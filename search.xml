<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APK--structure</title>
    <url>/2022/03/04/APK-structure/</url>
    <content><![CDATA[<p> 在遇到QQ上传播的3.99mb的恶搞apk之后，算是分析的第一个正儿八经的小程序，趁此学习一下基本的apk的文件结构。</p>
<span id="more"></span>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>apk实质上也是一个压缩包，解压之后得到如下文件：</p>
<p><img src="image-20220304195529813.png" alt="image-20220304195529813"></p>
<ul>
<li>lib：是动态库目录 一般存放so文件</li>
<li>META-INF目录：签名文件目录，只存在于签名后的apk文件中</li>
<li>res目录：资源库目录 ，一般存放xml布局文件和图标</li>
<li>AndroidMainifest.xml ：配置清单（二进制格式），每个应用程序都必须定义和包含的全局配置文件，它描述了应用程序的名称、版本、权限、引用的库文件等信息。如果动调java层的话会需要。</li>
<li>classes.dex：安卓系统上的可执行文件，也是我们逆向的主要的文件，源码都被编译在里面，如有多个是因为每个dex里最多存放<strong>65535</strong>个方法，而项目的方法数超出了这个数量，所以被分成多个保存</li>
<li>resources.arsc：资源索引文件，包含语言包，<strong>汉化</strong>的话一般是反编译这个文件</li>
<li>assets ：资源目录，一般存放图片</li>
</ul>
<h1 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h1><p>1.在该目录下会存放着一些so文件，apk为了安全，会将一些关键代码放到底层而不是java层，该层也是最容易被加密的，有时里会有不同的so文件，可能是同一文件对应的不同架构的平台，也可能是不同的so文件</p>
<p>2.市场上使用的移动终端大多是基于ARM或者ARM-V7a架构的，X86和MIPS架构的移动智能终端比较少，所以有些应用程序lib目录下只包含armeabi目录或者armeabi-v7a目录</p>
]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/27/First-test-blog/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">14</span>];</span><br><span class="line">    s=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>道生一，一生二，二生三，三生万物，万物负阴而抱阳，中气以为和。</p>
<p>​                                                                                                                        ——————————《道德经》</p>
]]></content>
      <tags>
        <tag>你好，世界</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr_2</title>
    <url>/2022/03/02/Angr-2/</url>
    <content><![CDATA[<p>Angr学习，一些其他的操作</p>
<span id="more"></span>
<h2 id="题目：15-angr-arbitrary-read"><a href="#题目：15-angr-arbitrary-read" class="headerlink" title="题目：15_angr_arbitrary_read"></a>题目：15_angr_arbitrary_read</h2><p>利用Angr实现内存地址的任意读</p>
<p>看到题目，得知这里是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s = try_again;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line"> __isoc99_scanf(<span class="string">&quot;%u %20s&quot;</span>, &amp;key, &amp;v4);</span><br><span class="line"> <span class="keyword">if</span> ( key == <span class="number">36134347</span> || key != <span class="number">41810812</span> )</span><br><span class="line">   <span class="built_in">puts</span>(try_again);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">puts</span>(s);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不论输入什么，得到的都是try again，这里通过angr让他输出编程goog，所以这里就要修改s的指针，good的地址在程序中给出了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./15_angr_arbitrary_read&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReScanf</span>(<span class="params">SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, para1, para2</span>):</span></span><br><span class="line">        in0 = BVS(<span class="string">&#x27;in1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">        in1 = BVS(<span class="string">&#x27;in2&#x27;</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> in1.chop(bits=<span class="number">8</span>):</span><br><span class="line">            self.state.add_constraints(char &gt;= <span class="string">&#x27;A&#x27;</span>, char &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        in1_addr = para1</span><br><span class="line">        in2_addr = para2</span><br><span class="line">        self.state.memory.store(in1_addr, in0, endness = p.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(in2_addr, in1)<span class="comment">#, endness = p.arch.memory_endness)</span></span><br><span class="line"></span><br><span class="line">        self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>] = (in0, in1)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">p.hook_symbol(name, ReScanf())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_out</span>(<span class="params">state</span>):</span></span><br><span class="line"></span><br><span class="line">    puts_para = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness = p.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_para):</span><br><span class="line"></span><br><span class="line">        good_addr = <span class="number">0x594e4257</span></span><br><span class="line"></span><br><span class="line">        copid_state = state.copy()</span><br><span class="line">        copid_state.add_constraints(puts_para == good_addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> copid_state.satisfiable():</span><br><span class="line">            state.add_constraints(puts_para == good_addr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        puts_address = <span class="number">0x8048370</span></span><br><span class="line">        <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">            <span class="keyword">return</span> check_out(state)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find = is_successful)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    (in0, in1) = solution_init.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(solution_init.solver.<span class="built_in">eval</span>(in0))</span><br><span class="line">    <span class="built_in">print</span>(solution_init.solver.<span class="built_in">eval</span>(in1,cast_to = <span class="built_in">bytes</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实就是利用了scanf的栈溢出，来达到目的</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>CGnetsw修改器</title>
    <url>/2021/12/16/CGnetsw%E4%BF%AE%E6%94%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="CGnetsw修改器"><a href="#CGnetsw修改器" class="headerlink" title="CGnetsw修改器"></a>CGnetsw修改器</h1><span id="more"></span>
<h2 id="断网的原理"><a href="#断网的原理" class="headerlink" title="断网的原理"></a>断网的原理</h2><p>通过删除本机路由，并写入cg平台自己的ip于hosts文件，实现只能访问CG平台的功能。</p>
<p>关闭程序后，将本机路由进行恢复，实现正常上网。</p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>通过ida联合动调，找到断网函数的位置：</p>
<p><img src="image-20211216192901951.png" alt="image-20211216192901951"></p>
<p>这个函数执行之后实现本机断网。</p>
<p>修改思路：将函数nop之后平衡堆栈，使程序正常运行</p>
<h3 id="2020版"><a href="#2020版" class="headerlink" title="2020版"></a>2020版</h3><p>这是我遇到的第一版的断网程序</p>
<p><img src="image-20211216193056827.png" alt="image-20211216193056827"></p>
<p>gcc编译，32位，无壳</p>
<p>IDA中查看winmain函数</p>
<p><img src="image-20211216193345120.png" alt="image-20211216193345120"></p>
<h4 id="大体分析："><a href="#大体分析：" class="headerlink" title="大体分析："></a>大体分析：</h4><ol>
<li><p>首先进行一个ip地址的获取放在<code>String</code>中，如果没有获取到正确的ip，那么就将CG平台的主ip进行赋值（各个学校有不同的ip地址）。</p>
</li>
<li><p>然后进行日志记录（这里不是很清楚为什么记录日志）。</p>
</li>
<li>v14和下面的语句实现了一个字符的拼接功能，用处不大。</li>
<li>v15和<code>SetWindowTextW</code>函数实现了窗口的初始化，没啥用。</li>
<li>下面对hosts表进行了修改，然后进去了<code>deleteip</code>函数。</li>
</ol>
<p>在<code>deleteip</code>函数中，找到删除本机路由的函数</p>
<p><img src="image-20211216194126785.png" alt="image-20211216194126785"></p>
<p>删除路由的函数成功返回0，也就是说这里不能执行判断里面的内容</p>
<p><img src="image-20211216194236740.png" alt="image-20211216194236740"></p>
<p>看到这里的汇编代码</p>
<p><img src="image-20211216194336541.png" alt="image-20211216194336541"></p>
<p>eax一定为 “ 1 ” ，也就是0x401edd处的跳转实现，否则程序就会意外终止或者不能达到效果。</p>
<p>这里看到函数的调用规则<code>__cdecl</code> ，这里思路将delete函数nop掉，这样没有调用函数，esp就通过-0恢复，（我认为对程序的修改越小越好，所以就没有将<code>sub esp , 4</code>全nop掉）。再看到下面的<code>test eax,eax</code> ，若把delete函数nop之后，<code>eax == 1</code> 这里显然如果要跳转的话需要=0，所以这里直接将<code>test</code>指令修改为<code>cmp</code>指令，他俩指令的占字节位是一样的。</p>
<h4 id="给出脚本："><a href="#给出脚本：" class="headerlink" title="给出脚本："></a>给出脚本：</h4><p>这里我通过C语言直接修改文件中相对的机器码来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> nop_cmp[]=&#123;<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x83</span> ,<span class="number">0xEC</span> ,<span class="number">0x00</span> ,<span class="number">0x39</span>&#125;;</span><br><span class="line"><span class="comment">//这是将程序修改之后对应的机器码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* p;</span><br><span class="line">    p=fopen(<span class="string">&quot;CGnetsw.exe&quot;</span>,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败，请手动填写文件名\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">        p=fopen(name , <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(p,<span class="number">0x12d5</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">//要修改的机器码对应文件头的偏移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(&amp;nop_cmp[i],<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">1</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success\n&quot;</span>);</span><br><span class="line">    fclose(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样文件就可以远程欺骗CG平台，同时本地也可以上网。（经实测得到）</p>
<h3 id="2021版"><a href="#2021版" class="headerlink" title="2021版"></a>2021版</h3><p>CG平台对程序进行了改版，临近期末，便不再深究改了哪里，直接寻找关键函数</p>
<h4 id="大体分析：-1"><a href="#大体分析：-1" class="headerlink" title="大体分析："></a>大体分析：</h4><p>依旧是32位无壳GCC编译的小程序</p>
<p><img src="image-20211216200044105.png" alt="image-20211216200044105"></p>
<p>ida中查看，程序明显的改动是先进行修改hosts，删除路由，然后再生成窗口。</p>
<p>思路同上一版本相似，但是main函数中多出一个判断</p>
<p><img src="image-20211216200304369.png" alt="image-20211216200304369"></p>
<p>这个判断经过分析实测，在win10系统中第一次运行会进行重启电脑的操作，产生的压缩包内有两个注册表文件，猜测这里应该是为了适应不同版本的功能。</p>
<p>压缩包内文件：</p>
<p><img src="image-20211216200443647.png" alt="image-20211216200443647"></p>
<p>时间有点古怪，可能是我电脑运行过老程序的问题，这里不做深究。</p>
<p>看到下面依旧是进行dns的修改，然后删除本机路由</p>
<p><img src="image-20211216200629735.png" alt="image-20211216200629735"></p>
<p>这里的三联ip串包括：cg平台的ip，本机的dns服务器地址，114.114.114.114（三大运营商通用dns服务器地址），三个地址通过逗号连接。</p>
<h4 id="给出脚本：-1"><a href="#给出脚本：-1" class="headerlink" title="给出脚本："></a>给出脚本：</h4><p>进入关键函数，和2020版基本一样，这里只需要更改一下去年的偏移即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> nop_cmp[]=&#123;<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x90</span> ,<span class="number">0x83</span> ,<span class="number">0xEC</span> ,<span class="number">0x00</span> ,<span class="number">0x39</span>&#125;;</span><br><span class="line"><span class="comment">//这是将程序修改之后对应的机器码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* p;</span><br><span class="line">    p=fopen(<span class="string">&quot;CGnetsw.exe&quot;</span>,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败，请手动填写文件名\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">        p=fopen(name , <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(p,<span class="number">0x1f15</span>,SEEK_SET);</span><br><span class="line">    <span class="comment">//要修改的机器码对应文件头的偏移，这里是2020和2021不一样的地方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(&amp;nop_cmp[i],<span class="keyword">sizeof</span>(<span class="keyword">char</span>),<span class="number">1</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success\n&quot;</span>);</span><br><span class="line">    fclose(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然对程序进行了升级，但是关键地方还是老样子，没有远程验证，这个我估计以后会加上去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望大家认真考试，不要总是想着这些歪门邪道。<strong>攻防无界</strong></p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Dev-C++配置</title>
    <url>/2022/05/02/Dev-C-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;VS过于臃肿并且无法直接对C文件进行编译操作，所以我又又又回到了DEVcpp。</p>
<span id="more"></span>
<p>&emsp;&emsp;Dev&emsp;cpp原版已经停止更新很久了，这里我下载的是由之后的公司续命的新版<a href="https://github.com/Embarcadero/Dev-Cpp/releases/tag/v6.3">Embarcadero-Dev</a>,&emsp;下载之后并不自带编译器，需要配置，简单记录以下配置过程方便以后查看。</p>
<h1 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h1><h2 id="新建编译器"><a href="#新建编译器" class="headerlink" title="新建编译器"></a>新建编译器</h2><p><img src="image-20220502201833060.png" alt="image-20220502201833060"></p>
<p>找到编译选项，新建一个编译选项。</p>
<p><img src="image-20220502201912845.png" alt="image-20220502201912845"></p>
<p>第二个加号，名字随便取，建议【名称+版本】的方式。</p>
<p>&emsp;&emsp;在编译时加入以下命令是为了gbk编码可以正常的输出中文。下面的连接器命令是静态编译，防止了缺库不能运行的弊端。</p>
<p><img src="image-20220502202055507.png" alt="image-20220502202055507"></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-fexec-charset=GBK</span></span><br><span class="line"><span class="deletion">-static-libgcc</span></span><br></pre></td></tr></table></figure>
<h2 id="配置编译器-1"><a href="#配置编译器-1" class="headerlink" title="配置编译器"></a>配置编译器</h2><p><img src="image-20220502202305831.png" alt="image-20220502202305831"></p>
<p>&emsp;在目录下，把对应的编译器的路径写上去，这四个都写，最后两个的路径是一样的。</p>
<p>之后在最后一栏的程序这里：</p>
<p><img src="image-20220502202422307.png" alt="image-20220502202422307"></p>
<p>&emsp;如果有多个编译器的话，这里在第二个编译器建议写绝对路径，不然默认还是第一个编译器的路径。编译器就配置成功了。</p>
<h1 id="完善DEV"><a href="#完善DEV" class="headerlink" title="完善DEV"></a>完善DEV</h1><h2 id="中文字体显式"><a href="#中文字体显式" class="headerlink" title="中文字体显式"></a>中文字体显式</h2><p>&emsp;&emsp;默认情况下，中文字体只有在鼠标点上去才会显式，通过修改编译器选项里的中间的编码格式可以解决。</p>
<p><img src="image-20220502202709993.png" alt="image-20220502202709993"></p>
<p>&emsp;&emsp;将其改成UTF-8。然后在第二栏显式里，不选字体里的那个选项（就一个）这样就可以正常显式中文&emsp;。</p>
<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>&emsp;&emsp;通过修改语法选项里的预设的GSS&emsp;hacker主题，可以让输入框变成黑色，但是周围还是白色的，这里要再修改环境选项里的apperance里的主题来修改边框的颜色，同时修改才能达到全黑的效果。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghidra学习</title>
    <url>/2022/03/28/Ghidra%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Garbage</title>
    <url>/2022/03/09/PE-ctf1/</url>
    <content><![CDATA[<p> 题目来源于Flare-on2020，的garbage，题目和PE的文件结构息息相关，记录一下解题思路</p>
<span id="more"></span>
<h1 id="garbage"><a href="#garbage" class="headerlink" title="garbage"></a>garbage</h1><h2 id="修文件"><a href="#修文件" class="headerlink" title="修文件"></a>修文件</h2><p>根据给出的提示，知道这是一个破损的upx加壳的pe文件，首先想到用loadPE进行重建，失败。</p>
<p>查看文件的16进制，最下面可以看到：</p>
<p><img src="image-20220304140723392.png" alt="image-20220304140723392"></p>
<p>这里感觉就是文件并没有写完，然后看到WP，用到一个强大的PEviewer：CFF</p>
<p>得知上图看到的是一个截断的 <strong>manifest</strong> 段</p>
<blockquote>
<p>这个文件可以单独存在，也可以内嵌到PE文件中，<strong>默认就是内嵌到PE文件中。</strong>保存了程序集所依赖的所有程序集</p>
</blockquote>
<p>upx只能用脚本脱壳，程序跑不起来，脚本脱壳报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upx: upxed.exe: OverlayException: invalid overlay size; file is possibly corrupt</span><br></pre></td></tr></table></figure>
<p>这里用CFF解析文件。文件里的manifest段错误，所以可以定位到程序的<code>.rsrc</code>段，因为manifest在rsrc中。 (<strong>.rsrc节区可能会存放一个PE文件或者关键字符串</strong>)</p>
<p><img src="image-20220304142059443.png" alt="image-20220304142059443"></p>
<p>看到这里的RAW Size和Raw Address，地址是从9E000开始的，大小是400h，再回到winHEX，程序的大小应该是在（9E00+0X400）大小，这样直接用0补全程序大小，然后upx可以顺利脱壳了。</p>
<p>脱壳之后，ida打开</p>
<p><img src="image-20220304142855088.png" alt="image-20220304142855088"></p>
<p>看到这样的信息，没有成功的解析出函数，在之前遇到的一个病毒，在进行aspack脱壳之后也遇到了这样的问题。</p>
<p>没有函数，那就要去看一下她的IAT，ida找到import窗口，啥也没有，确定问题就出现在这里，回到CFF继续修题</p>
<p><img src="image-20220304143108539.png" alt="image-20220304143108539"></p>
<p>看到名字这里是空的，点击这里，会看到：</p>
<p><img src="image-20220304143225409.png" alt="image-20220304143225409"></p>
<p>这些函数，这些函数百度得知在kernel.dll文件里，这里将名称补全，下面哪一行也一样</p>
<p><img src="image-20220304143431693.png" alt="image-20220304143431693"></p>
<p>这是再用ida打开程序，可以正常分析了</p>
<p><img src="image-20220304143511112.png" alt="image-20220304143511112"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到<code>WriteFile</code>,第二个参数是写进去的内容，直接分析上面那函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_DWORD *__thiscall <span class="title">sub_401000</span><span class="params">(_DWORD *<span class="keyword">this</span>, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> v11, <span class="keyword">int</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// edi</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  *<span class="keyword">this</span> = a2;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">1</span>] = a3;</span><br><span class="line">  <span class="keyword">this</span>[<span class="number">2</span>] = v11;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">this</span>[<span class="number">3</span>] = <span class="number">102</span>; v5 &lt; <span class="keyword">this</span>[<span class="number">1</span>]; ++v5 )     <span class="comment">// 20</span></span><br><span class="line">    *(_BYTE *)(*<span class="keyword">this</span> + v5) ^= *(_BYTE *)(v5 % <span class="keyword">this</span>[<span class="number">3</span>] + <span class="keyword">this</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面给出的字符串，进行 解密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v10 = <span class="string">&quot;nPTnaGLkIqdcQwvieFQKGcTGOTbfMjDNmvibfBDdFBhoPaBbtfQuuGWYomtqTFqvBSKdUMmciqKSGZaosWCSoZlcIlyQpOwkcAgw &quot;</span></span><br><span class="line">v11 = <span class="string">&quot;KglPFOsQDxBPXmclOpmsdLDEPMRWbMDzwhDGOyqAkVMRvnBeIkpZIhFznwVylfjrkqprBPAdPuaiVoVugQAlyOQQtxBNsTdPZgDH &quot;</span></span><br><span class="line"></span><br><span class="line">v14 = [<span class="number">0x38</span>, <span class="number">0x0E</span>, <span class="number">0x02</span>, <span class="number">0x3B</span>, <span class="number">0x19</span>, <span class="number">0x3B</span>, <span class="number">0x1B</span>, <span class="number">0x34</span>, <span class="number">0x1B</span>, <span class="number">0x0C</span>, <span class="number">0x23</span>,</span><br><span class="line">       <span class="number">0x3E</span>, <span class="number">0x33</span>, <span class="number">0x08</span>, <span class="number">0x11</span>, <span class="number">0x42</span>, <span class="number">0x39</span>, <span class="number">0x12</span>, <span class="number">0x1E</span>, <span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line">v12 = [ <span class="number">0x23</span>, <span class="number">0x23</span>, <span class="number">0x33</span>, <span class="number">0x2C</span>,  <span class="number">0x0E</span>, <span class="number">0x3F</span>, <span class="number">0x64</span>, <span class="number">0x49</span>,  <span class="number">0x0A</span>, <span class="number">0x1E</span>, <span class="number">0x0A</span>, <span class="number">0x04</span>,  <span class="number">0x23</span>, <span class="number">0x16</span>, <span class="number">0x02</span>, <span class="number">0x1A</span>,</span><br><span class="line">        <span class="number">0x44</span>, <span class="number">0x66</span>, <span class="number">0x08</span>, <span class="number">0x24</span>, <span class="number">0x32</span>, <span class="number">0x11</span>, <span class="number">0x74</span>, <span class="number">0x2C</span>, <span class="number">0x2A</span>, <span class="number">0x2D</span>, <span class="number">0x42</span>, <span class="number">0x0F</span>, <span class="number">0x3E</span>, <span class="number">0x50</span>, <span class="number">0x64</span>, <span class="number">0x0D</span>,</span><br><span class="line">        <span class="number">0x5D</span>, <span class="number">0x04</span>, <span class="number">0x1B</span>, <span class="number">0x17</span>,  <span class="number">0x16</span>, <span class="number">0x36</span>, <span class="number">0x03</span>, <span class="number">0x05</span>, <span class="number">0x34</span>, <span class="number">0x20</span>, <span class="number">0x09</span>, <span class="number">0x08</span>, <span class="number">0x63</span>, <span class="number">0x21</span>,  <span class="number">0x24</span>, <span class="number">0x0E</span>,</span><br><span class="line">        <span class="number">0x15</span>, <span class="number">0x14</span>, <span class="number">0x34</span>, <span class="number">0x58</span>, <span class="number">0x1A</span>, <span class="number">0x29</span>, <span class="number">0x79</span>, <span class="number">0x3A</span>,  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x58</span>, <span class="number">0x54</span>]</span><br><span class="line"></span><br><span class="line">this_3 = <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):			<span class="comment">#文件名</span></span><br><span class="line">    v14[i] =<span class="built_in">chr</span>(v14[i] ^ <span class="built_in">ord</span>(v11[(i%this_3)]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(v14))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(v12)):	<span class="comment">#内容</span></span><br><span class="line">    v12[i] = <span class="built_in">chr</span>(v12[i] ^ <span class="built_in">ord</span>(v10[(i%this_3)]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(v12))</span><br><span class="line"><span class="comment">#得到下面文件</span></span><br><span class="line">sink_the_tanker.vbs </span><br><span class="line">MsgBox(<span class="string">&quot;Congrats! Your key is: C0rruptGarbag3@flare-on.com&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>apk重打包动态调试</title>
    <url>/2022/01/17/JEB%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>  以一道apk题目学习apk重打包并进行动态调试</p>
<span id="more"></span>
<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p> 看到题目，看解压的文件就知道有native层的操作</p>
<p>看到dex文件的<code>onGoClick()</code>类</p>
<p><img src="image-20220117204226432.png" alt="image-20220117204226432"></p>
<p>判断的思路是：对输入进行<code>encrypt</code> <code>getSecret</code>方法的加密之后，和 <code>getSecret</code>方法加密的<code>getFlag</code>值进行比较。</p>
<p>两边都进行了同样的加密，所以可以简化程序为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( getFlag() .equal ( encrypt(input) ) )</span><br><span class="line">&#123;</span><br><span class="line">    success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>encrypt</code>方法和<code>getFlag</code>方法都在lib文件里</p>
<p>看到lib文件，简单明了</p>
<p><strong>encrypt函数</strong></p>
<p><img src="image-20220117204714356.png" alt="image-20220117204714356"></p>
<p>先改第一个参数类型为<code>JNIEnv *env</code>，正确解析出两个函数，看到for循环，作用是把a1的每一个值-1。</p>
<p><strong>getFlag函数</strong></p>
<p><img src="image-20220117204926055.png" alt="image-20220117204926055"></p>
<p>考虑到这个函数没有输入对他的影响，所以这里直接动调得到返回值</p>
<p>经过JEB动调，返回值是：</p>
<figure class="highlight parser3"><table><tr><td class="code"><pre><span class="line"><span class="xml">ek`fz@q2</span><span class="keyword">^x</span><span class="xml">/t</span><span class="keyword">^fn0mF</span><span class="keyword">^6</span><span class="xml">/</span><span class="keyword">^rb</span><span class="xml">`qanqntfg</span><span class="keyword">^E</span><span class="xml">`hq|</span></span><br></pre></td></tr></table></figure>
<p>思路就是我的输入每一个字节-1，等于返回值，所以直接把返回值每字节+1即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">1</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#flag&#123;Ar3_y0u_go1nG_70_scarborough_Fair&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="JEB动态调试"><a href="#JEB动态调试" class="headerlink" title="JEB动态调试"></a>JEB动态调试</h1><h2 id="0-大体步骤"><a href="#0-大体步骤" class="headerlink" title="0.大体步骤"></a>0.大体步骤</h2><p><img src="image-20220117210304834.png" alt="image-20220117210304834"></p>
<h2 id="1-能否调试"><a href="#1-能否调试" class="headerlink" title="1.能否调试"></a>1.能否调试</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查看解压之后的 <code>AndroidManifest.xml</code> 文件，看是否有</p>
<p><img src="image-20220117210502192.png" alt="image-20220117210502192"></p>
<p>android:debuggable属性，如果没有就手动添加上 <code>android:debuggable=&quot;true&quot;</code> ，如果是false的话就改成true。</p>
<p><strong>解压方式：</strong>可以用一般的解压软件直接解压，或者是用apktool进行解压</p>
<p><strong>apktool：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apktool d ###.apk</span><br><span class="line">apktool b 文件夹名</span><br></pre></td></tr></table></figure>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>如果需要修改的话，就需要对apk文件进行解包修改，拆电视机容易，组装可就难了</p>
<p>再改完之后，通过apktool进行重打包</p>
<h4 id="apk解包"><a href="#apk解包" class="headerlink" title="apk解包"></a>apk解包</h4><p><img src="image-20220117212514460.png" alt="image-20220117212514460"></p>
<p>同目录下找到同名文件夹</p>
<p>这里如果是一般解压的话， <code>AndroidManifest.xml</code> 文件会被当作是二进制文件无法被打开，apktool解包的话，vscode正常打开，在进行必要的修改之后保存。</p>
<h4 id="apk打包"><a href="#apk打包" class="headerlink" title="apk打包"></a>apk打包</h4><p><img src="image-20220117213017020.png" alt="image-20220117213017020"></p>
<p>打包之后在文件夹中找到dist文件夹，里的新的apk文件。</p>
<h4 id="apk签名"><a href="#apk签名" class="headerlink" title="apk签名"></a>apk签名</h4><p>仅仅是打包的文件还是不能运行的，在<code>adb insall</code> 的时候也会报错，拖进模拟器会无法安装。</p>
<p><strong>为什么要签名：</strong></p>
<ul>
<li><p>由于开发商可能通过使用相同的 Package Name 来混淆替换已经安装的程序，以此保证签名不同的包不被替换</p>
</li>
<li><p>保证信息传输的完整性。签名对于包中的每个文件进行处理，以此确保包中内容不被替换</p>
</li>
<li><p>防止交易中的抵赖发生， Market 对软件的要求</p>
</li>
</ul>
<p>这里使用jdk自带的两个工具：keytool和jarsigner工具，在jdk目录中，这里方便起见先把jdk的bin目录添加在环境变量。</p>
<p>用keytool获得密钥，用后者进行签名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">keytool -genkey -<span class="built_in">alias</span> demo.keystore -keyalg RSA -validity 100 -keystore demo.keystore</span></span><br><span class="line"></span><br><span class="line">输入密钥库口令:</span><br><span class="line">密钥库口令太短 - 至少必须为 6 个字符</span><br><span class="line">输入密钥库口令:</span><br><span class="line">再次输入新口令:</span><br><span class="line">您的名字与姓氏是什么?</span><br><span class="line">  [Unknown]:  r</span><br><span class="line">您的组织单位名称是什么?</span><br><span class="line">  [Unknown]:  oo</span><br><span class="line">您的组织名称是什么?</span><br><span class="line">  [Unknown]:  t</span><br><span class="line">您所在的城市或区域名称是什么?</span><br><span class="line">  [Unknown]:  k</span><br><span class="line">您所在的省/市/自治区名称是什么?</span><br><span class="line">  [Unknown]:  i</span><br><span class="line">该单位的双字母国家/地区代码是什么?</span><br><span class="line">  [Unknown]:  t</span><br><span class="line">CN=r, OU=oo, O=t, L=k, ST=i, C=t是否正确?</span><br><span class="line">  [否]:  Y</span><br><span class="line"></span><br><span class="line">输入 &lt;demo.keystore&gt; 的密钥口令</span><br><span class="line">        (如果和密钥库口令相同, 按回车):</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">jarsigner -keystore demo.keystore -signedjar 新.apk 打包的.apk demo.keystore</span></span><br><span class="line"></span><br><span class="line">输入密钥库的密码短语:</span><br><span class="line">jar 已签名。</span><br></pre></td></tr></table></figure>
<p>之后会生成一个新的apk文件，这个文件就可以正常使用了</p>
<h2 id="2-推送到安卓设备"><a href="#2-推送到安卓设备" class="headerlink" title="2.推送到安卓设备"></a>2.推送到安卓设备</h2><h3 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h3><p>adb连接，通过 <code>adb install mulu/aaa.apk</code> </p>
<h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p>直接拖进去，命令 <code>adb connect 127.0.0.1:端口</code>，不同的模拟器有不同的端口，夜神模拟器的端口是62001. </p>
<h2 id="3-JEB附加调试"><a href="#3-JEB附加调试" class="headerlink" title="3.JEB附加调试"></a>3.JEB附加调试</h2><p>apk文件拖进jeb，在disassemble界面通过ctrl+b下断点。</p>
<p><img src="image-20220117211555191.png" alt="image-20220117211555191"></p>
<p>点击调试器里的开始调试，弹出进程选择界面</p>
<p><img src="image-20220117211711571.png" alt="image-20220117211711571"></p>
<p>这里直接附上就可以调试了，这时可以看到jeb会出现三个窗口</p>
<p><img src="image-20220117214426692.png" alt="image-20220117214426692"></p>
<p>这里主要关注的是局部变量，输入之后停在断点处。</p>
<p>通过f6单步调试</p>
<p><img src="image-20220117214735007.png" alt="image-20220117214735007"></p>
<p>这里注意v1的变量类型，string的s小写，单击可以修改</p>
<p><img src="image-20220117214818299.png" alt="image-20220117214818299"></p>
<p>这就可以得到这个函数的返回值了，就可以解题了。</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>PEviewer</title>
    <url>/2021/09/26/PEviewer/</url>
    <content><![CDATA[<p>​    为了深入理解PE文件的结构，又参考多方资料，代码，思路，图片，讲解等等，用C语言写了一个简陋，不完善的PEviewer，代码如下，vscode运行不会报错</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">IMAGE_DOS_HEADER dosheader;<span class="comment">//Dos头</span></span><br><span class="line">IMAGE_FILE_HEADER fileheader;<span class="comment">//文件头</span></span><br><span class="line">IMAGE_SECTION_HEADER SectionHeader;<span class="comment">//节区头</span></span><br><span class="line">IMAGE_OPTIONAL_HEADER32 optionalheader;<span class="comment">//NT头里的可选头	</span></span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR iid;<span class="comment">//IID</span></span><br><span class="line">DWORD PointerToPeHeader = <span class="number">0</span>;</span><br><span class="line">DWORD Size_Of_File = <span class="number">0</span>;</span><br><span class="line">DWORD Pe_Signature = <span class="number">0</span>;</span><br><span class="line">WORD Size_Of_Opt_Header = <span class="number">0</span>;</span><br><span class="line">WORD subsys = <span class="number">0</span>;</span><br><span class="line">DWORD Addr_of_EP = <span class="number">0</span>;</span><br><span class="line">DWORD PtrIdata = <span class="number">0</span>;</span><br><span class="line">DWORD ImageBase = <span class="number">0</span>;</span><br><span class="line">DWORD ImportsVA = <span class="number">0</span>;</span><br><span class="line">DWORD ImportsSize = <span class="number">0</span>;</span><br><span class="line">DWORD ImportDirAddr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> NrOfSections = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionInfo</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> VA;</span><br><span class="line">        <span class="keyword">int</span> VirtualSize;</span><br><span class="line">        <span class="keyword">int</span> SizeOfRAW;</span><br><span class="line">        <span class="keyword">int</span> Ptr2RAW;<span class="comment">//是一个文件偏移地址(FOA),该节区在硬盘文件中的地址</span></span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_section</span><span class="params">(struct SectionInfo *section_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s节区:\n&quot;</span>, section_info-&gt;name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t装如内存虚拟空间后的地址（RVA） : 0x%x\n&quot;</span>, section_info-&gt;VA);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t该节区装入内存后的总大小: %d byte\n&quot;</span>, section_info-&gt;VirtualSize);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t该节区在硬盘文件中的地址(FOA) : 0x%x\n&quot;</span>, section_info-&gt;Ptr2RAW);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t该节区在硬盘上初始化数据的大小 : %d byte\n&quot;</span>, section_info-&gt;SizeOfRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[] = <span class="string">&quot;ty.exe&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请将测试文件与本程序放在同一目录下\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入文件名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;测试文件%s\n&quot;</span>,name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------文件信息-----------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">    FILE* fp;</span><br><span class="line"></span><br><span class="line">    fp=fopen(name , <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//读取DOS头&quot;MZ&quot;</span></span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    fread(&amp;dosheader , <span class="number">1</span> , <span class="keyword">sizeof</span>(dosheader) , fp);<span class="comment">//从fp流里面读出&quot;MZ&quot;</span></span><br><span class="line">    WORD MZ=dosheader.e_magic;</span><br><span class="line">    <span class="keyword">if</span>(MZ != <span class="number">0x5a4d</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这不是PE文件，或者你把DOS头删了\nfuck you\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PE文件的Dos头是：%x\n&quot;</span>,MZ);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DOS结构体里面有两个重要成员：e_magic(MZ)  e_lfanew\n&quot;</span>);</span><br><span class="line">    WORD NToffset=dosheader.e_lfanew;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NT头的偏移 = 0x%x\n&quot;</span>,NToffset);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//寻找NT头</span></span><br><span class="line">    fseek(fp,NToffset,SEEK_SET);</span><br><span class="line">    fread(&amp;Pe_Signature,<span class="number">1</span>,<span class="keyword">sizeof</span>(Pe_Signature),fp);</span><br><span class="line">    WORD signature=Pe_Signature;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PE签名是：%x\n&quot;</span>,signature);</span><br><span class="line">    <span class="keyword">if</span>(signature != <span class="number">0x4550</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你PE头呢？\nFuck you&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//文件头结构体</span></span><br><span class="line">    fread(&amp;fileheader,<span class="number">1</span>,<span class="keyword">sizeof</span>(fileheader),fp);</span><br><span class="line">    WORD m_code=fileheader.Machine;</span><br><span class="line">    <span class="keyword">if</span> (m_code==<span class="number">0x014c</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该CPU是intel-386(X32)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m_code==<span class="number">0x8664</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该CPU是（X64）\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;谁知道你这是么cpu，自己百度去\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//节区数</span></span><br><span class="line">    <span class="keyword">if</span> (fileheader.NumberOfSections==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不可能有0个节区\n&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WORD section_num=fileheader.NumberOfSections;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件一共有%x个节区\n&quot;</span>,fileheader.NumberOfSections);</span><br><span class="line"><span class="comment">//可选头大小</span></span><br><span class="line">    WORD optional_header_size=fileheader.SizeOfOptionalHeader;</span><br><span class="line">    <span class="keyword">int</span> xbit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (optional_header_size==<span class="number">0xE0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xbit=<span class="number">32</span>;</span><br><span class="line">        <span class="comment">// pritnf(&quot;这是一个32位程序\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xbit=<span class="number">64</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;这是一个64位程序\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可选头结构体的大小是：0x%x\n这是一个X%d程序\n&quot;</span>,optional_header_size,xbit);</span><br><span class="line"><span class="comment">//找到可选头</span></span><br><span class="line">    fread(&amp;optionalheader,<span class="number">1</span>,optional_header_size,fp);</span><br><span class="line">    </span><br><span class="line">    subsys=optionalheader.Subsystem;</span><br><span class="line">    <span class="keyword">if</span> (subsys==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这是一个Windows GUI 子系统\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(subsys==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这是一个Windows 控制台子系统\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;俺也不知道了，恁自己查吧\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DWORD iid_addr=optionalheader.DataDirectory[<span class="number">1</span>].VirtualAddress;</span><br><span class="line">    DWORD iid_size=optionalheader.DataDirectory[<span class="number">1</span>].Size;</span><br><span class="line"></span><br><span class="line">    DWORD ope_addr=optionalheader.AddressOfEntryPoint;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序最先执行的代码的地址(RVA)是：0x%x&quot;</span>,ope_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;如果想要在一个可执行文件中附加了一段代码并且要让这段代码首先被执行，就可以通过更改入口地址到目标代码上，然后再跳转回原有的入口地址。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;就像upx压缩那样\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;代码节的起始地址：0x%x, &quot;</span>,optionalheader.BaseOfCode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据节的起始地址：0x%x\n&quot;</span>,optionalheader.BaseOfData);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//打印出所有的节区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SectionInfo</span> <span class="title">section_info</span>[<span class="title">section_num</span>];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;section_num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;SectionHeader,<span class="number">1</span>,<span class="keyword">sizeof</span>(SectionHeader),fp);</span><br><span class="line">        <span class="built_in">memcpy</span>(section_info[i].name,SectionHeader.Name,<span class="number">10</span>);        </span><br><span class="line">        section_info[i].VA=SectionHeader.VirtualAddress;</span><br><span class="line">        section_info[i].VirtualSize=SectionHeader.Misc.VirtualSize;</span><br><span class="line">        <span class="comment">//这个成员指定了该节区装入内存后的总大小，以字节为单位</span></span><br><span class="line">        section_info[i].Ptr2RAW=SectionHeader.PointerToRawData;</span><br><span class="line">        print_section(&amp;section_info[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//RVA---&gt;RAW</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RVA2RAW</span><span class="params">(<span class="keyword">int</span> rva)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,raw;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;section_num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((rva&gt;=section_info[i].VA) &amp;&amp; (rva&lt;=(section_info[i].VA + section_info[i].VirtualSize)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//RAW = RVA - VA + PointerToRawData</span></span><br><span class="line">                raw = rva - section_info[i].VA + section_info[i].VirtualSize;</span><br><span class="line">                <span class="keyword">return</span> raw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试打印出dll的名称</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IID结构体的大小：%d\n&quot;</span>,iid_size);</span><br><span class="line">    <span class="keyword">int</span> IID_addr=RVA2RAW(iid_addr);</span><br><span class="line">    fseek(fp,IID_addr,SEEK_SET);</span><br><span class="line">    fread(&amp;iid,<span class="number">1</span>,<span class="number">20</span>,fp); <span class="comment">//read the first Import</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(iid.Name!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fread(&amp;iid,<span class="number">1</span>,<span class="number">20</span>,fp);	</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	IMAGE_IMPORT_DESCRIPTOR Imported[count<span class="number">-1</span>];</span><br><span class="line">	fseek(fp, iid_addr, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char *dll_name;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count<span class="number">-1</span>);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fread(&amp;Imported[i],<span class="number">1</span>,<span class="number">20</span>,fp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] DLL文件的名称在地址 0x%lx 处。\n&quot;</span>, i, Imported[i].Name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//尝试获取dll的名称，失败</span></span><br><span class="line">        <span class="comment">// if (i==3)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     fseek(fp,Imported[i].Name,SEEK_SET);</span></span><br><span class="line">        <span class="comment">//     fread(&amp;name,1,10,fp);</span></span><br><span class="line">        <span class="comment">//     printf(&quot;--%s--\n&quot;,dll_name);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件用到的DLL：\n&quot;</span>);</span><br><span class="line"><span class="comment">// //尝试获取dll的名称，失败</span></span><br><span class="line"><span class="comment">//     DWORD DLL_NAME;</span></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;(count-1);i++)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         DLL_NAME = RVA2RAW(Imported[i].Name);//找出name的RAW</span></span><br><span class="line"><span class="comment">//         // DLL_NAME = Imported[i].Name;</span></span><br><span class="line"><span class="comment">//         fseek(fp , DLL_NAME , SEEK_SET);//定位文件</span></span><br><span class="line"><span class="comment">//         do</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             char c;</span></span><br><span class="line"><span class="comment">//             c = fgetc(fp);//按字节获取地址里的内容</span></span><br><span class="line"><span class="comment">//             if (c==0)//ascii字符串用0结尾</span></span><br><span class="line"><span class="comment">//             &#123;</span></span><br><span class="line"><span class="comment">//                 printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//                 break;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             printf(&quot;%c&quot;,c);</span></span><br><span class="line"><span class="comment">//         &#125; while (1);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该PEviewer能够准确的识别PE文件的位数，节区数等等，有些也不能准确识别，后期会不定期改进，先发上来，有意见和建议或者指出错误或者告诉我怎么识别dll名称的，欢迎联系我（QQ：MTYyMTA0Mzk4Ng==）</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode环境配置</title>
    <url>/2021/09/07/VScode/</url>
    <content><![CDATA[<p> 最近发现dev c++喜欢报一些奇奇怪怪的错，所以这里将阵地转移到了Vscode，看看网上吹的是不是都是真的，记录一下配置的过程</p>
<span id="more"></span>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>vscode这个软件</li>
<li>Windows下的这个gcc</li>
</ul>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="下载编译器："><a href="#下载编译器：" class="headerlink" title="下载编译器："></a>下载编译器：</h2><p>先下载gcc，安装，将其中的bin目录的地址给到path路径下，然后将include的路径也给到path</p>
<p><img src="VScode/image-20210907141602495.png" alt="image-20210907141602495" style="zoom:150%;" /></p>
<p>然后打开dos窗口输入【gcc -v】出现</p>
<p><img src="image-20210907141708826.png" alt="image-20210907141708826"></p>
<p>这些东西就说明安装好了</p>
<h2 id="配置VScode："><a href="#配置VScode：" class="headerlink" title="配置VScode："></a>配置VScode：</h2><p>打开vscode</p>
<p>1.首先在插件商店安装汉化插件，C语言插件，运行插件</p>
<p><img src="image-20210907142042232.png" alt="image-20210907142042232"></p>
<p>这样就完成了基本的配置，重启一下软件让他们生效</p>
<p>2.然后开始配置以些文件</p>
<ul>
<li><p>先进入一个文件夹，这里我新创建了一个</p>
</li>
<li><p>按快捷键Ctrl+Shift+P调出命令面板，输入”C/C++“，选择“Edit Configurations(UI)”进入配置。这里配置两个选项： - 编译器路径：D:/……/bin/gcc.exe【填写你自己的路径】</p>
</li>
<li>然后划到这一页最下面，找到###Sense模式，选则gcc-x64</li>
</ul>
<p>这时可以看到文件夹内生成了一个.vscode文件夹，里面有c_cpp_properties.json文件，打开之后会发现有自己的gcc.exe的目录，如果那个目录不是，需要人为改正</p>
<p>2.创建一个tasks.json文件来告诉VS Code如何构建（编译）程序。该任务将调用gcc编译器基于源代码创建可执行文件。 按快捷键Ctrl+Shift+P调出命令面板，输入tasks，选择“Tasks:Configure Default Build Task”：</p>
<p>再选“C/C++: g++.exe build active file”（可能前面的不一样，后面的几个英文对了就可以）</p>
<p>这时就会出现tasks.json文件，打开文件，看一下路径是否正确，不对就自己改改</p>
<p>3.配置调试文件GDB: 这里主要是为了在.vscode文件夹中产生一个launch.json文件，用来配置调试的相关信息。点击菜单栏的<em>Debug</em>—&gt;<em>Start Debugging</em>：</p>
<p>选择C++(GDB/LLDB)</p>
<p>这时可以看到生成了一个launch.json文件，这个文件就是关于调试用的</p>
<p>这里我采用了网上大神的代码，全部替换</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;g++.exe build active file&quot;</span>,<span class="comment">//调试前执行的任务，就是之前配置的tasks.json中的label字段</span></span><br><span class="line">            <span class="comment">//这里需要去查看一下，这个字段要统一，但是不一定是这一个</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,<span class="comment">//配置类型，只能为cppdbg</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,<span class="comment">//请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,<span class="comment">//调试程序的路径名称</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],<span class="comment">//调试传递参数</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>,<span class="comment">//true显示外置的控制台窗口，false显示内置终端</span></span><br><span class="line">            <span class="comment">//弹不弹出新的dos窗口，网上说弹出会被说是小白</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;D:\\mingw-w64\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="comment">//注意bin文件里面gdb的路径，写自己的</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在终端运行："><a href="#在终端运行：" class="headerlink" title="在终端运行："></a>在终端运行：</h2><p>这样是为了防止code run插件出现乱码</p>
<ul>
<li>选择 文件 -&gt; 首选项 -&gt; 设置，打开 VS Code 设置页面，</li>
<li>找到 Run Code configuration，勾上 Run In Terminal 选项。</li>
<li>设置之后，代码就会在 Terminal 中运行即可。</li>
</ul>
<p>这时该文件夹就已经写好了，现在任意位置创建一个C语言文件，看能不能像dev一样方便</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在桌面新建了一个C文件，这里直接用vscode打开，写好程序</p>
<p><strong>先保存，不然会出错</strong></p>
<p>写完之后“Ctrl+Alt+N”开始运行</p>
<p><strong>每一次debug完事都要保存</strong></p>
<p><img src="image-20210907151430340.png" alt="image-20210907151430340"></p>
<p>这是没问题的，现在来开始调试一下</p>
<p><strong>需要注意的是这里的路径和文件名不能又中文，否则会调试失败</strong></p>
<p>将.vscode文件和需要调试的文件放在同一个目录下，然后用vscode打开这个目录，就可以调试了</p>
<p><img src="image-20210907154001133.png" alt="image-20210907154001133"></p>
<p>这时就基本完成了</p>
]]></content>
      <categories>
        <category>悠哉日常</category>
      </categories>
      <tags>
        <tag>悠哉日常</tag>
      </tags>
  </entry>
  <entry>
    <title>daily</title>
    <url>/2021/09/12/daily/</url>
    <content><![CDATA[<p>​    人间最美好的，莫过于可以不受打扰，安心的干自己喜欢的事。</p>
]]></content>
      <categories>
        <category>悠哉日常</category>
      </categories>
      <tags>
        <tag>悠哉日常</tag>
      </tags>
  </entry>
  <entry>
    <title>flare-on2014复现记录</title>
    <url>/2021/11/14/flare-2014/</url>
    <content><![CDATA[<p> 复现了flare-on2014的部分题目，有的题目已经不具时效性，或者相关软件已经无法找到，便不再复现。</p>
<span id="more"></span>
<h2 id="Flare-on-1"><a href="#Flare-on-1" class="headerlink" title="Flare-on 1"></a>Flare-on 1</h2><p>签到题，给了一个安装程序（这个不是题目），安装之后得到一个NET文件，直接拖进dnspy</p>
<p>断在程序入口点</p>
<p><img src="image-20211123202529321.png" alt="image-20211123202529321"></p>
<p>跟进Form1()下好断点</p>
<p>然后在他下面的函数那里下好断电</p>
<p><img src="image-20211123202715849.png" alt="image-20211123202715849"></p>
<p>看到下面的几个for循环，这里直接下断点</p>
<p><img src="image-20211123202844320.png" alt="image-20211123202844320"></p>
<p>然后直接继续运行，这里观察下面的内存窗口，就可以看到flag</p>
<p><img src="image-20211123202936006.png" alt="image-20211123202936006"></p>
<p>这个题目一开始给一张图片，然后按下按钮上面的字会变成乱码，很容易猜到这是把flag给改变了</p>
<h2 id="Flare-on-2"><a href="#Flare-on-2" class="headerlink" title="Flare-on 2"></a>Flare-on 2</h2><p>题目给了一个图片，直接想到可能是图片隐写，winhex观察</p>
<p><img src="image-20211123203219289.png" alt="image-20211123203219289"></p>
<p>这里看反正是隐写了一种语言的代码，再下面还有一些代码</p>
<p><img src="image-20211123203331215.png" alt="image-20211123203331215"></p>
<p>将数据和代码提取出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">order = [</span><br><span class="line">	<span class="number">59</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">81</span>, <span class="number">76</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">11</span>, <span class="number">76</span>, <span class="number">68</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">20</span>, <span class="number">23</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">63</span>, <span class="number">58</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">11</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">50</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">49</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">58</span>, <span class="number">66</span>, <span class="number">3</span>, <span class="number">86</span>, <span class="number">27</span>, <span class="number">88</span>, <span class="number">77</span>, <span class="number">80</span>, <span class="number">38</span>, <span class="number">25</span>, <span class="number">40</span>, <span class="number">81</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">76</span>, <span class="number">81</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">24</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">28</span>, <span class="number">7</span>, <span class="number">88</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">7</span>, <span class="number">90</span>, <span class="number">52</span>, <span class="number">80</span>, <span class="number">58</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">50</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">72</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">91</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">72</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">75</span>, <span class="number">11</span>, <span class="number">79</span>, <span class="number">28</span>, <span class="number">27</span>, <span class="number">75</span>, <span class="number">3</span>, <span class="number">42</span>, <span class="number">23</span>, <span class="number">88</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">35</span>, <span class="number">68</span>, <span class="number">38</span>, <span class="number">63</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">38</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">81</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">24</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">1</span>, <span class="number">43</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">40</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">77</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">70</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">49</span>, <span class="number">51</span>, <span class="number">4</span>, <span class="number">51</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">70</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">70</span>, <span class="number">21</span>, <span class="number">47</span>, <span class="number">93</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">58</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">47</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">terms = [</span><br><span class="line">	<span class="string">&quot;M&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;]&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;\\&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;:&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;~&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;;&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;`&quot;</span>, <span class="string">&quot;%&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;|&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里就是用orde里的值来索引trems</p>
<p>用python来跑一下，得到一串base64密文，</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=<span class="string">&#x27;aWYoaXNzZXQoJF9QT1NUWyJcOTdcNDlcNDlcNjhceDRGXDg0XDExNlx4NjhcOTdceDc0XHg0NFx4NEZceDU0XHg2QVw5N1x4NzZceDYxXHgzNVx4NjNceDcyXDk3XHg3MFx4NDFcODRceDY2XHg2Q1w5N1x4NzJceDY1XHg0NFw2NVx4NTNcNzJcMTExXDExMFw2OFw3OVw4NFw5OVx4NkZceDZEIl0pKSB7IGV2YWwoYmFzZTY0X2RlY29kZSgkX1BPU1RbIlw5N1w0OVx4MzFcNjhceDRGXHg1NFwxMTZcMTA0XHg2MVwxMTZceDQ0XDc5XHg1NFwxMDZcOTdcMTE4XDk3XDUzXHg2M1wxMTRceDYxXHg3MFw2NVw4NFwxMDJceDZDXHg2MVwxMTRcMTAxXHg0NFw2NVx4NTNcNzJcMTExXHg2RVx4NDRceDRGXDg0XDk5XHg2Rlx4NkQiXSkpOyB9&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$___</span>=<span class="string">&quot;\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$___</span>(<span class="variable">$__</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解开密文，得到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&quot;\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D&quot;</span>])) </span><br><span class="line">&#123; <span class="keyword">eval</span>(base64_decode(<span class="variable">$_POST</span>[<span class="string">&quot;\97\49\x31\68\x4F\x54\116\104\x61\116\x44\79\x54\106\97\118\97\53\x63\114\x61\x70\65\84\102\x6C\x61\114\101\x44\65\x53\72\111\x6E\x44\x4F\84\99\x6F\x6D&quot;</span>])); </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$code</span>=base64_decode(<span class="variable">$_</span>);<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">下面那个没解出来</span><br></pre></td></tr></table></figure>
<p>直接把后面的内容再用base解开，就能得到flag</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">a11DOTthatDOTjava5crapATflareDASH<span class="keyword">on</span>DOTcom</span><br></pre></td></tr></table></figure>
<p>这里把里面的DOT换成点，AT换成@，DASH换成-</p>
<p>网页其实是迷惑人的，关键在图片隐写</p>
<h2 id="Flare-on-3"><a href="#Flare-on-3" class="headerlink" title="Flare-on 3"></a>Flare-on 3</h2><p>这个就纯动态调试了，没啥别的。不过出题人的本意应该是考察idc的使用</p>
<p>给了一个没有后缀的32位PE文件（winhex得出），然后加上后缀运行，直接弹错。不难看出，这里的报错是刻意为之的</p>
<p>进ida看一下</p>
<p><img src="image-20211123204253909.png" alt="image-20211123204253909"></p>
<p>函数不多，但是没有什么实际价值</p>
<p><img src="image-20211123204310491.png" alt="image-20211123204310491"></p>
<p>这里看起来需要动态调试，打开x32dbg，直接在0x401000处下断点，然后f9，来到最后的一个call这里</p>
<p><img src="image-20211103194501505.png" alt="image-20211103194501505"></p>
<p>f7跟进之后，f8往下走，发现这里一个和0x66的异或，看一下异或之后的数据</p>
<p>在循环的时候，看到下面的指令在不断变化，这里直接在内存窗口看一下</p>
<p>循环结束之后发下字符串</p>
<p> <code>so it beginshus</code>：这应该是开始的标志</p>
<p>在jmp之后又遇到一个循环，看到又在内存中生成了一串字符串</p>
<p><img src="image-20211103195406253.png" alt="image-20211103195406253"></p>
<p>这里还是不清楚他想表达什么，但是这些字符串没有出现在程序窗口中，应该是作者刻意为之，继续往下跑</p>
<p>时刻观察着内存窗口，然后一直往下跑，不一会就看到了flag</p>
<p><img src="image-20211103195648942.png" alt="image-20211103195648942"></p>
<h2 id="Flare-on-4"><a href="#Flare-on-4" class="headerlink" title="Flare-on 4"></a>Flare-on 4</h2><p>这个pdf有一个背景，就是mandiant公司在2014年揭露了一个中国的国营黑客组织</p>
<blockquote>
<p> “61398股”工作的性质被中国视为国家机密：然而，我们相信它从事有害的”计算机网络操作”。</p>
<p>61398号机组部分位于高桥镇大同路（路旁），位于上海浦东新区（区）。该大院的中心建筑是一个 130，663 平方英尺的设施，高 12 层，建于 2007 年初。</p>
<p>我们估计，61398股有成百上千的人员，根据61398股的有形基础设施的规模。</p>
<p>中国电信以国防的名义为该单位提供了特殊的光纤通信基础设施。</p>
<p>61398股要求其人员接受计算机安全和计算机网络操作培训，并要求其人员精通英语。</p>
</blockquote>
<p>给了一个PDF，看官方wp，在用老版本的pdf阅读器的时候，程序会执行一些代码，但是我没有找到这个阅读器，现在的阅读器过于先进和安全，所以就没有成功复现</p>
<h2 id="Flare-on-5"><a href="#Flare-on-5" class="headerlink" title="Flare-on 5"></a>Flare-on 5</h2><p>这是一个简单的dll逆向吧，开始想去直接动态调试，但是dll文件没有动起来，就只能静态看看了</p>
<p>ida进去找到dllmain函数</p>
<p><img src="image-20211107214222015.png" alt="image-20211107214222015"></p>
<p>分析了一堆没啥用的api函数，最后在下面找到了关键函数</p>
<p><img src="image-20211107214331089.png" alt="image-20211107214331089"></p>
<p>这里发现有俩函数，都跟进去看一下</p>
<p>第一个函数：</p>
<p><img src="image-20211107214452357.png" alt="image-20211107214452357"></p>
<p>这时要学会浏览函数列表，列表中总会有一些函数，有奇怪的作用（算是一个逆向的技巧吧）</p>
<p>然后找到了一个函数（从上往下第四位）</p>
<p><img src="image-20211107214757593.png" alt="image-20211107214757593"></p>
<p>函数很大，这里直接用c语言模拟一下</p>
<p><img src="image-20211107215840081.png" alt="image-20211107215840081"></p>
<p>得到这个，考虑到这是dll文件，所以这里考虑输出这个函数，他就运行成功了</p>
<p>然后跟进xref向回引用查找</p>
<p><img src="image-20211107220004372.png" alt="image-20211107220004372"></p>
<p>这里调用了成功函数，看到只有当这个数组&gt;0时，才可以，所以看一下他在哪里被赋值了</p>
<p><img src="image-20211107220110634.png" alt="image-20211107220110634"></p>
<p>这里跳转到下面那个，</p>
<p><img src="image-20211107220139870.png" alt="image-20211107220139870"></p>
<p>这里再看他赋值为1的条件，是上面那个大于0，以此类推，靠着这个数组的和0比较的大小，不停的向回跳转，然后每一个函数最后都有一个返回值</p>
<p><img src="image-20211107220319910.png" alt="image-20211107220319910"></p>
<p>根据xref的顺序记录一下返回值（这把一些英文单词换成符号）</p>
<p>得到：l0gging.ur.5tr0ke5atflare-on.com</p>
<h2 id="Flare-on-6"><a href="#Flare-on-6" class="headerlink" title="Flare-on 6"></a>Flare-on 6</h2><p>这个elf文件不会，看他们分析也分析不出来</p>
<h2 id="Flare-on-7"><a href="#Flare-on-7" class="headerlink" title="Flare-on 7"></a>Flare-on 7</h2><p>这个程序我不敢在本机跑，然后再win7虚拟机里跑也会出错，说他是个16位的程序，但是实际上是32位的，我不理解，这里记录一下题目中的涉及的反调试函数</p>
<p>IsDebuggerPresent() //调试时会返回1</p>
<p>IDT() //检查是否使用虚拟机</p>
<p><img src="image-20211123210400912.png" alt="image-20211123210400912"></p>
<p>通过使用特权指令判断是否使用虚拟机</p>
<p><img src="image-20211123210427090.png" alt="image-20211123210427090"></p>
<p>计算了1e1030到1e1780之间的0xCC数量，未调试时应为0x55</p>
<p><img src="image-20211123210524084.png" alt="image-20211123210524084"></p>
<p>peb中的BeingDebugged，当调试时这个值为1</p>
<p><img src="image-20211123210559391.png" alt="image-20211123210559391"></p>
<p>peb偏移0x68处为未公开的一处位置，调试时这个值为0x70</p>
<p><img src="image-20211123210629610.png" alt="image-20211123210629610"></p>
<p>以上参考harmonica11师傅的博客，我也没有找到这些函数</p>
]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>how2buildBlog</title>
    <url>/2021/08/27/how2buildBlog/</url>
    <content><![CDATA[<p> 搭建好博客，记录搭建过程：</p>
<h1 id="搭建博客："><a href="#搭建博客：" class="headerlink" title="搭建博客："></a>搭建博客：</h1><p>博客搭建基于【Github+hexo】模式；用的是hexo的next的模板。</p>
<h2 id="准备工具："><a href="#准备工具：" class="headerlink" title="准备工具："></a>准备工具：</h2><p>1.git</p>
<p>2.hexo</p>
<p>3.github</p>
<p>4.nodejs</p>
<h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>1.首先是在GitHub上创建一个仓库，仓库名称需为：名称.github.io</p>
<p>名称最好是和仓库名相同，这样方便索引：</p>
<span id="more"></span>
<p><img src="image-20210827182643655.png" alt="image-20210827182643655"></p>
<p>像这样即可</p>
<p>2.然后需要先安装git（熟悉Windows的可以直接用cmd）；然后下载nodejs，用<code>node -v</code>进行检查是否安装成功；然后安装<code>npm install hexo -g</code>用命令：<code>hexo -v</code>查看是否安装成功；之后需要安装hexo的一系列的以来文件<code>nmp install hexo-deployer-git --save</code>,这里需要注意的是—save的位置可以放到install那里，这个看个人情况。</p>
<p>3.这里最后需要配置SSH KEY，相当于一个身份验证：</p>
<p>通过git，输入命令：<code>cd ~/.ssh</code>进入ssh文件——-&gt;通过命令<code>cat id_rsa.pub</code>查看密钥，然后在github的设置里：</p>
<p><img src="image-20210827183729815.png" alt="image-20210827183729815"></p>
<p>将刚刚的一大串直接复制进去，这样就可以了</p>
<p>用<code>ssh -T git@github.com</code>检验是否成功</p>
<p>成功用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;liyunchen&quot; #你的github用户名</span><br><span class="line">$ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱</span><br></pre></td></tr></table></figure>
<p>命令来设置邮箱和用户名</p>
<h2 id="开始搭建："><a href="#开始搭建：" class="headerlink" title="开始搭建："></a>开始搭建：</h2><p>1.在一个较大的盘里新建文件夹，取一个洋文名字防止出灵异事件</p>
<p>2.git bash here，在该目录下打开git</p>
<p>3.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.hexo init</span><br><span class="line"><span class="comment">#初始化hexo，此时目录下多了一堆文件</span></span><br></pre></td></tr></table></figure>
<p>事先在<a href="https://hexo.io/themes/里下载好主题，将主题文件夹拖进【themes】文件夹然后回到主目录，用记事本打开主目录里的_config.yml文件，划到最后，找到themes：">https://hexo.io/themes/里下载好主题，将主题文件夹拖进【themes】文件夹然后回到主目录，用记事本打开主目录里的_config.yml文件，划到最后，找到themes：</a></p>
<p><img src="image-20210827184605759.png" alt="image-20210827184605759"></p>
<p>这里标黄的是要改成自己的仓库，下面的branch根据实际情况决定是main还是master。</p>
<p>themes后面跟的是主题的文件夹的名字，注意空格，<strong>千万不能少</strong></p>
<p>4.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.hexo s<span class="comment">#在本机生成一个预览可以看到效果</span></span><br><span class="line">2.hexo g<span class="comment">#生成html界面</span></span><br><span class="line">3.hexo d<span class="comment">#部署到github</span></span><br></pre></td></tr></table></figure>
<p>此时就可以看到自己的博客的初始状态，也就搭建基本完毕了</p>
<h1 id="完善博客："><a href="#完善博客：" class="headerlink" title="完善博客："></a>完善博客：</h1><p>搭建好之后需要完善成人类友好的界面（next为例子）</p>
<h2 id="1-首页风格："><a href="#1-首页风格：" class="headerlink" title="1.首页风格："></a>1.首页风格：</h2><p>找到你下载的主题里的_config.yml文件（没错，主题里面也有）</p>
<p>找到：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是四种风格，选一个喜欢的去掉前面的井号</span></span><br><span class="line"><span class="meta"># Schemes</span></span><br><span class="line"><span class="meta">#scheme: Muse</span></span><br><span class="line"><span class="meta">#scheme: Mist</span></span><br><span class="line"><span class="meta">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br><span class="line"><span class="comment">//这里是模式，亮还是暗</span></span><br><span class="line"><span class="meta"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是菜单设置，去掉喜欢的前面的#</span></span><br><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home                          <span class="comment">//首页</span></span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive          <span class="comment">//归档</span></span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || th           <span class="comment">//分类</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags                     <span class="comment">//标签</span></span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span> || user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//侧栏设置，看好适用风格</span></span><br><span class="line"><span class="meta"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"><span class="symbol">  position:</span> left        <span class="comment">//靠左放置</span></span><br><span class="line">  <span class="meta">#position: right      <span class="comment">//靠右放置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span></span><br><span class="line">  <span class="meta">#display: post        <span class="comment">//默认行为，在文章页面（拥有目录列表）时显示</span></span></span><br><span class="line"><span class="symbol">  display:</span> always       <span class="comment">//在所有页面中都显示</span></span><br><span class="line">  <span class="meta">#display: hide        <span class="comment">//在所有页面中都隐藏（可以手动展开）</span></span></span><br><span class="line">  <span class="meta">#display: remove      <span class="comment">//完全移除</span></span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">  offset:</span> <span class="number">12</span>            <span class="comment">//文章间距（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">  b2t:</span> false            <span class="comment">//返回顶部按钮（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">  scrollpercent:</span> true   <span class="comment">//返回顶部按钮的百分比</span></span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>头像设置，将头像设为header.jpg，然后拖到themes\hexo-theme-<span class="keyword">next</span>\source\images目录下</span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar: <span class="regexp">/images/</span>header.jpg</span><br></pre></td></tr></table></figure>
<h2 id="2-语言文字："><a href="#2-语言文字：" class="headerlink" title="2.语言文字："></a>2.语言文字：</h2><p>打开主目录的_config.yml文件，开头就是这几个，后面的内容自己写写，注意空格</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">R-o-o-t-k-i-t</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">自由，平等，公正，法制</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">rootkit，+-*/</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">rootkit/+-*</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span><span class="comment">#网站时区（Hexo 默认使用您电脑的时区，不用写）</span></span><br></pre></td></tr></table></figure>
<h1 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h1><p><img src="image-20210827190155039.png" alt="image-20210827190155039"></p>
<h1 id="上传日志："><a href="#上传日志：" class="headerlink" title="上传日志："></a>上传日志：</h1><p>在该文件夹里通过git或者cmd使用命令<code>hexo new &#39;#######&#39;</code>,就会在sources目录里生成一个#####.md文件，然后正常写点东西（在下面的正文部分，上面的灰色框是自带的）</p>
<p>写完之后通过命令<code>hexo g</code>和<code>hexo d</code>来上传</p>
<p>这样就完成了上面的效果。</p>
]]></content>
      <categories>
        <category>博客装修</category>
      </categories>
      <tags>
        <tag>关于博客</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA动态调试APK</title>
    <url>/2021/10/02/ida-remote-android/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>夜神模拟器使用于调试32位的apk程序，因为apk为了安全很少将关键数据放在java层，所以这里通过动态调试以达到对native层的逆向。</p>
<span id="more"></span>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>ida与模拟器通过adb指令进行连接</p>
<h2 id="安装adb"><a href="#安装adb" class="headerlink" title="安装adb"></a>安装adb</h2><p>从<a href="https://developer.android.com/studio/releases/platform-tools.html下载adb，安装">https://developer.android.com/studio/releases/platform-tools.html下载adb，安装</a></p>
<p>找到目录中的adb.exe文件的路径，添加到patch</p>
<p>cmd窗口输入adb -version查看是否成功，出现版本号和命令帮助则成功</p>
<h2 id="adb连接"><a href="#adb连接" class="headerlink" title="adb连接"></a>adb连接</h2><h3 id="配置模拟器"><a href="#配置模拟器" class="headerlink" title="配置模拟器"></a>配置模拟器</h3><p>以下为夜神模拟器思路：</p>
<p>进入夜神模拟器设置，“关于平板电脑选项”，连续点击5次 “版本号” ，进入开发者模式</p>
<p>打开开发者模式中调试选项中的 ”USB调试“</p>
<p>—-<strong>模拟器配置完成</strong>—</p>
<h3 id="连接主机"><a href="#连接主机" class="headerlink" title="连接主机"></a>连接主机</h3><p>1.连接：cmd命令【adb connect 127.0.0.1:62001】</p>
<p>62001: 夜神模拟器的默认端口号，因模拟器而异</p>
<p>2.查看：cmd命令 【adb devices】；成功会显示出当前的连接，失败则显示“device not found”.</p>
<p>3.与ida建立关系：cmd命令 【adb push 路径\android_server /data/local/tmp/】</p>
<p>将ida安装目录中远程调试目录下的android_server文件push向模拟器，后者为push进模拟器的路径</p>
<p>4.进入模拟器：cmd命令 【adb shell】, 乱码不要在意，继续cmd命令 【su】,进入管理员模式</p>
<p>5.执行server文件：cmd命令 【cd /data/local/tmp/】,【ls】查看文件是否存在</p>
<p>【chmod 777 android_server】赋予文件777权限，【./android_server】执行文件，建立ida联系</p>
<p>6.端口转发：另外打开cmd，cmd命令 【adb forward tcp:23946  tcp:23946】</p>
<p><strong><em>常见异常</em></strong>：</p>
<p>1.执行文件时显示文件已经执行：命令【ps | grep android_server】寻找进程【kill -s 9 ID】关闭进程，然后重新执行</p>
<p>2.端口转发异常：(1)device not found：结束server文件执行，重新启动模拟器。（2）端口被占用：主机查看后酌情选择</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>在模拟器中事先打开需要调试的文件</p>
<p>1.打开空白ida，或已经载入so文件的ida</p>
<p>2.空白ida：Debugger选项中的“attach”选项中的“Remote ARM……”选项</p>
<p>hostname选择填入“127.0.0.1”，端口默认，密码为空</p>
<p>2_1.已经载入so文件的ida：Debugger选项中的 “Select debugger” 选项中的“Remote ARM……”选项</p>
<p>然后 Debugger选项中 “process option” 选项，参数按需，hostname同上，端口，密码默认</p>
<p>3.选择进程：一般会在进程列表的底部找到目标程序的进程</p>
<p>连接完成，可以开始调试</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>ida动态调试APK的so文件</title>
    <url>/2022/04/12/ida%E8%B0%83so/</url>
    <content><![CDATA[<p> 一个apk分为两层，java层和so层，一般的重要的算法都会放在so层为了效率和安全，所以用一道简单的题目来学习ida对so文件的调试。</p>
<span id="more"></span>
<blockquote>
<p> 题目来源：攻防世界移动安全新手区：easyjni，算法简单，学习动调。</p>
</blockquote>
<p><strong><em>ps：不要用华为或者荣耀的全系列手机进行调试，即使你开了root权限</em></strong></p>
<h1 id="方法一、直接打开"><a href="#方法一、直接打开" class="headerlink" title="方法一、直接打开"></a>方法一、直接打开</h1><h2 id="建立通信"><a href="#建立通信" class="headerlink" title="建立通信"></a>建立通信</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;adb（android studio自&nbsp;带或者&emsp;独立安装），安卓（root）环境。</p>
<h3 id="文件导入"><a href="#文件导入" class="headerlink" title="文件导入"></a>文件导入</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1:62001   #真机调试没有这部，62001夜神的端口</span><br><span class="line">adb devices  #查看是否检测到安卓连接</span><br><span class="line">adb push F:\IDA\IDA_Pro_v7.5_Portable\dbgsrv\android_server /data/local/tmp</span><br><span class="line"><span class="meta">#</span><span class="bash">将ida的远程调试文件push进去，一般就这个目录，比较好记注意位数，不要搞错</span></span><br><span class="line">adb install F:\CTF题目\Android\easyjni\jni.apk  #把apk传进去</span><br><span class="line">adb shell    #进去shell界面</span><br></pre></td></tr></table></figure>
<p>进入安卓的shell之后，命令和ubuntu基本一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 /data/local/tmp/android_server</span><br><span class="line">su -c /data/local/tmp/android_server</span><br></pre></td></tr></table></figure>
<p>执行到这里，会发现：</p>
<p><img src="image-20220412135844452.png" alt="image-20220412135844452"></p>
<p>这时已经在android上成功开启了端口监听，但是还需要一个端口转发，把android的端口消息转发到本机上来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb forward tcp:23946 tcp:23946</span><br></pre></td></tr></table></figure>
<p>可以用ida去远程连接了。</p>
<h2 id="ida连接"><a href="#ida连接" class="headerlink" title="ida连接"></a>ida连接</h2><p>打开对应位数的新的ida</p>
<p><img src="image-20220412140440322.png" alt="image-20220412140440322"></p>
<p>找到对应的调试器。</p>
<p><img src="image-20220412140538684.png" alt="image-20220412140538684"></p>
<p>然后在弹出的进程框中搜得你要调试的apk的包名字，在jeb中获得或者在jadx中找到，比如：</p>
<p><img src="image-20220412140912677.png" alt="image-20220412140912677"></p>
<p>这就是包名，搜索jni即可。</p>
<p><img src="image-20220412140636458.png" alt="image-20220412140636458"></p>
<p>可能有许多，这里找到之后直接通过搜索来确定就行。</p>
<h2 id="动调"><a href="#动调" class="headerlink" title="动调"></a>动调</h2><p>找到进程之后，进入调试界面，ctrl+s，找到对应so文件，这里会有许多的so文件，还是要自己搜一下名字，然后附加上去。</p>
<p><img src="image-20220412141635356.png" alt="image-20220412141635356"></p>
<p>这里我的so文件<code>libnative.so</code>但是找到三个，都试一试，看一下特征。</p>
<p>找到正确的so文件后，另开一个ida，静态分析so，找到对应的函数的对应的地址的偏移，回到动调ida，直接G过去。</p>
<p><img src="image-20220412141823202.png" alt="image-20220412141823202"></p>
<p>可能没有识别成函数，直接p一下就好，就可以正常的F5了。</p>
<h2 id="可能的失败"><a href="#可能的失败" class="headerlink" title="可能的失败"></a>可能的失败</h2><p>1.如果报错，或者找不到进程，可能是没有开启全局调试指令（真机）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">magisk resetprop ro.debuggable 1  #设置debuggable</span><br><span class="line">stop;start;                       #一定要通过该方式重启，软重启</span><br></pre></td></tr></table></figure>
<p>2.前面都正常，但是最后无法调试原因：</p>
<ul>
<li><p>不要用华为或者荣耀系列的真机。</p>
</li>
<li><p>夜神模拟器是x86架构，如果调试arm的话夜神会强制转换架构出问题，用真机即可。</p>
</li>
</ul>
<h1 id="方法二、进程附加"><a href="#方法二、进程附加" class="headerlink" title="方法二、进程附加"></a>方法二、进程附加</h1><h2 id="建立通信-1"><a href="#建立通信-1" class="headerlink" title="建立通信"></a>建立通信</h2><p>步骤同上</p>
<h2 id="ida连接-1"><a href="#ida连接-1" class="headerlink" title="ida连接"></a>ida连接</h2><p>so文件直接拖进ida中打开静态分析</p>
<p><img src="image-20220412142210487.png" alt="image-20220412142210487"></p>
<p>修改一下debug选项，然后</p>
<p><img src="image-20220412142238040.png" alt="image-20220412142238040"></p>
<p>这里选择远程安卓arm调试，如上图。</p>
<p><img src="image-20220412142313591.png" alt="image-20220412142313591"></p>
<p>debug选择附加进程</p>
<p><img src="image-20220412142721554.png" alt="image-20220412142721554"></p>
<p>要是这里报错就随便写点参数，基本都是默认的</p>
<p>之后会有一个弹窗问你这俩文件一不一样，直接选same就行了。</p>
<h2 id="动调-1"><a href="#动调-1" class="headerlink" title="动调"></a>动调</h2><p>就和别的程序一样动调了，注意ARM架构的ip指针是PC指针。</p>
]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>fpbe(虎符2022-re1)</title>
    <url>/2022/03/28/fpbe/</url>
    <content><![CDATA[<p> 通过一道题目，学习ebpf相关的知识，并且了解Ghidra调试器的使用和ida的pip使用</p>
<span id="more"></span>
<h1 id="HCTF-fpbe"><a href="#HCTF-fpbe" class="headerlink" title="HCTF-fpbe"></a>HCTF-fpbe</h1><p>用户使用 BPF 虚拟机的指令集（也称 BPF 字节码）定义过滤器表达式，然后传递给内核，由解释器执行。类似于vm逆向的概念</p>
<h1 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h1><p>首先ida分析原来的文件：根据main函数，找到关键位置</p>
<p><img src="image-20220327141819319.png" alt="image-20220327141819319"></p>
<p>这里百度得到往内存中加载字节码的关键函数，跟进这个函数，找到字节码</p>
<p><img src="image-20220327142009846.png" alt="image-20220327142009846"></p>
<p>可以看到字节码的长度就是1648字节，提取出来的字节码dump进一个新的文件，这及时ebp文件了，下面开始分析文件。</p>
<h2 id="反汇编方法1"><a href="#反汇编方法1" class="headerlink" title="反汇编方法1"></a>反汇编方法1</h2><p>由dump出的字节码，然后通过<a href="hellorootkit.github.io/2022/03/28/Ghidra学习/">Ghidra</a>的ebpe插件（选用9.2版本的插件，然后不解压，直接修改里面的配置文件，将版本修改成对应Ghidra的版本），之后重新启动，进行反编译之后的伪代码。【这里不要使用360zip】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="function">undefined8 <span class="title">uprobe</span><span class="params">(longlong param_1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ulonglong uVar1;</span><br><span class="line">  ulonglong uVar2;</span><br><span class="line">  undefined8 uVar3;</span><br><span class="line">  undefined8 local_40;</span><br><span class="line">  undefined8 local_38;</span><br><span class="line">  undefined8 local_30;</span><br><span class="line">  undefined8 local_28;</span><br><span class="line">  undefined local_20;</span><br><span class="line">  ulonglong local_18;</span><br><span class="line">  ulonglong local_10;</span><br><span class="line">  undefined local_8;</span><br><span class="line">  </span><br><span class="line">  uVar2 = *(ulonglong *)(param_1 + <span class="number">0x68</span>) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">  local_18 = *(ulonglong *)(param_1 + <span class="number">0x70</span>) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">  local_10 = *(ulonglong *)(param_1 + <span class="number">0x60</span>) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">  local_8 = <span class="number">0</span>;</span><br><span class="line">  uVar1 = *(ulonglong *)(param_1 + <span class="number">0x58</span>) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">  uVar3 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((((uVar2 * <span class="number">0xfb88</span> + local_18 * <span class="number">0x6dc0</span> + local_10 * <span class="number">0x71fb</span> + uVar1 * <span class="number">0xcc8e</span> == <span class="number">-0x5e8ca66b</span>) &amp; &amp;</span><br><span class="line">       (uVar2 * <span class="number">0x6ae5</span> + local_18 * <span class="number">0xf1bf</span> + local_10 * <span class="number">0xadd3</span> + uVar1 * <span class="number">0x9284</span> == <span class="number">-0x1aabfcc0</span>)) &amp; &amp;</span><br><span class="line">      (uVar2 * <span class="number">0x8028</span> + local_18 * <span class="number">0xdd85</span> + local_10 * <span class="number">0x652d</span> + uVar1 * <span class="number">0xe712</span> == <span class="number">0xa6f374484da3</span>))</span><br><span class="line">     &amp;&amp; (uVar2 * <span class="number">0xca43</span> + local_18 * <span class="number">0x822c</span> + local_10 * <span class="number">0x7c8e</span> + uVar1 * <span class="number">0xf23a</span> == <span class="number">0xb99c485a7277</span> ))</span><br><span class="line">  &#123;</span><br><span class="line">    local_10 = local_10 | uVar1 &lt;&lt; <span class="number">0x20</span>;</span><br><span class="line">    local_18 = local_18 | uVar2 &lt;&lt; <span class="number">0x20</span>;</span><br><span class="line">    local_28 = <span class="number">0xa7d73257b465443</span>;</span><br><span class="line">    local_30 = <span class="number">0x4648203a47414c46</span>;</span><br><span class="line">    local_38 = <span class="number">0x2052554f59202145</span>;</span><br><span class="line">    local_40 = <span class="number">0x4e4f44204c4c4557</span>;</span><br><span class="line">    uVar3 = <span class="number">0</span>;</span><br><span class="line">    local_20 = <span class="number">0</span>;</span><br><span class="line">    bpf_trace_printk((<span class="keyword">char</span> *)&amp;local_40,<span class="number">0x21</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uVar3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反汇编方法2"><a href="#反汇编方法2" class="headerlink" title="反汇编方法2"></a>反汇编方法2</h2><p>通过ida的插件进行反汇编</p>
<h3 id="ida-pip"><a href="#ida-pip" class="headerlink" title="ida_pip"></a>ida_pip</h3><p>该插件来自 <a href="https://github.com/cylance/eBPF_processor">cylance/eBPF_processor: An IDA processor for eBPF bytecode (github.com)</a></p>
<ul>
<li>place <code>ebpf.py</code> in your <code>IDA_ROOT\procs</code> folder.</li>
</ul>
<p>然后找到ida——python的目录：<code>F:\IDA\IDA7.5\IDA_Pro_v7.5_Portable\python38\Scripts</code></p>
<p>然后在这里下载库<code>&gt;pip3.8 install pyelftools</code>，在外面下载的化，idapython是用不了的。</p>
<ul>
<li>最后一个脚本有一个bug，需要把<code>del(sym)</code>加一个缩进，到if判断里面才能执行。</li>
</ul>
<h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p><img src="image-20220327142423849.png" alt="image-20220327142423849"></p>
<p>这里选EBPF，就是刚那个插件，要不然打不开。</p>
<p>打开之后，看到流程图很清晰，然后就读汇编代码破解就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uprobe_func:0000000000000008 uprobe:</span><br><span class="line">uprobe_func:0000000000000008                 ldxdw          r2, [r1+0x68]</span><br><span class="line">uprobe_func:0000000000000010                 lsh            r2, 0x20</span><br><span class="line">uprobe_func:0000000000000018                 rsh            r2, 0x20</span><br><span class="line">uprobe_func:0000000000000020                 ldxdw          r3, [r1+0x70]</span><br><span class="line">uprobe_func:0000000000000028                 lsh            r3, 0x20</span><br><span class="line">uprobe_func:0000000000000030                 rsh            r3, 0x20</span><br><span class="line">uprobe_func:0000000000000038                 mov            r4, r3</span><br><span class="line">uprobe_func:0000000000000040                 mul            r4, 0x6DC0</span><br><span class="line">uprobe_func:0000000000000048                 mov            r5, r2</span><br><span class="line">uprobe_func:0000000000000050                 mul            r5, 0xFB88</span><br><span class="line">uprobe_func:0000000000000058                 add            r5, r4</span><br><span class="line">uprobe_func:0000000000000060                 ldxdw          r4, [r1+0x60]</span><br><span class="line">uprobe_func:0000000000000068                 lsh            r4, 0x20</span><br><span class="line">uprobe_func:0000000000000070                 rsh            r4, 0x20</span><br><span class="line">uprobe_func:0000000000000078                 mov            r0, r4</span><br><span class="line">uprobe_func:0000000000000080                 mul            r0, 0x71FB</span><br><span class="line">uprobe_func:0000000000000088                 add            r5, r0</span><br><span class="line">uprobe_func:0000000000000090                 ldxdw          r1, [r1+0x58]</span><br><span class="line">uprobe_func:0000000000000098                 mov            r0, 0</span><br><span class="line">uprobe_func:00000000000000A0                 stxb           [r10-8], r0</span><br><span class="line">uprobe_func:00000000000000A8                 stxdw          [r10-0x10], r0</span><br><span class="line">uprobe_func:00000000000000B0                 stxdw          [r10-0x18], r0</span><br><span class="line">uprobe_func:00000000000000B8                 lsh            r1, 0x20</span><br><span class="line">uprobe_func:00000000000000C0                 rsh            r1, 0x20</span><br><span class="line">uprobe_func:00000000000000C8                 mov            r0, r1</span><br><span class="line">uprobe_func:00000000000000D0                 mul            r0, 0xCC8E</span><br><span class="line">uprobe_func:00000000000000D8                 add            r5, r0</span><br><span class="line">uprobe_func:00000000000000E0                 mov            r6, 1</span><br><span class="line">uprobe_func:00000000000000E8                 lddw           r0, 0xBE18A1735995</span><br><span class="line">uprobe_func:00000000000000F8                 jne            r5, r0, LBB0_5</span><br><span class="line">uprobe_func:0000000000000100                 mov            r5, r3</span><br><span class="line">uprobe_func:0000000000000108                 mul            r5, 0xF1BF</span><br><span class="line">uprobe_func:0000000000000110                 mov            r0, r2</span><br><span class="line">uprobe_func:0000000000000118                 mul            r0, 0x6AE5</span><br><span class="line">uprobe_func:0000000000000120                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000128                 mov            r5, r4</span><br><span class="line">uprobe_func:0000000000000130                 mul            r5, 0xADD3</span><br><span class="line">uprobe_func:0000000000000138                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000140                 mov            r5, r1</span><br><span class="line">uprobe_func:0000000000000148                 mul            r5, 0x9284</span><br><span class="line">uprobe_func:0000000000000150                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000158                 lddw           r5, 0xA556E5540340</span><br><span class="line">uprobe_func:0000000000000168                 jne            r0, r5, LBB0_5</span><br><span class="line">uprobe_func:0000000000000170                 mov            r5, r3</span><br><span class="line">uprobe_func:0000000000000178                 mul            r5, 0xDD85</span><br><span class="line">uprobe_func:0000000000000180                 mov            r0, r2</span><br><span class="line">uprobe_func:0000000000000188                 mul            r0, 0x8028</span><br><span class="line">uprobe_func:0000000000000190                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000198                 mov            r5, r4</span><br><span class="line">uprobe_func:00000000000001A0                 mul            r5, 0x652D</span><br><span class="line">uprobe_func:00000000000001A8                 add            r0, r5</span><br><span class="line">uprobe_func:00000000000001B0                 mov            r5, r1</span><br><span class="line">uprobe_func:00000000000001B8                 mul            r5, 0xE712</span><br><span class="line">uprobe_func:00000000000001C0                 add            r0, r5</span><br><span class="line">uprobe_func:00000000000001C8                 lddw           r5, 0xA6F374484DA3</span><br><span class="line">uprobe_func:00000000000001D8                 jne            r0, r5, LBB0_5</span><br><span class="line">uprobe_func:00000000000001E0                 mov            r5, r3</span><br><span class="line">uprobe_func:00000000000001E8                 mul            r5, 0x822C</span><br><span class="line">uprobe_func:00000000000001F0                 mov            r0, r2</span><br><span class="line">uprobe_func:00000000000001F8                 mul            r0, 0xCA43</span><br><span class="line">uprobe_func:0000000000000200                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000208                 mov            r5, r4</span><br><span class="line">uprobe_func:0000000000000210                 mul            r5, 0x7C8E</span><br><span class="line">uprobe_func:0000000000000218                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000220                 mov            r5, r1</span><br><span class="line">uprobe_func:0000000000000228                 mul            r5, 0xF23A</span><br><span class="line">uprobe_func:0000000000000230                 add            r0, r5</span><br><span class="line">uprobe_func:0000000000000238                 lddw           r5, 0xB99C485A7277</span><br><span class="line">uprobe_func:0000000000000248                 jne            r0, r5, LBB0_5</span><br><span class="line">uprobe_func:0000000000000250                 stxw           [r10-0xC], r1</span><br><span class="line">uprobe_func:0000000000000258                 stxw           [r10-0x10], r4</span><br><span class="line">uprobe_func:0000000000000260                 stxw           [r10-0x14], r2</span><br><span class="line">uprobe_func:0000000000000268                 stxw           [r10-0x18], r3</span><br><span class="line">uprobe_func:0000000000000270                 lddw           r1, 0xA7D73257B465443</span><br><span class="line">uprobe_func:0000000000000280                 stxdw          [r10-0x28], r1</span><br><span class="line">uprobe_func:0000000000000288                 lddw           r1, 0x4648203A47414C46</span><br><span class="line">uprobe_func:0000000000000298                 stxdw          [r10-0x30], r1</span><br><span class="line">uprobe_func:00000000000002A0                 lddw           r1, 0x2052554F59202145</span><br><span class="line">uprobe_func:00000000000002B0                 stxdw          [r10-0x38], r1</span><br><span class="line">uprobe_func:00000000000002B8                 lddw           r1, 0x4E4F44204C4C4557</span><br><span class="line">uprobe_func:00000000000002C8                 stxdw          [r10-0x40], r1</span><br><span class="line">uprobe_func:00000000000002D0                 mov            r6, 0</span><br><span class="line">uprobe_func:00000000000002D8                 stxb           [r10-0x20], r6</span><br><span class="line">uprobe_func:00000000000002E0                 mov            r1, r10</span><br><span class="line">uprobe_func:00000000000002E8                 add            r1, -0x40</span><br><span class="line">uprobe_func:00000000000002F0                 mov            r3, r10</span><br><span class="line">uprobe_func:00000000000002F8                 add            r3, -0x18</span><br><span class="line">uprobe_func:0000000000000300                 mov            r2, 0x21</span><br><span class="line">uprobe_func:0000000000000308                 call           6        ; long bpf_trace_printk(const char *fmt, __u32 fmt_size, ...)</span><br><span class="line">uprobe_func:0000000000000310</span><br><span class="line">uprobe_func:0000000000000310 LBB0_5:                                 ; CODE XREF: uprobe+F0↑j</span><br><span class="line">uprobe_func:0000000000000310                                         ; uprobe+160↑j ...</span><br><span class="line">uprobe_func:0000000000000310                 mov            r0, r6</span><br><span class="line">uprobe_func:0000000000000318                 ret</span><br><span class="line">uprobe_func:0000000000000318 ; End of function uprobe</span><br><span class="line">uprobe_func:0000000000000318</span><br><span class="line">uprobe_func:0000000000000318 ; end of &#x27;uprobe_func&#x27;</span><br><span class="line">uprobe_func:0000000000000318</span><br><span class="line">license:0000000000000320 ; ===========================================================================</span><br><span class="line">license:0000000000000320</span><br><span class="line">license:0000000000000320 ; Segment type: Pure data</span><br><span class="line">license:0000000000000320 LICENSE:        db &quot;Dual BSD/GPL&quot;,0</span><br><span class="line">license:0000000000000320 ; end of &#x27;license&#x27;</span><br><span class="line">license:0000000000000320</span><br><span class="line">.rodata.str1.1:000000000000032D ; ===========================================================================</span><br><span class="line">.rodata.str1.1:000000000000032D</span><br><span class="line">.rodata.str1.1:000000000000032D ; Segment type: Pure data</span><br><span class="line">.rodata.str1.1:000000000000032D aWellDoneYourFl:db &quot;WELL DONE! YOUR FLAG: HFCTF&#123;%s&#125;&quot;,0xA,0</span><br><span class="line">.rodata.str1.1:000000000000032D ; end of &#x27;.rodata.str1.1&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>根据Ghidra的方式，可以看到有一个if判断，这里直接用Z3进行约束求解，然后转字符串，最后连接就行（注意 大小端序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r1 = Int(<span class="string">&#x27;r1&#x27;</span>)</span><br><span class="line">r2 = Int(<span class="string">&#x27;r2&#x27;</span>)</span><br><span class="line">r3 = Int(<span class="string">&#x27;r3&#x27;</span>)</span><br><span class="line">r4 = Int(<span class="string">&#x27;r4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add(<span class="number">28096</span>*r1+<span class="number">64392</span>*r2+<span class="number">29179</span>*r3+<span class="number">52366</span>*r4 == <span class="number">209012997183893</span>)</span><br><span class="line">s.add(<span class="number">61887</span>*r1+<span class="number">27365</span>*r2+<span class="number">44499</span>*r3+<span class="number">37508</span>*r4 == <span class="number">181792633258816</span>)</span><br><span class="line">s.add(<span class="number">56709</span>*r1+<span class="number">32808</span>*r2+<span class="number">25901</span>*r3+<span class="number">59154</span>*r4 == <span class="number">183564558159267</span>)</span><br><span class="line">s.add(<span class="number">33324</span>*r1+<span class="number">51779</span>*r2+<span class="number">31886</span>*r3+<span class="number">62010</span>*r4 == <span class="number">204080879923831</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">        flag = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        m = s.model()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [r1,r2,r3,r4]:</span><br><span class="line">            flag += long_to_bytes(m[i].as_long())[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="comment">#0vR3sAlbs8pD2h53</span></span><br></pre></td></tr></table></figure>
<h1 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h1><p>看到main函数里的：</p>
<p><img src="image-20220327143733361.png" alt="image-20220327143733361"></p>
<p>明显是在内核中调用了一个普通的sha-256加密，来判断输入的flag，而且分析这个算法，给出了密文，而且知道flag的长度，直接爆破也是可以的，但是时间比较长</p>
]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>java配置</title>
    <url>/2021/12/13/java%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>​       </p>
<h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1>  <span id="more"></span>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在：<a href="https://www.oracle.com/java/technologies/downloads/#java8">Java Downloads | Oracle</a></p>
<p>可以下载到java8或者是11的JDK，下载的时候看好发行的版本（linux，macos，Windows）</p>
<p>下载好之后开始安装</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>按照提示安装就好，注意尽量不要放在C盘，我安装在了D盘。</p>
<p>在安装的时候可能会有报错</p>
<p><strong>报错1</strong>：“以下应用程序正在使用需要由此安装程序更新的文件”</p>
<p>这个错误会同时给出一个占用的进程的PID，在Windows下用管理员命令，打开命令提示符界面，</p>
<p>输入<code>netstat -ano</code>命令，该命令用来查看进程的id，上面给出了就不必要了。命令<code>taskkill /f /pid xxxxx</code>这个命令用来kill特定的进程，kill之后点击安装程序的”重试“就可以了。</p>
<p><strong>报错2：</strong>”以下应用程序正在使用需要由此安装程序更新的文件“</p>
<p>这个报错一般会跟在报错1的后面，同时也给出一个进程号，用上面的命令给他kill了之后点击安装程序的”重试“就可以了。</p>
<p>看好安装路径，然后就安装完成了。</p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>这里需要配置的是 系统变量  </strong></p>
<p><img src="image-20211213214053090.png" alt="image-20211213214053090"></p>
<p>下面这里的变量，不牵扯到上面的 <strong>用户变量</strong></p>
<h2 id="配置变量"><a href="#配置变量" class="headerlink" title="配置变量"></a>配置变量</h2><ul>
<li>新建系统变量<code>CLASSPATH</code> ，值为：</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">.;<span class="meta">%</span>JAVA_HOME<span class="meta">%</span>\lib<span class="meta">%</span>JAVA_HOME<span class="meta">%</span>\lib\tools.jar    <span class="comment">//注意前面小数点和分号。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>新建系统变量<code>JAVA_HOME</code> ，值为：你安装的那个<strong>jdk</strong>的路径</li>
<li>找到系统变量里的 Path ，新增（一行的话中间用分号分隔）</li>
</ul>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"><span class="variable">%JAVA_HOME%</span><span class="symbol">\b</span>in</span><br><span class="line"><span class="variable">%JAVA_HOME%</span><span class="symbol">\j</span>re<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>cmd窗口输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>如果都有回显的话说明配置成功</p>
<p><strong><em>例外：</em></strong>有时候javac可能会出错，这里把前面的%路径全都改成绝对路径解决</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title>insert_photo</title>
    <url>/2021/08/27/insert-photo/</url>
    <content><![CDATA[<p>​    Do you konw how to insert photo?</p>
<p><img src="image-20210827212032824.png" alt="image-20210827212032824"></p>
]]></content>
  </entry>
  <entry>
    <title>注册谷歌</title>
    <url>/2021/09/04/signgoogle/</url>
    <content><![CDATA[<p>主要为了解决在注册时手机号无法使用的问题</p>
<p>This phone number cannot be used for verification.</p>
<span id="more"></span>
<h1 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h1><p>1.这里以采用香港节点为例</p>
<p>2.将注册界面的语言设置为繁体字</p>
<h1 id="开始注册："><a href="#开始注册：" class="headerlink" title="开始注册："></a>开始注册：</h1><p>按照步骤来就可以了，电话就可以用你的了，注意国旗还是要大陆的</p>
<p><strong><em>Ps:</em></strong></p>
<ul>
<li><p>这里注意的是要将浏览器界面的语言设置成符合自己所用节点的语言，可能会更顺利一些</p>
</li>
<li><p>一次不行，不要频繁尝试，等一会再试，否则容易误判</p>
</li>
<li><strong>科学上网，请遵守法律法规</strong></li>
</ul>
]]></content>
      <categories>
        <category>悠哉日常</category>
      </categories>
      <tags>
        <tag>你好，世界</tag>
      </tags>
  </entry>
  <entry>
    <title>winrar去广告</title>
    <url>/2022/02/28/winrar%E5%8E%BB%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<p> winRAR好用，但是开屏广告烦死人，这里通过x64dbg去除广告</p>
<span id="more"></span>
<h1 id="找经验"><a href="#找经验" class="headerlink" title="找经验"></a>找经验</h1><p>网上有教程，先去看一下可行性如何，都是低版本的教程，偏移和结构已经发生变化，但是<code>bp CreateWindowExW</code>指令在弹出窗口的api函数下断点还是有效的。网上的教程过于麻烦，可能是改的更多</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>直接打开然后：<code>bp CreateWindowExW</code>，开始f9运行。因为调用函数的话，栈中必然会有参数，所以这里就时刻观察着栈上的数据，大概在f9了30次左右，在栈中观察到了网址：</p>
<p><img src="IMG_1603.JPG" alt="IMG_1603"></p>
<p>这里看开头的ad就知道，是广告的缩写，这时候直接回到用户代码领空，在栈这里回车，跳转回代码领空，然后找到一个call CreateWindows函数，直接把这个指令nop完事，patch之后，运行发现没有广告了</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>东北大学招新_re</title>
    <url>/2021/08/29/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A6%E6%8B%9B%E6%96%B0-re/</url>
    <content><![CDATA[<p> elf文件，ida64打开，看到程序很简单的加密，但是涉及到<strong>数据类型之间的转化和经典的逆向过程</strong></p>
<span id="more"></span>
<p><img src="image-20210829132912959.png" alt="image-20210829132912959"></p>
<p>确定了输入的flag是22位，然后经过三轮运算，将得到的和给出的数组进行比较，逻辑简单，开始逆向！</p>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#首先将三轮运算逆向回去</span></span><br><span class="line">targ=[  <span class="number">0x03</span>, <span class="number">0x1D</span>, <span class="number">0x24</span>, <span class="number">0x1C</span>, <span class="number">0x06</span>, <span class="number">0x1A</span>, <span class="number">0x3C</span>, <span class="number">0x3F</span>, <span class="number">0x04</span>, <span class="number">0x32</span>,</span><br><span class="line">  		<span class="number">0x3E</span>, <span class="number">0x11</span>, <span class="number">0x1C</span>, <span class="number">0x0B</span>, <span class="number">0x0D</span>, <span class="number">0x1F</span>, <span class="number">0xFD</span>, <span class="number">0x09</span>, <span class="number">0xF3</span>, <span class="number">0xFB</span>,</span><br><span class="line">      	<span class="number">0x98</span>, <span class="number">0x92</span>, <span class="number">0x00</span>]</span><br><span class="line"><span class="comment">#每一位和后一位异或，所以最后一位是不会变的，这就是突破口</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    targ[<span class="number">21</span>-i]=targ[<span class="number">21</span>-i]^targ[<span class="number">22</span>-i]</span><br><span class="line"><span class="built_in">print</span>(targ)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    targ[<span class="number">21</span>-i]=targ[<span class="number">21</span>-i]-targ[<span class="number">22</span>-i]</span><br><span class="line"><span class="built_in">print</span>(targ)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    targ[i]-=i</span><br><span class="line"><span class="built_in">print</span>(targ)</span><br></pre></td></tr></table></figure>
<p>这时得到的数组是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">targ=[-<span class="number">154</span>, <span class="number">365</span>, -<span class="number">157</span>, <span class="number">362</span>, -<span class="number">129</span>, <span class="number">374</span>, -<span class="number">131</span>, <span class="number">364</span>, -<span class="number">151</span>, <span class="number">385</span>,</span><br><span class="line">      -<span class="number">147</span>, <span class="number">367</span>, -<span class="number">141</span>, <span class="number">384</span>, -<span class="number">145</span>, <span class="number">373</span>, -<span class="number">140</span>, <span class="number">386</span>, -<span class="number">375</span>, <span class="number">377</span>, </span><br><span class="line">      -<span class="number">136</span>, <span class="number">146</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这里很明显看到因为python的数据类型基本没有限制，所以会出现 很多大数和负数</p>
<p>在C语言里面，一个byte的无符号整数是0-255，这里看到程序里面都是单字节，所以会出现循环现象，这里将他门进行复原</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">22</span>):</span><br><span class="line">    <span class="keyword">if</span> targ[i]&gt;<span class="number">255</span>:</span><br><span class="line">        targ[i]%=<span class="number">256</span></span><br><span class="line"><span class="comment">#因为这里超过256会循环，所以要%256</span></span><br><span class="line">    <span class="keyword">if</span> targ[i]&lt;<span class="number">0</span>:</span><br><span class="line">        targ[i]&amp;=<span class="number">0xffffffff</span></span><br><span class="line"><span class="comment">#考虑到负数的缘故，要先将负数转化成正数（有符号数转化无符号数）</span></span><br><span class="line"><span class="built_in">print</span>(targ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后统一规矩一下数据，然后字符输出就可以了</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">    <span class="keyword">if</span> targ[i]&gt;<span class="number">255</span>:</span><br><span class="line">        targ[i]%=<span class="number">256</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(targ[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(targ)</span><br></pre></td></tr></table></figure>
<p>最后得到flag：</p>
<p><strong>flag{qweaxcdgsafdqwfd}</strong></p>
]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓逆向学习路径</title>
    <url>/2021/11/24/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p> 在52破解上看到的一篇安卓逆向的学习路线，这里记录一下，以便后续使用</p>
<span id="more"></span>
<h2 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h2><ul>
<li>熟练使用AndroidKiller、Jeb等工具 </li>
<li>了解smali语言，能够将简单的sali语句翻译成java </li>
<li>能够使用AndroidStudio进行java层面的动态调试 </li>
<li>了解arm汇编语言 </li>
<li>从0到一编写一个so文件 </li>
<li>能够配合ida对so成进行动态调试 </li>
<li>配合so层的编写经验实现自己的反调试代码，并一一动手调试过掉这些反调试</li>
<li>总结：java和smail语言基础；arm架构汇编；熟练使用相关工具；自己实现so</li>
</ul>
<p>基础学习：<a href="https://www.52pojie.cn/thread-742703-1-1.html">《教我兄弟学Android逆向系列课程+附件导航帖》 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>
<h2 id="进阶技能"><a href="#进阶技能" class="headerlink" title="进阶技能"></a>进阶技能</h2><ul>
<li>了解安卓apk包的架构，能解析apk的各种文件，例如dex、xml文件 </li>
<li>了解动态加载的技术 </li>
<li>学习安卓第一代壳(落地加载壳)的加固方案然后自己动手实现 </li>
<li>学习frida，会使用frida编写简单的脱壳机  </li>
<li>学习安卓第二代壳(不落地加载壳)的加固方案有条件就自己实现一下 </li>
<li>针对第一代壳和第二代壳的加载点无论是使用动态调试还是hook的方法脱壳修复 </li>
<li>了解第三代壳(函数抽取式壳)和第四代壳(vmp)的原理 </li>
<li>学会使用或者自己编写针对第三代壳的脱壳机，例如:fart、frida-unpack等等 </li>
<li>能自己解析so文件<strong>，</strong>也就是elf文件，这是后面so层加密加固的前提 </li>
<li>有时间可以学习一下unicorn框架，github上已经有基于unicorn的so调用器，名字叫啥忘了 </li>
<li>学习so层的一些加密加固方案</li>
<li>然后还要ollvm框架，ollvm用来对抗ida的分析那滋味是真的酸爽（52破解无名侠师傅）</li>
</ul>
<p>书籍推荐：姜维大佬的小黄书和非虫大佬的安卓逆向</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>博客改良(持续记录)</title>
    <url>/2021/08/28/%E5%8D%9A%E5%AE%A2%E6%94%B9%E8%89%AF/</url>
    <content><![CDATA[<h2 id="1-删除强力驱动："><a href="#1-删除强力驱动：" class="headerlink" title="1.删除强力驱动："></a>1.删除强力驱动：</h2><p>1.在【themes/layout/_partial/footer】文件中的最后，删除如下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme<span class="selector-class">.footer</span><span class="selector-class">.powered</span> %&#125;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org<span class="string">&#x27; if theme.scheme === &#x27;</span>Gemini<span class="string">&#x27; else &#x27;</span>https://theme-next.js.org/<span class="string">&#x27; + theme.scheme | lower + &#x27;</span>/<span class="string">&#x27; %&#125;</span></span><br><span class="line"><span class="string">    &#123;&#123;- __(&#x27;</span>footer.powered<span class="string">&#x27;, next_url(&#x27;</span>https://hexo.io<span class="string">&#x27;, &#x27;</span>Hexo<span class="string">&#x27;) + &#x27;</span> &amp; <span class="string">&#x27; + next_url(next_site, &#x27;</span>NexT.<span class="string">&#x27; + theme.scheme)) &#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#123;%- endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>2.同样，如果想在该位置添加一些别的文字，直接在这个文件里面加就行</p>
<span id="more"></span>
<h2 id="2-更改字体颜色："><a href="#2-更改字体颜色：" class="headerlink" title="2.更改字体颜色："></a>2.更改字体颜色：</h2><p>在_data文件里面添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span> #色号</span><br></pre></td></tr></table></figure>
<p><img src="image-20210828115628268.png" alt="image-20210828115628268"></p>
<p><img src="image-20210828115713939.png" alt="image-20210828115713939"></p>
<p><img src="image-20210828115742828.png" alt="image-20210828115742828"></p>
<h2 id="3-利用不通的分类："><a href="#3-利用不通的分类：" class="headerlink" title="3.利用不通的分类："></a>3.利用不通的分类：</h2><p>这里用“categories”为例</p>
<p>找到在categories目录下的哪个index.md文件，在开头的地方加上一行</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">type: <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="image-20210828122741712.png" alt="image-20210828122741712"></p>
<p>这样就可以在那个界面里面看到不通的分类了</p>
<h2 id="4-在文中添加超链接"><a href="#4-在文中添加超链接" class="headerlink" title="4.在文中添加超链接"></a>4.在文中添加超链接</h2><p>利用markdown特性，将链接放在&lt;&gt;中间</p>
<p>例如<a href="https://hellorootkit.github.io">https://hellorootkit.github.io</a></p>
<h2 id="5-修改字体颜色"><a href="#5-修改字体颜色" class="headerlink" title="5.修改字体颜色"></a>5.修改字体颜色</h2><h3 id="1-修改博文标题："><a href="#1-修改博文标题：" class="headerlink" title="1.修改博文标题："></a>1.修改博文标题：</h3><p>找到目录\hexo-theme-next\source\css_common\components\post下的post-header文件</p>
<p>然后找到.post-title-link</p>
<p>修改颜色即可生效</p>
<h3 id="2-修改博文颜色："><a href="#2-修改博文颜色：" class="headerlink" title="2.修改博文颜色："></a>2.修改博文颜色：</h3><p>同2</p>
<h3 id="3-日志分类标签统计："><a href="#3-日志分类标签统计：" class="headerlink" title="3.日志分类标签统计："></a>3.日志分类标签统计：</h3><p>目录\hexo-theme-next\source\css_common\outline\sidebar\site-state.styl</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-state-item-name</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#40E0D0</span>;//$site-state-item-name-<span class="attribute">color</span>;//日志，分类，标签的颜色</span><br><span class="line">  <span class="attribute">font-size</span>: $site-state-item-name-font-size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-头像下面和描述："><a href="#4-头像下面和描述：" class="headerlink" title="4.头像下面和描述："></a>4.头像下面和描述：</h3><p>目录\hexo-theme-next\source\css_common\outline\sidebar\author.styl</p>
<h3 id="5-站点描述："><a href="#5-站点描述：" class="headerlink" title="5.站点描述："></a>5.站点描述：</h3><p>themes\hexo-theme-next\source\css_schemes\Pisces_sidebar.styl</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.sidebar-inner &#123;//站点概况</span><br><span class="line">  <span class="built_in">background</span>: rgba(<span class="number">128</span>,<span class="number">138</span>,<span class="number">135</span>,<span class="number">0.1</span>)//<span class="built_in">var</span>(--<span class="built_in">content</span>-bg-<span class="built_in">color</span>);</span><br><span class="line">  <span class="built_in">border</span>-<span class="built_in">radius</span>: $<span class="built_in">border</span>-<span class="built_in">radius</span>;</span><br><span class="line">  <span class="built_in">box</span>-shadow: $<span class="built_in">box</span>-shadow;</span><br><span class="line">  <span class="built_in">box</span>-sizing: <span class="built_in">border</span>-<span class="built_in">box</span>;</span><br><span class="line">  <span class="built_in">color</span>: <span class="built_in">var</span>(--text-<span class="built_in">color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客装修</category>
      </categories>
  </entry>
  <entry>
    <title>转转大师v6.0.0.6破解</title>
    <url>/2022/02/27/zhuanzhuan-Winrar/</url>
    <content><![CDATA[<p> 在写简历时，需要一遍遍的完善，转pdf看看效果，但是百度文库转的格式不行，下载了转转大师，但是非会员有次数限制，寻思能不能绕过，再写博客的时候，复现一下，一不小心就直接解锁了，现在所有的功能登录即可使用；</p>
<span id="more"></span>
<h1 id="zhuanzhuan"><a href="#zhuanzhuan" class="headerlink" title="zhuanzhuan"></a>zhuanzhuan</h1><p>1.先查壳，无壳；妙哉。</p>
<p>2.问题：直接开始调试会先走许多库函数进行程序加载，比较慢</p>
<p>解决：直接将软件运行起来，用x64dbg附加上去。注意管理员打开</p>
<p>3.开始调试：</p>
<p>首先打开软件，找到需要的模块，找到<code>zhuanzhuan</code>进程附加，附加上去之后等一会，看到栈窗口稳定了，这时候看到代码段还不在用户领空，这时候找到符号，选中用户模块，就来到了用户模块</p>
<p><img src="image-20220228111329652.png" alt="image-20220228111329652"></p>
<p>看到开头有三个call函数，这里都下断，看一下能断在那里</p>
<p><img src="image-20220228111551074.png" alt="image-20220228111551074"></p>
<p>这时候发现程序断不下来，麻了；猜测原因，这时候去附加的话，程序已经完成了会员登录与否的判断，基本的程序也加载了，所以这次直接程序开始运行就附加上去</p>
<p>保持上述断点，在call的函数里面下断点，因为不知道有没有别的调用。</p>
<p><img src="image-20220228112630557.png" alt="image-20220228112630557"></p>
<p>在这里就开始附加，点击文件转pdf，程序直接断在了刚刚的第二个call的断点上</p>
<p>F9两次，程序正常开始</p>
<p><img src="image-20220228112759054.png" alt="image-20220228112759054"></p>
<p>添加文件，程序又回到刚刚的断点，F8单步配合F9，成功选中文件，程序断在了</p>
<p><img src="image-20220228113025517.png" alt="image-20220228113025517"></p>
<p>f9，观察程序窗口，正常之后点击开始转换，程序又断在第一次断的地方，思路断了</p>
<p>看下当前模块的字符串</p>
<p>发现：</p>
<p><img src="image-20220228114637749.png" alt="image-20220228114637749"></p>
<p>一堆开通VIP，这里猜测应该是对应了不同的模块，挨个进去看看上下文注释，有的有，有的没有，直接全下断点。断在一个地方</p>
<p><img src="image-20220228114852317.png" alt="image-20220228114852317"></p>
<p>这里就是对应着我的word2pdf，看一下上下文</p>
<p>下文：</p>
<p><img src="image-20220228115035420.png" alt="image-20220228115035420"></p>
<p>这里的call出现弹窗，可选的，下面的cmp引人注目，选择只转五页的选项，jnz跳转到一处地址，下断。jnz跳转的地方就可以正常的执行转换，虽然只有五页。这里迷惑的是如何判断的会员身份，没有找到判断逻辑。</p>
<p>再看到上下文，寻找大跳转，看看能不能跳过弹窗。找到一处JE</p>
<p><img src="image-20220228120737885.png" alt="image-20220228120737885"></p>
<p>直接跳过了弹窗生成，</p>
<p><img src="image-20220228121053479.png" alt="image-20220228121053479"></p>
<p>这一块代码通过判断eax，然后对bl赋值，最后检测bl，非零跳转到刚刚进入转换程序的那里</p>
<p>看到eax的值通过函数</p>
<p><img src="image-20220228121205670.png" alt="image-20220228121205670"></p>
<p>得到。</p>
<p>思路：将setge改为setle指令（不行），分析eax的函数，一个对eax的修改，看看能不能改后面的</p>
<p><img src="image-20220228121539870.png" alt="image-20220228121539870"></p>
<p>下面有一个对bl的判断，进行修改：</p>
<p>将原来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test bl , bl</span><br><span class="line">jne 开始转换</span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">cmp bl, bl</span><br><span class="line">je $$$</span><br></pre></td></tr></table></figure>
<p>改完之后patch文件，运行，发现在开始转换的时候，她不会弹窗，但是再转换结束之后，还是会进行弹窗，继续看一下程序（减号可以回到上一步的显示）</p>
<p>思路n：通过修改eax来绕过，还是算啦吧</p>
<p>把所有的vip提示都下断点，然后运行，转化之后断在了这里</p>
<p><img src="image-20220228135246731.png" alt="image-20220228135246731"></p>
<p>上下文分析，跳转比较多，这里发现不论选什么，都会跳出付款界面，于是找到函数头，断下来，把前面的断点去一下，然后重新调试，</p>
<p>发现不少的跳转这都会跳到最后的结尾，思路就是一个个的试一试，然后程序就死了，这样就还是回到eax上，找到那个修改eax的函数，</p>
<p><img src="image-20220228152039024.png" alt="image-20220228152039024"></p>
<p>这里把她都改成1，然后patch之后，惊喜的发现程序可以转5页+了<strong>成功了</strong></p>
<p>复盘一下：</p>
<p>找到程序的代码段，首先跳过开始的弹窗（不要改lock指令下的跳转），然后再找到setgn bl指令上的对eax修改的函数，进去之后把他们改成1，完成【这是对与word2pdf的转换，别的模块可能相似】</p>
<p><img src="image-20220228153308945.png" alt="image-20220228153308945"></p>
<p>先改1，跳开始窗口</p>
<p>再改</p>
<p><img src="image-20220228153426521.png" alt="image-20220228153426521"></p>
<p>看一下这个函数会被执行多少次，判断是不是一个全局的判断函数，还是模块特有的，是模块特有的，根据相似思路，对别的模块进行分析</p>
<p>合并pdf的功能会弹窗，但是正常执行，忍一忍吧，实在没找到那里改，图片压缩不会带水印的，虽然弹窗有提示</p>
<p>我的版本是最新版6.0.0.6，<strong>仅供学习使用</strong></p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>江苏省赛2021题解</title>
    <url>/2021/09/01/%E6%B1%9F%E8%8B%8F%E7%9C%81%E8%B5%9B2021%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="2021领航杯APK逆向"><a href="#2021领航杯APK逆向" class="headerlink" title="2021领航杯APK逆向"></a>2021领航杯APK逆向</h1><p>没见过这么急促、简陋的比赛</p>
<span id="more"></span>
<p>言归正传</p>
<h2 id="本题反思："><a href="#本题反思：" class="headerlink" title="本题反思："></a>本题反思：</h2><p>反码，补码这些要会算，不能只会正数，负数也要会。</p>
<p>基础不牢啊，这道题如果算对了-16的二进制码就出了，300分可惜可惜</p>
<p>题目简单，但还是要以此为戒增强基础</p>
<p>一定要明白运算的含义，不能马虎</p>
<h2 id="知识提要："><a href="#知识提要：" class="headerlink" title="知识提要："></a>知识提要：</h2><p>APK文件要了解的基础</p>
<ul>
<li>每一个apk文件都是可以解压的</li>
</ul>
<p>解压之后一般会出现以下文件（纯APK，无添加别的引擎）</p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等等信息</p>
<h3 id="META-INF目录"><a href="#META-INF目录" class="headerlink" title="META-INF目录"></a>META-INF目录</h3><p>1.META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全</p>
<p>2.保证了apk包里的文件不能被随意替换。如果想要替换里面的一幅图片，一段代码， 或一段版权信息，想直接解压缩、替换再重新打包，基本是不可能的。</p>
<p>3.软件修改后需要将里面的证书文件删除（.RSA、.SF、.MF三个文件）再重新签名，否则软件无法安装</p>
<h3 id="res目录"><a href="#res目录" class="headerlink" title="res目录"></a>res目录</h3><p>1.res目录存放资源文件。包括图片，字符串等等。</p>
<p>2.res文件夹里存放的大部分是软件所需的资源及布局文件（drawable存放资源、layout、xml存放布局文件.xml），部分需要汉化的单词、语句会在这些.xml文件里</p>
<h3 id="lib目录"><a href="#lib目录" class="headerlink" title="lib目录"></a>lib目录</h3><p>存放一些so文件，有的可能没有</p>
<h3 id="assets目录"><a href="#assets目录" class="headerlink" title="assets目录"></a>assets目录</h3><p>存放一些配置文件，这些文件的内容在程序运行过程中可以通过相关的API获得</p>
<h3 id="classes-dex文件"><a href="#classes-dex文件" class="headerlink" title="classes.dex文件"></a>classes.dex文件</h3><p>classes.dex是java源码编译后生成的java字节码文件（比如这个题就可以直接分析这个文件）</p>
<h3 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h3><p>编译后的二进制资源文件。resources.arsc文件是编译后的资源文件，大多数情况下，需要汉化的单词、语句绝大多数都在这个文件里，<strong>汉化</strong>的时候首先就要看这个文件。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这类简单apk首先就需要找到MainActive函数，这里我直接将class.dex文件用jadx打开了，不要管androidx开头的文件和google开头的文件，找最不一样的、出现次数最少的文件</p>
<p><img src="image-20210901225721143.png" alt="image-20210901225721143"></p>
<p>这里轻松获得源码</p>
<p>看到最下面，找到关键判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (check.m39check_final_GBYM_sE(r1)) </span><br><span class="line">&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span><span class="keyword">this</span>$<span class="number">0.</span>getApplicationContext(),<span class="string">&quot;Rightflag!&quot;</span>,<span class="number">0</span>).show();</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span><span class="keyword">this</span>$<span class="number">0.</span>getApplicationContext(), <span class="string">&quot;Wrong flag!&quot;</span>, <span class="number">0</span>).show()    &#125;</span><br></pre></td></tr></table></figure>
<p>这里需要知道参数的含义</p>
<p>判断关键的“r1”就是由函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">check.m40enc_Fz0kQmc(substring, r4, r1);</span><br></pre></td></tr></table></figure>
<p>得到的</p>
<p>该函数的三个参数很分析得到就是</p>
<p>输入的flag中间的内容；从一个文件中读取的几个字符；一个空字符</p>
<p>跳到这个函数的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">m40enc_Fz0kQmc</span><span class="params">(String str, <span class="keyword">byte</span>[] bArr, <span class="keyword">byte</span>[] bArr2)</span> </span>&#123;</span><br><span class="line">     Intrinsics.checkNotNullParameter(str, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">     Intrinsics.checkNotNullParameter(bArr, <span class="string">&quot;key&quot;</span>);</span><br><span class="line">     Intrinsics.checkNotNullParameter(bArr2, <span class="string">&quot;enc&quot;</span>);</span><br><span class="line">     <span class="keyword">byte</span>[] r0 = UByteArray.m107constructorimpl(<span class="number">36</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">         UByteArray.m118setVurrAj0(r0, i, UByte.m64constructorimpl((<span class="keyword">byte</span>) (str.charAt(i) ^ i)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt;= <span class="number">35</span>; i2++) &#123;</span><br><span class="line">         UByteArray.m118setVurrAj0(bArr2, i2, UByte.m64constructorimpl((<span class="keyword">byte</span>) (UByteArray.m113getw2LRezQ(r0, <span class="number">35</span> - i2) ^ UByteArray.m113getw2LRezQ(bArr, i2 % <span class="number">16</span>))));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i3 = <span class="number">0</span>; i3 &lt;= <span class="number">35</span>; i3++) &#123;</span><br><span class="line">         <span class="keyword">byte</span> b = UByteArray.m113getw2LRezQ(bArr2, i3);</span><br><span class="line">         UByteArray.m118setVurrAj0(bArr2, i3, UByte.m64constructorimpl((<span class="keyword">byte</span>) UnsignedUtils.m361uintDivideJ1ME1BU(UInt.m132constructorimpl(UByte.m64constructorimpl((<span class="keyword">byte</span>) (UByteArray.m113getw2LRezQ(bArr2, i3) &amp; -<span class="number">16</span>)) &amp; UByte.MAX_VALUE), <span class="number">16</span>)));</span><br><span class="line">         UByteArray.m118setVurrAj0(bArr2, i3 + <span class="number">36</span>, UByte.m64constructorimpl((<span class="keyword">byte</span>) (b &amp; <span class="number">15</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到主函数判断的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">m39check_final_GBYM_sE</span><span class="params">(<span class="keyword">byte</span>[] bArr)</span> </span>&#123;</span><br><span class="line">    Intrinsics.checkNotNullParameter(bArr, <span class="string">&quot;enc&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">71</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;abcdefgh13462579&quot;</span>.charAt(UByteArray.m113getw2LRezQ(bArr, i) &amp; UByte.MAX_VALUE) != <span class="string">&quot;ccccebeebbeafbeeeabefabfaffffafaafaaea4b292he31922g6d54a62hchf2bb9ehagdc&quot;</span>.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据这个函数，可以直接求出r1的值（判断里的参数），但是这里需要注意的是，jadx不会对参数进行重命名，所以会出现参数名重复的现象，大坑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string_2=<span class="string">&quot;ccccebeebbeafbeeeabefabfaffffafaafaaea4b292he31922g6d54a62hchf2bb9ehagdc&quot;</span></span><br><span class="line">string_1=<span class="string">&quot;abcdefgh13462579&quot;</span></span><br><span class="line">bArr=<span class="string">&#x27;123456789getflag&#x27;</span></span><br><span class="line"></span><br><span class="line">barr2=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(string_2)):</span><br><span class="line">    barr2.append((string_1.index(string_2[i]))&amp;<span class="number">255</span>)</span><br><span class="line">barr2_0=[]</span><br><span class="line"><span class="built_in">print</span>(barr2)</span><br><span class="line"><span class="comment"># print(barr2_0)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    barr2_0.append(barr2[i]*<span class="number">16</span>+barr2[i+<span class="number">36</span>])</span><br></pre></td></tr></table></figure>
<p>得到r1，也就是上面函数bArr2参数</p>
<p>这样就可以求出flag了，三个循环，第一个第二个没啥好分析的，直接逆向就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前两个循环</span></span><br><span class="line">r0=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    r0[<span class="number">35</span>-i]=barr2_0[i]^<span class="built_in">ord</span>(bArr[i%<span class="number">16</span>])</span><br><span class="line"><span class="built_in">print</span>(r0)</span><br><span class="line"></span><br><span class="line">flag=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    flag.append(<span class="built_in">chr</span>(r0[i]^i))</span><br></pre></td></tr></table></figure>
<p>看到第三个循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i3 = <span class="number">0</span>; i3 &lt;= <span class="number">35</span>; i3++) &#123;</span><br><span class="line">    byte b = UByteArray.m113getw2LRezQ(bArr2, i3);</span><br><span class="line"><span class="comment">#这里首先把数组里的i位保存给b了</span></span><br><span class="line">    UByteArray.m118setVurrAj0(bArr2, i3, UByte.m64constructorimpl((byte) UnsignedUtils.m361uintDivideJ1ME1BU(UInt.m132constructorimpl(UByte.m64constructorimpl((byte) (UByteArray.m113getw2LRezQ(bArr2, i3) &amp; -<span class="number">16</span>)) &amp; UByte.MAX_VALUE), <span class="number">16</span>)));</span><br><span class="line"><span class="comment">#这里可以简化的看成i位&amp;-16之后又÷16</span></span><br><span class="line">    <span class="comment">#-16的二进制表示是：1111 1111 0000，这里可以看作是保留了这个第i位的前4位</span></span><br><span class="line">           UByteArray.m118setVurrAj0(bArr2, i3 + <span class="number">36</span>, UByte.m64constructorimpl((byte) (b &amp; <span class="number">15</span>)));</span><br><span class="line">    <span class="comment">#15的二进制是：1111，这就是保留后四位</span></span><br><span class="line">    <span class="comment">#总体来看就是将第i位拆开来算了，大坑啊我日</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这段加密的大体意思就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov EAX, [ESP+I]</span><br><span class="line">and [ESP+I], FFFFFFF0</span><br><span class="line">sal [ESP+I], 4	</span><br><span class="line">and EAX, 1111</span><br><span class="line">mov [ESP+I+0x24], EAX</span><br></pre></td></tr></table></figure>
<p>看似对对称的两个数进行操作，实际上还是一个数，给出脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line">    barr2_0.append(barr2[i]*<span class="number">16</span>+barr2[i+<span class="number">36</span>])</span><br></pre></td></tr></table></figure>
<p>组合起来就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string_2=&quot;ccccebeebbeafbeeeabefabfaffffafaafaaea4b292he31922g6d54a62hchf2bb9ehagdc&quot;</span><br><span class="line">string_1=&quot;abcdefgh13462579&quot;</span><br><span class="line">bArr=&#x27;123456789getflag&#x27;</span><br><span class="line"></span><br><span class="line">barr2=[]</span><br><span class="line">for i in range(len(string_2)):</span><br><span class="line">    barr2.append((string_1.index(string_2[i]))&amp;255)</span><br><span class="line">barr2_0=[]</span><br><span class="line">print(barr2)</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span>(barr2_0)</span></span><br><span class="line">for i in range(36):</span><br><span class="line">    barr2_0.append(barr2[i]*16+barr2[i+36])</span><br><span class="line"></span><br><span class="line">r0=[0 for i in range(36)]</span><br><span class="line">for i in range(36):</span><br><span class="line">    r0[35-i]=barr2_0[i]^ord(bArr[i%16])</span><br><span class="line">print(r0)</span><br><span class="line"></span><br><span class="line">flag=[]</span><br><span class="line">for i in range(36):</span><br><span class="line">    flag.append(chr(r0[i]^i))</span><br><span class="line">print(&#x27;&#x27;.join(flag))</span><br></pre></td></tr></table></figure>
<h2 id="APK例外"><a href="#APK例外" class="headerlink" title="APK例外"></a>APK例外</h2><p>也不算是例外，只是我觉得是例外，我做的题太少了……</p>
<p>apk游戏，buu的PixelShooter</p>
<p>这是一个由unity引擎支持的一个打飞机游戏，他的flag存在于</p>
<p>assets\bin\Data\Managed目录下的</p>
<p><strong>Assembly-CSharp.dll</strong>文件中</p>
]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>科目三学习</title>
    <url>/2021/08/29/%E7%A7%91%E7%9B%AE%E4%B8%89%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一-灯光模拟："><a href="#一-灯光模拟：" class="headerlink" title="一.灯光模拟："></a>一.灯光模拟：</h1><h2 id="1-近光灯："><a href="#1-近光灯：" class="headerlink" title="1.近光灯："></a>1.近光灯：</h2><p>同方向近距离跟车行驶。</p>
<p>通过有信号灯控制路口。</p>
<p>在有路灯照明良好的道路上行驶。</p>
<p>与非机动车会车。</p>
<span id="more"></span>
<h2 id="2-远光灯："><a href="#2-远光灯：" class="headerlink" title="2.远光灯："></a>2.远光灯：</h2><p>进入<strong>无照明</strong>的道路行驶。</p>
<p>夜间进入<strong>照明不良</strong>的道路行驶。</p>
<h2 id="3-交替灯光："><a href="#3-交替灯光：" class="headerlink" title="3.交替灯光："></a>3.交替灯光：</h2><p>超车。</p>
<p><strong>通过</strong>急弯，坡路，拱桥，人行横道，没有交通信号灯控制的路口。</p>
<h2 id="4-小灯-四闪："><a href="#4-小灯-四闪：" class="headerlink" title="4.小灯+四闪："></a>4.小灯+四闪：</h2><p>在路边临时停车。</p>
<h1 id="二-行驶："><a href="#二-行驶：" class="headerlink" title="二.行驶："></a>二.行驶：</h1><h3 id="（0）挡位与速度匹配："><a href="#（0）挡位与速度匹配：" class="headerlink" title="（0）挡位与速度匹配："></a>（0）挡位与速度匹配：</h3><p>15挂2挡，25挂三档，35挂四档。</p>
<p>但是这里不是很严格，三档开到40也可以，但是要快速换挡。</p>
<h3 id="（1）准备起步："><a href="#（1）准备起步：" class="headerlink" title="（1）准备起步："></a>（1）准备起步：</h3><p>1.<strong>逆时针</strong>绕车一圈。</p>
<p>2.报告考官请求上车。</p>
<p>3.座椅，后视镜，安全带。</p>
<p>4.<strong>离合回空挡，松离合，打火</strong>，模拟灯光。</p>
<p>5.报告个仪表工作正常，请求起步。</p>
<h3 id="（2）起步："><a href="#（2）起步：" class="headerlink" title="（2）起步："></a>（2）起步：</h3><p>（一踩二挂三转向，四喇叭五看后镜六手刹，轻抬离合把油加）</p>
<p>1.踩离合挂一档。 </p>
<p>2.拨左向灯，鸣喇叭。</p>
<p>3.观察<strong>左右后视镜，回头看</strong>，慢松离合，松手刹。</p>
<h3 id="（3）超车："><a href="#（3）超车：" class="headerlink" title="（3）超车："></a>（3）超车：</h3><p><strong><em>超</em></strong></p>
<p>1.听到指令，左转向灯，看<strong>左后视镜，回头看</strong></p>
<p>2.三秒之后条件允许，往左转方向盘15°左右</p>
<p>3<strong>.车斜回正，右脚快到路中心，往右打方向盘，车正回正</strong></p>
<p><strong><em>回</em></strong></p>
<p>4.开右转向灯，<strong>右后视镜，回头看</strong></p>
<p>5.三秒以上，条件允许，往右转方向盘15°左右</p>
<p>6.<strong>车斜回正，右脚快到路中心，往左打方向盘，车正回正</strong></p>
<h3 id="（4）路口左转弯："><a href="#（4）路口左转弯：" class="headerlink" title="（4）路口左转弯："></a>（4）路口左转弯：</h3><p>1.听到指令，左转向灯</p>
<p>2.路口前减速至1，2挡，左右观察</p>
<p>3.肩头快超过人行道时，左打四分之一方向盘</p>
<p>4.左右观察</p>
<p>5.条件允许进入中间车道，回正方向，加速加挡</p>
<h3 id="（5）人行道，学校，公交站，前方路口直行："><a href="#（5）人行道，学校，公交站，前方路口直行：" class="headerlink" title="（5）人行道，学校，公交站，前方路口直行："></a>（5）人行道，学校，公交站，前方路口直行：</h3><p>1.看（听）到后点刹车，左右观察</p>
<p>2.学校区域减速至<strong>30公里</strong>以下</p>
<h3 id="（6）路口右转弯："><a href="#（6）路口右转弯：" class="headerlink" title="（6）路口右转弯："></a>（6）路口右转弯：</h3><p>1.听到指令，右转向灯</p>
<p>2.路口前减速至1，2挡，左右观察</p>
<p>3.肩头快超过人行道时，右打一半方向盘</p>
<p>4.观察来车方向</p>
<p>5.条件允许进入中间车道，回正方向，加速加挡</p>
<h3 id="（7）掉头："><a href="#（7）掉头：" class="headerlink" title="（7）掉头："></a>（7）掉头：</h3><p>1.听到指令后，左转向灯</p>
<p>2.路口前减速到1挡，左右观察</p>
<p>3.肩膀过绿化带，桥墩左打一圈，观察来车方向</p>
<p>4.条件允许，中间车道加速加档</p>
<h3 id="（8）靠边停车："><a href="#（8）靠边停车：" class="headerlink" title="（8）靠边停车："></a>（8）靠边停车：</h3><p><strong>一定要注意前车的距离，要有一定的距离可以把车顺正，不然就会挂科 操他妈的</strong></p>
<p>1.听到指令，右转向灯</p>
<p>2.<strong>看右后视镜，向后看</strong>，减速减挡到1挡</p>
<p>3.慢松离合，选好地点，右打半圈方向</p>
<p>4.看铆钉到马路牙子下沿，回方向（打一次，回两次）</p>
<p>5.让铆钉压着路边白线行驶后 停车</p>
<p>6.拉手刹，推空挡，关转向灯，熄火，挂一档，解安全带，后拉座椅；报告考官，请求下车</p>
<p>（手刹空挡转向灯，熄火一档安全带）</p>
<p>7.<strong>看左后视镜，后头看</strong>，确认安全，下车顺时针到考官处，<strong>谢谢考官</strong></p>
]]></content>
      <categories>
        <category>悠哉日常</category>
      </categories>
      <tags>
        <tag>学车</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念一下</title>
    <url>/2021/09/02/%E7%BA%AA%E5%BF%B5%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>​    纪念一下<strong><em>2021-09-02 23:34:04</em></strong>，BUU的逆向第二页圆满完成</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>近期比赛问题</title>
    <url>/2021/10/16/%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<pre><code> 2021-10 强网杯，字节跳动，莲城杯等比赛总结
</code></pre><p>安恒月赛中的逆向相对容易，但是涉及到大量的对称加密以及非对称加密的问题，拿到带有加密的逆向多少手足无措。还有就是编程基础的欠缺，对编程语言知之甚少，还有就是对编程术语比如“断言”，“Panic”</p>
<h2 id="莲城杯"><a href="#莲城杯" class="headerlink" title="莲城杯"></a>莲城杯</h2><p>baby_rust：是用rust语言写的程序，通过wp知道根据rust语言的特点可以很快解答</p>
<p>longtime：对算法的理解和关键代码的定位能力欠缺，不能有效的识别算法，也不能优化算法。</p>
<p>brainfuck: 一种比较脑洞的加密形式，理解分析能力不够，编码能力差的离谱</p>
<p>README：代码分析能力，AES算法不了解，分辨不出魔改的TEA加密。</p>
<h2 id="强网杯"><a href="#强网杯" class="headerlink" title="强网杯"></a>强网杯</h2>]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程学习-PE文件格式</title>
    <url>/2021/08/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0-PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>PE文件是windows操作系统下的可执行文件的统称，一般指的是32位文件，64位文件称为【PE32+】</p>
<span id="more"></span>
<h2 id="文件种类："><a href="#文件种类：" class="headerlink" title="文件种类："></a>文件种类：</h2><div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>可执行文件</td>
<td>EXE, SCR</td>
</tr>
<tr>
<td>库系列文件</td>
<td>DLL, OCX, CPL, DRV</td>
</tr>
<tr>
<td>驱动程序</td>
<td>SYS, VXD</td>
</tr>
<tr>
<td>对象文件</td>
<td>OBJ</td>
</tr>
</tbody>
</table>
</div>
<h2 id="PE文件基本结构："><a href="#PE文件基本结构：" class="headerlink" title="PE文件基本结构："></a>PE文件基本结构：</h2><h3 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h3><p>PE头+PE体</p>
<p>PE头：DOS头；DOS存根；NT头；节区头【text（代码）；data（数据）；rsrc（资源）】</p>
<p>PE头与各节区的尾部存在一个【NULL填充】区域：</p>
<p><img src="image-20210831160207999.png" alt="image-20210831160207999" style="zoom:150%;" /></p>
<h3 id="VA-amp-RVA"><a href="#VA-amp-RVA" class="headerlink" title="VA  &amp;  RVA:"></a>VA  &amp;  RVA:</h3><p>1.VA：进程虚拟内存的绝对地址</p>
<p>2.RVA：从某个基准位置开始的相对地址</p>
<p>（虚拟内存：在32位的Windows中，各个进程分配4GB的虚拟内存，所以VA的范围【00000000~ffffffff】）</p>
<script type="math/tex; mode=display">
RVA + ImageBase = VA</script><p>PE内部信息大多数以RVA形式存在，这样方便地址重定位</p>
<h2 id="PE头："><a href="#PE头：" class="headerlink" title="PE头："></a>PE头：</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>1.起源：微软在创建PE文件时，DOS广泛使用，所以在PE头前面加了一个<strong>IMAGE_DOS_HEADER</strong>结构体，内容如下。</p>
<p><img src="image-20210831162112162.png" alt="image-20210831162112162"></p>
<p>2.结构体大小共64字节，有两个重要成员【e_magic   &amp;   e_lfanew】。</p>
<p>e_magic：DOS签名，对应的是字符===&gt;”MZ”</p>
<p>e_lfanew：指示NT头的偏移，不同的文件值也不一样。</p>
<p><img src="image-20210831162156817.png" alt="image-20210831162156817"></p>
<p>这里看出最后就是e_lfanew的值是 00 00 00 B0（小端序）</p>
<h4 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h4><p>在dos头下面，大小不固定，有没有都行，由代码和数据混合而成</p>
<p><img src="image-20210708191640915.png" alt="image-20210708191640915"></p>
<p>代码的作用就是在你用DOS运行时出现后面那句话</p>
<h3 id="NT头（IMAGE-NT-HEADER）"><a href="#NT头（IMAGE-NT-HEADER）" class="headerlink" title="NT头（IMAGE_NT_HEADER）"></a>NT头（IMAGE_NT_HEADER）</h3><p>NT头又名”文件头“，是表现文件大致属性的“IMAGE_NT_HEADER”结构体</p>
<p>内涵3个成员，总共大小为0xF8:(根据DOS头指出的偏移可以找到)</p>
<p><img src="image-20210831163457833.png" alt="image-20210831163457833"></p>
<p><img src="image-20210831163317838.png" alt="image-20210831163317838"></p>
<p>第一个成员是<strong>签名结构体</strong>：值为【50 45 00 00】=====&gt;’PE‘</p>
<p>第二个成员是<strong>文件头结构体</strong>===&gt;IMAGE_FILE_HEADER</p>
<p>第三个成员是<strong>可选头结构体</strong>===&gt;IMAGE_OPTIONAL_HEADER</p>
<h4 id="文件头结构体（IMAGE-FILE-HEADER）"><a href="#文件头结构体（IMAGE-FILE-HEADER）" class="headerlink" title="文件头结构体（IMAGE_FILE_HEADER）"></a>文件头结构体（IMAGE_FILE_HEADER）</h4><p>表现文件大致属性 IMAGE_FILE_HEADER结构体</p>
<p><img src="image-20210831163600312.png" alt="image-20210831163600312"></p>
<p><img src="image-20210831165137520.png" alt="image-20210831165137520"></p>
<p>对应着如下结构体</p>
<p><img src="image-20210831171701776.png" alt="image-20210831171701776"></p>
<p>内涵四个重要成员：Machine，NumberOfSections，SizeOfOptionalHeader，Characteristics</p>
<p>（程序能否运行的关键）</p>
<ul>
<li><p>Machine：每个CPU都有唯一的Machine码</p>
<p><img src="image-20210831163725281.png" alt="image-20210831163725281"></p>
</li>
</ul>
<p>这里看到我的CPU对应的机器码是：0x014C</p>
<ul>
<li>NumberOfSections</li>
</ul>
<p>指出文件中存在节区的数量，一定要大于零。定义与实际不符会运行失败</p>
<p>看上图知道应该是”05“</p>
<ul>
<li>SizeOfOptionalHeader</li>
</ul>
<p>指出NT结构体最后一个成员【IMAGE_OPTIONAL_HEADER32】的结构体长度，64位和32位不同。</p>
<ul>
<li>Characerristics</li>
</ul>
<p>用于标记文件属性。即文件是否是可运行状态，是否是DLL文件等信息，通过bit OR形式组合起来。</p>
<p><img src="image-20210831164610110.png" alt="image-20210831164610110"></p>
<p>注：Characteristics的值有可能是【0002h】（不可执行），比如obj文件和resource DLL文件。</p>
<p>这里SYS文件时0x1000</p>
<p>可用于区分不同的文件类型</p>
<h4 id="可选头结构体（IMAGE-OPTIONAL-HEADER32）"><a href="#可选头结构体（IMAGE-OPTIONAL-HEADER32）" class="headerlink" title="可选头结构体（IMAGE_OPTIONAL_HEADER32）"></a>可选头结构体（IMAGE_OPTIONAL_HEADER32）</h4><p>特点：PE头结构体中最大的结构体：</p>
<p><img src="image-20210831165328723.png" alt="image-20210831165328723"></p>
<p>关键成员，出错文件将无法运行：Magic，AddressOfEntryPoint，ImageBase，SectionAlignment，FileAlignment。</p>
<p><img src="image-20210831165536267.png" alt="image-20210831165536267"></p>
<p>对应着如下节选的结构体</p>
<p><img src="image-20210831171800697.png" alt="image-20210831171800697"></p>
<ul>
<li>Magic：在32位中，Magic码是10B，64位是20B；这里显然是一个32位程序</li>
<li><p>AddressOfEntryPoint：拥有EP和RVA的值，该值指出程序最先执行的代码起始地址</p>
</li>
<li><p>ImageBase：当PE文件装入内存时，指出文件  的优先装入地址</p>
<p>Tips：EXE,DLL文件一般装载到用户内存的0~7fffffff中，SYS文件载入内核内存的80000000~ffffffff里；在执行PE文件时，PE装载器事先创建进程，文件载入内存，设置EIP的值为</p>
</li>
</ul>
<ul>
<li><p>SectionAlignment，FileAlignment：PE文件的PE体部分划分不同区节，存储着不同类别的数据，FileAlignment指定了节区在磁盘文件中的最小单位；SectionAlignment指定了节区在内存中的最小单位；在一个文件中，二者的值不一定相等，但是节区的大小必然是SectionAlignment或FileAlignment的整倍数。</p>
</li>
<li><p>SizeOfImage：指定了PE Image在虚拟内存中所占的大小</p>
</li>
<li>SizeOfHEADER：指出整个PE头的大小，该值一定是FileAlignment值的整数倍。第一节区所在位置与SizeOfHEADER距离文件开始的偏移量相同</li>
<li>Subsystem：该值用来区分系统驱动文件和普通的可执行文件。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Driver文件</td>
<td>系统驱动（如：ntfs.sys）</td>
</tr>
<tr>
<td>2</td>
<td>GUI文件</td>
<td>窗口应用程序（如：记事本.exe）</td>
</tr>
<tr>
<td>3</td>
<td>GUI文件</td>
<td>控制台应用程序（如：CMD.EXE)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>NumberOfRvaAndSizes：指定结构体：IMAGE_OPTIONAL_HEADER32最后一个成员数组的个数，虽然明确指出时16，但是也不一定</li>
<li>DataDirection：IMAGE_OPTIONAL_HEADER32最后一个成员；由IMAGE_DATA_DIRECTORY结构体构成的数组，每一项都有被定义的值：</li>
</ul>
<p><img src="image-20210831171409417.png" alt="image-20210831171409417"></p>
<h3 id="节区头（IMAGE-SECTION-HEADER）"><a href="#节区头（IMAGE-SECTION-HEADER）" class="headerlink" title="节区头（IMAGE_SECTION_HEADER）"></a>节区头（IMAGE_SECTION_HEADER）</h3><p>组成：由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。</p>
<p>作用：定义了各节区的属性</p>
<p><img src="image-20210831172859859.png" alt="image-20210831172859859"></p>
<p>结构体：</p>
<p><img src="image-20210831172237863.png" alt="image-20210831172237863"></p>
<p>重要成员：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>VirtualSize</td>
<td>内存中节区所占大小</td>
</tr>
<tr>
<td>VirtualAddress</td>
<td>内存中节区起始地址</td>
</tr>
<tr>
<td>SizeOfRawData</td>
<td>硬盘中节区所占大小</td>
</tr>
<tr>
<td>PointerToRawData</td>
<td>硬盘中节区起始地址</td>
</tr>
<tr>
<td>Characteristics</td>
<td>节区属性</td>
</tr>
</tbody>
</table>
</div>
<p>Tips：VA和PointerToRawData不带有任何值，分别由IMAGE_OPTIONAL_HEADER32结构体中的SectionAlignment和FileAlignment定义；SizeOfRawData和VirtualSize的值一般不同</p>
<p>Characteristic由以下的值组合而成：</p>
<p><img src="image-20210831172929874.png" alt="image-20210831172929874"></p>
<p>Ps:当PE文件加载到内存时，不是原封不动的加载，而是根据节区头中定义的节区起始地址，节区大小等加载，所以在磁盘里的PE文件和在内存中的PE文件具有不同的形态，这一过程称为“映像”（image）</p>
<h1 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h1><h2 id="是什么："><a href="#是什么：" class="headerlink" title="是什么："></a>是什么：</h2><p>PE文件加载到内存时，每个节区都要能准确完成<strong>内存地址</strong>与<strong>文件偏移</strong>间的映射。这一过程称为RVA   to   RAW（文件偏移）。</p>
<h2 id="计算方法："><a href="#计算方法：" class="headerlink" title="计算方法："></a>计算方法：</h2><p>公式：</p>
<ul>
<li><p>RAW-PointerToRawData=RVA-VA</p>
</li>
<li><p>RAW=RVA-VA+PointerToRawData</p>
</li>
</ul>
<p>例题：</p>
<p><img src="image-20210708205117927.png" alt="image-20210708205117927"></p>
<p>1.当RAV（相对地址）= 5000时，File Offset = ？</p>
<p>已知RAV=5000在.text节区，且ImageBase=01000000，根据</p>
<ul>
<li>RAW=RVA-VA+PointerToRawData</li>
</ul>
<p>RAW=5000-1000+400=4400</p>
<h1 id="IAT（Import-Address-Tables）"><a href="#IAT（Import-Address-Tables）" class="headerlink" title="IAT（Import_Address_Tables）"></a>IAT（Import_Address_Tables）</h1><h2 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h2><p>IAT：Import_Address_Tables,导入地址表）是一个用来记录程序正在使用哪些库里的哪些函数的表格</p>
<h2 id="DLL（动态链接库）："><a href="#DLL（动态链接库）：" class="headerlink" title="DLL（动态链接库）："></a>DLL（动态链接库）：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.不需要把库包含到程序中（C语言就需要提前导入库），需要时调用即可。</p>
<p>2.可以在多个进程中共享。</p>
<p>3.更新库时只需要替换相关的DLL文件。</p>
<h3 id="加载方式："><a href="#加载方式：" class="headerlink" title="加载方式："></a>加载方式：</h3><p>1.显示链接：程序使用时加载，使用完毕后释放内存。</p>
<p>2.隐式链接：程序开始时一同加载DLL，程序终止时释放内存。（IAT提供的机制与隐式链接有关）</p>
<h2 id="IMAGE-IMPORT-DESCRIPTOR（IID）"><a href="#IMAGE-IMPORT-DESCRIPTOR（IID）" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR（IID）:"></a>IMAGE_IMPORT_DESCRIPTOR（IID）:</h2><p>也被称为IMPORT Directory Table</p>
<p>该结构体记录着PE文件要导入哪些库文件。（Import：导入，向库提供服务（函数）；Export：导出，由库向PE文件提供服务（函数））</p>
<p><img src="image-20210831174510190.png" alt="image-20210831174510190"></p>
<p>1.执行一个程序需要许多库，导入多少库，就有多少这种结构体，这些结构体构成一个<strong>数组</strong>，该数组以NULL结构体结束。</p>
<p>2.重要成员：OriginalFirstThunk: 是INT的地址（RVA），Name：库名称字符串的地址（RVA），FirstThunk：IAT的地址 RVA。</p>
<ul>
<li>INT===&gt;IMPORT NAME TABLE；IAT===&gt;IMPORE ADDRESS TABLE（table：数组）</li>
<li>INT与IAT是长整型数组，以NULL结束</li>
<li>INT中个元素的值为IMAGE_IMPORT_BY_NAME结构体指针</li>
<li>INT IAT大小应相同</li>
</ul>
<p><img src="image-20210831175012865.png" alt="image-20210831175012865"></p>
<p>PE装载器把导入函数输入至IAT的顺序</p>
<p><img src="image-20210831175304097.png" alt="image-20210831175304097"></p>
<h3 id="尝试找到IID结构体"><a href="#尝试找到IID结构体" class="headerlink" title="尝试找到IID结构体"></a>尝试找到IID结构体</h3><p>1.该结构体不在PE头中，他存在于PE体中，但是他的位置在PE头中</p>
<p>2.位于：IMAGE_OPTIONAL_HEADER32.DataDirectory[1].VritualAddress；这便是结构体的起始地址</p>
<h1 id="EAT"><a href="#EAT" class="headerlink" title="EAT"></a>EAT</h1><h2 id="介绍：-2"><a href="#介绍：-2" class="headerlink" title="介绍："></a>介绍：</h2><p>1.EAT是一种核心机制，可以让不同的程序调用库提供的函数。只用通过EAT才能准确求得从相应库中导出函数的起始地址。</p>
<p>2.PE文件特有的结构体image_export_DIRECTORY保存着导出信息。并且PE文件中仅有<strong>一个</strong>用来说明库EAT的结构体</p>
<p>【用来说明IAT的结构体IMAGE_IMPORT_DESCRIPTOR以数组的形式存在，拥有多个成员，这样PE文件可以同时导入多个库】</p>
<h2 id="IMAGE-EXPORT-DIRECTORY："><a href="#IMAGE-EXPORT-DIRECTORY：" class="headerlink" title="IMAGE_EXPORT_DIRECTORY："></a>IMAGE_EXPORT_DIRECTORY：</h2><p>结构体如下</p>
<p><img src="image-20210831180851274.png" alt="image-20210831180851274"></p>
<p>重要成员：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NumberOfFunctions</td>
<td>实际的Export函数的个数</td>
</tr>
<tr>
<td>NumberOfNames</td>
<td>Export函数中具名的函数个数</td>
</tr>
<tr>
<td>AddressOfFunctions</td>
<td>Export函数地址数组（元素个数等于表中第一个项目）</td>
</tr>
<tr>
<td>AddressOfNames</td>
<td>函数名称的地址数组（元素个数等于表中第二个项目）</td>
</tr>
<tr>
<td>AddressOfNameOrdinals</td>
<td>Ordinal地址数组（元素个数等于表中第二个项目）</td>
</tr>
</tbody>
</table>
</div>
<p>Ordinals：导出函数的固有编号。因为有的函数没有函数名，只有一个编号</p>
<p><img src="image-20210831204013551.png" alt="image-20210831204013551"></p>
<h2 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress():"></a>GetProcAddress():</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>从库中获得函数地址，该API引用EAT来获取指定的API的地址</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过引用EAT来获取指定API的地址</p>
<p><img src="image-20210831181112965.png" alt="image-20210831181112965"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.PE规范只是一种规范，仅此而已。</p>
<p>2.PE头并非一成不变，而是灵活度极高。</p>
<p><img src="image-20220421161743618.png" alt="image-20220421161743618"></p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>链表学习（C语言）</title>
    <url>/2022/01/06/%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0%EF%BC%88C%E8%AF%AD%E8%A8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="链表学习"><a href="#链表学习" class="headerlink" title="链表学习"></a>链表学习</h1><span id="more"></span>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>这里用一个学号+姓名的结构体学习单链表的 “头插法” 。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> nums;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">next</span>;</span><span class="comment">//这里的next虽然拼写一样，但是在每一个节点的结构体里指向的都是他后面那个结构体</span></span><br><span class="line">&#125;;					<span class="comment">//这里新建结构体，一定要放在前面，不然后面的函数调用报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opdata</span><span class="params">(struct STU *student)</span><span class="comment">//传进来一个结构体指针，该指针指向一个结构体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;input the nums: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;student-&gt;nums);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;input the name: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, student-&gt;name);</span><br><span class="line">&#125;								<span class="comment">//这个指针指向的结构体赋值成功</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addnode</span><span class="params">(struct STU **student)</span><span class="comment">//这里传递的是“指向指针的指针”，</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">temp</span>, *<span class="title">new_stu</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (*student != <span class="literal">NULL</span>)		<span class="comment">//这里说如果传进来的节点不是最后一个</span></span><br><span class="line">	&#123;							<span class="comment">//*student是内容所在的地址，student存放的是*student的地址</span></span><br><span class="line">		new_stu = (struct STU*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct STU));<span class="comment">//新建一个节点，并申请一个空间</span></span><br><span class="line">		opdata(new_stu);</span><br><span class="line"></span><br><span class="line">		temp = *student;	<span class="comment">//先将原先指向数据的地址保存为temp</span></span><br><span class="line">		*student = new_stu;	<span class="comment">//指针更新成新的指针</span></span><br><span class="line">		new_stu-&gt;next = temp;<span class="comment">//新的节点的next指针指向原来的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>		<span class="comment">//传进来的是最后一个节点，也就是说链表是空的，这样直接在后面加就可以</span></span><br><span class="line">	&#123;</span><br><span class="line">		new_stu = (struct STU*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct STU));</span><br><span class="line">        opdata(new_stu);</span><br><span class="line">		*student = new_stu;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintData</span><span class="params">(struct STU *student)</span><span class="comment">//传进来一个指向结构体的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">stu</span>;</span>				<span class="comment">//新建中间人，这里是为了防止参数被改变，使后面的释放函数出错</span></span><br><span class="line">	stu = student;</span><br><span class="line">	<span class="keyword">while</span>(stu != <span class="literal">NULL</span>)				<span class="comment">//等于NULL的话就说明到最后一个了，</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;xuehao is %u\n&quot;</span>, stu-&gt;nums);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;name is %s\n&quot;</span>, stu-&gt;name);</span><br><span class="line">		stu = stu-&gt;next;			<span class="comment">//不断指向next</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseMem</span><span class="params">(struct STU **student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span>  *<span class="title">temp</span>;</span>		<span class="comment">//找第三方替换，不然直接free的话 只能free一个，剩下的free不了</span></span><br><span class="line">	<span class="keyword">while</span>( *student != <span class="literal">NULL</span> )<span class="comment">//内容所在的地址不是空的</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp = *student;	<span class="comment">//中间变量接受地址</span></span><br><span class="line">		*student = (*student)-&gt;next;	<span class="comment">//内容的地址指向下一组内容</span></span><br><span class="line">		<span class="built_in">free</span>(temp);			<span class="comment">//free掉刚刚的内存空间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">STU</span>* <span class="title">student</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the addr of (*student) is %p\n&quot;</span>,student);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the addr of (&amp;student) is %p\n&quot;</span>,&amp;student);</span><br><span class="line">	addnode(&amp;student);			<span class="comment">//这里把这个结构体指针的地址传进去，让一个新的节点指向这个地址</span></span><br><span class="line">	PrintData(student);			<span class="comment">//这里就正常的传递一个结构体指针</span></span><br><span class="line">	releaseMem(&amp;student);		<span class="comment">//也是把这个结构体指针的地址传进去</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;successful&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于程序中指向指针的指针我理解为</p>
<p><img src="链表学习（C语言）/image-20220106192242683.png" alt="image-20220106192242683"></p>
<p>这里addnode和releaseMem函数的参数均是二级指针，这个指针指向了 “指向数据内容的一级指针” </p>
<h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OpStu</span><span class="params">(struct stu *student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;name : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, student -&gt; name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Score : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;student -&gt; score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主要不同之处就在于这里的节点插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddStu</span><span class="params">(struct stu **student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">new_stu</span> =</span> (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));</span><br><span class="line">    <span class="comment">//为新节点分配空间</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">end_node</span>;</span></span><br><span class="line">	<span class="comment">//创建静态变量来存储尾节点</span></span><br><span class="line">	OpStu(new_stu);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (*student == <span class="literal">NULL</span>)<span class="comment">//如果是一个空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		*student = new_stu;<span class="comment">//直接把头的指针指向新生成的数据</span></span><br><span class="line">		new_stu-&gt;next = <span class="literal">NULL</span>;<span class="comment">//最后在他后面补上NULL，或者可以是</span></span><br><span class="line">        <span class="comment">//(*student) -&gt; next = NULL 解引用和-&gt;的优先级不一样</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//不是空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		end_node-&gt;next = new_stu;<span class="comment">//尾节点的下一项是新节点</span></span><br><span class="line">		new_stu-&gt;next = <span class="literal">NULL</span>;<span class="comment">//封底</span></span><br><span class="line">	&#125;</span><br><span class="line">	end_node = new_stu;<span class="comment">//尾接点指向新节点的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNode</span><span class="params">(struct stu *students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">temp</span>;</span></span><br><span class="line">	temp = students;</span><br><span class="line">	<span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;name is %s, got %d scores\n&quot;</span>, temp-&gt;name, temp-&gt;score);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FINISH\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleasMem</span><span class="params">(struct stu **students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">temp</span>;</span></span><br><span class="line">	<span class="comment">//temp = *students;</span></span><br><span class="line">	<span class="keyword">while</span>(*students != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = *students;</span><br><span class="line">		*students = (*students)-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;free end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">student</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">while</span>(i!=<span class="number">0</span>)<span class="comment">//用五组数据进行测试</span></span><br><span class="line">	&#123;</span><br><span class="line">		AddStu(&amp;student);</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	PrintNode(student);</span><br><span class="line">	ReleasMem(&amp;student);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入，删除"><a href="#插入，删除" class="headerlink" title="插入，删除"></a>插入，删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(<span class="keyword">int</span> addr, struct stu *student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int count=0;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">stu</span> =</span> student;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">newstu</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">temp</span>;</span></span><br><span class="line">	<span class="keyword">for</span>(;addr<span class="number">-1</span>!=<span class="number">0</span>;addr--)<span class="comment">//先通过循环找到要插入的节点的位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		stu = stu-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf(&quot;insert location---&gt; %s,%d\n\n&quot;,stu-&gt;name,stu-&gt;score);</span></span><br><span class="line">	newstu = (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));</span><br><span class="line">	OpStu(newstu);<span class="comment">//准备好要插入的新节点</span></span><br><span class="line"></span><br><span class="line">	temp = stu-&gt;next;<span class="comment">//将前一个节点的next指针用temp保存</span></span><br><span class="line">	stu-&gt;next = newstu;<span class="comment">//前一个节点的next指针指向新的插入的节点</span></span><br><span class="line">	newstu-&gt;next = temp;<span class="comment">//新节点的next指针指向原来的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeletNode</span><span class="params">(<span class="keyword">int</span> addr, struct stu* student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">under</span>, *<span class="title">stu</span>, *<span class="title">pre</span>;</span></span><br><span class="line">	stu = student;</span><br><span class="line">	<span class="keyword">for</span>(;addr!=<span class="number">1</span>;addr--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (addr == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pre = stu;<span class="comment">//将要删除节点的前一个节点保存</span></span><br><span class="line">		&#125;</span><br><span class="line">		stu = stu-&gt;next;<span class="comment">//找到要删除的节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//printf(&quot;delete location---&gt; %s,%d\n\n&quot;,stu-&gt;name,stu-&gt;score);</span></span><br><span class="line">	under = stu-&gt;next;<span class="comment">//保存要删除节点的后一个节点</span></span><br><span class="line">    pre-&gt;next = under;<span class="comment">//将删除节点的前一个节点指向后一个节点</span></span><br><span class="line">	<span class="comment">//printf(&quot;pre location---&gt; %s,%d\n\n&quot;,pre-&gt;name,pre-&gt;score);</span></span><br><span class="line">	<span class="comment">//printf(&quot;under location---&gt; %s,%d\n\n&quot;,under-&gt;name, under-&gt;score);</span></span><br><span class="line">	<span class="built_in">free</span>(stu);<span class="comment">//free掉删除的节点的内存空间</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;delete success&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入：</p>
<p><img src="链表学习（C语言）/image-20220107123357566.png" alt="image-20220107123357566"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构入门</tag>
      </tags>
  </entry>
  <entry>
    <title>读过的书</title>
    <url>/2021/09/12/%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/</url>
    <content><![CDATA[<p> 记录一下读过的书和读书笔记吧</p>
]]></content>
      <categories>
        <category>读过的书</category>
      </categories>
      <tags>
        <tag>你好，世界</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程学习-基础篇</title>
    <url>/2021/08/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h1 id="逆向工程学习-基础1"><a href="#逆向工程学习-基础1" class="headerlink" title="逆向工程学习-基础1"></a>逆向工程学习-基础1</h1><span id="more"></span>
<p><a href="http://www.baidu.com">http://www.baidu.com</a></p>
<h2 id="字节序："><a href="#字节序：" class="headerlink" title="字节序："></a>字节序：</h2><h3 id="1-小端序"><a href="#1-小端序" class="headerlink" title="1.小端序"></a>1.小端序</h3><p>1.当一个数据只有一个字节时，大小端序都一样</p>
<p>2.地址高位存储数据的高位，人眼看来是逆序存储</p>
<p><img src="image-20210831121649274.png" alt="image-20210831121649274"></p>
<h3 id="2-大端序"><a href="#2-大端序" class="headerlink" title="2.大端序"></a>2.大端序</h3><p>1.地址低位存储数据高位，人眼看起来是正常的</p>
<p>2.应用于大型服务器和risc系列的CPU。</p>
<h3 id="另外："><a href="#另外：" class="headerlink" title="另外："></a>另外：</h3><p>【字符数组】在内存中是连续的，无论大小端序，储存顺序相同</p>
<h2 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h2><h3 id="基本程序运行寄存器"><a href="#基本程序运行寄存器" class="headerlink" title="基本程序运行寄存器"></a>基本程序运行寄存器</h3><div class="table-container">
<table>
<thead>
<tr>
<th>寄存器类型</th>
<th>寄存器名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用寄存器</td>
<td>eax, ebx, ecx, edx, esi, edi, ebp, esp</td>
</tr>
<tr>
<td>段寄存器</td>
<td>cs, ds, ss, es, fs, gs</td>
</tr>
<tr>
<td>程序状态与控制寄存器</td>
<td>EFLAGS</td>
</tr>
<tr>
<td>指令指针寄存器</td>
<td>EIP</td>
</tr>
</tbody>
</table>
</div>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>ESP（栈顶指针）:指示栈区域的栈顶地址。</p>
<p>EBP（栈帧指针）:表示栈区域的基地址，函数被调用时，保存ESP的的值，函数返回时再将值还给ESP，以保证栈不会崩溃（栈帧技术）。</p>
<p>ESI,EDI：这两个寄存器与特定指令（LODS, STOP, REP, MOVS等）一起使用时，主要用于内存复制（例：upx解压缩时恢复upx0节区）</p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>1.什么是段：是一种将内存划分为多个区段的内存保护技术，与分页技术一起将虚拟内存变为实际物理内存。段内存记录在Segment Deskcriptor Table(SDT)段描述表中，段寄存器持有这些SDT的索引</p>
<p><img src="image-20210831140543512.png" alt="image-20210831140543512"></p>
<p>每个段寄存器指向的段描述符结合虚拟内存，形成一个线性地址，在借助分页技术，线性地址转化为实际的物理地址（如果没有分页技术，线性地址直接变成物理地址）</p>
<h3 id="程序状态与控制寄存器"><a href="#程序状态与控制寄存器" class="headerlink" title="程序状态与控制寄存器"></a>程序状态与控制寄存器</h3><p>就是所说的标志位寄存器，一开始我认为是不同的寄存器，现在发现是一个寄存器中的不同的位</p>
<p><img src="image-20210831141323762.png" alt="image-20210831141323762"></p>
<p>32位程序中，该寄存器由原来的16位的FLAGS寄存器拓展到了32的EFLAGS寄存器，其中常用的有ZF, OF, CF。</p>
<p>ZF（0标志）：若运算结果是“0“，那么该标志位为”1“</p>
<p>OF（溢出标志）：有符号整数溢出时，该标志位为”1“；或最高有效位改变时，该标志位为”1“</p>
<p>CF（进位标志）：无符号整数溢出时为”1“</p>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>当程序运行时，cpu会读取EIP中的一条地址，当地址传递到缓冲区后，eip会增加，增加的大小就是读取指令的字节大小。</p>
<h2 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li><p>一种由高地址像低地址拓展的数据结构</p>
</li>
<li><p>暂时保存函数内部的局部变量</p>
</li>
<li>传递参数</li>
<li>保存函数的返回地址（就是call指令的下一条地址）</li>
</ul>
<p><img src="image-20210831142251690.png" alt="image-20210831142251690"></p>
<h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><p>1.两个指针：栈顶指针ESP；栈帧指针EBP</p>
<p>2.向栈中push数据时，栈顶指针ESP会减小（上移），当pop数据时，ESP会增加（下移）。</p>
<p>3.栈顶指针（ESP）在初始状态下指向栈底（高地址），所以初始化栈即为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push EBP		//使用EBP前先将已有值保存在栈中</span><br><span class="line">MOV EBP, ESP	//保存当前ESP到EBP中</span><br><span class="line">……</span><br><span class="line">MOV ESP, EBP	//将函数的起始地址还给ESP</span><br><span class="line">POP EBP			//将一开始push进栈的地址还给EBP</span><br></pre></td></tr></table></figure>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>1.是什么：是利用EBP（栈帧指针）寄存器访问栈内局部变量、参数、函数返回地址等的手段。 </p>
<p>2.为什么需要用到栈帧指针EBP：因为栈顶是在不断变化的（push, pop, call等都会影响栈顶），所以如果用ESP来当作基址进行索引是很复杂的，所以就需要一个相对固定的来打下手的帮忙，就是EBP。所以在开始的时候，都会把esp的值给ebp。</p>
<h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h3><p>C语言的默认调用方式，调用者负责恢复栈结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add esp, 0x8</span><br></pre></td></tr></table></figure>
<p><img src="image-20210831151852977.png" alt="image-20210831151852977"  /></p>
<p>这里因为push了两个int类型的参数，所以栈空间-0x8</p>
<p>好处：可以向 被调用函数 传递 参数可变 的函数</p>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><p>由被调用者恢复堆栈</p>
<p>该调用方式被Win32 API采用，以获得更好的兼容性</p>
<h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>与stdcall类似，只不过前两个参数通过寄存器【ECX, EDX】快速调用。顾名思义，这里可以实现更快的调用函数，因为CPU访问寄存器的速度远高于CPU访问内存的速度。</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr_0</title>
    <url>/2022/03/02/Angr-0/</url>
    <content><![CDATA[<p> Angr学习1，一些简单的用法：</p>
<span id="more"></span>
<h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1><p>理解：输入的不是特定的字符，而是一个符号（可以理解为：x），每执行一步，就记录下执行的条件（此为执行）。遇到分支语句，就分为两个方程，分别对应不同的路线，这样程序执行完之后，就得到了一群方程，想要那一条路径，就分析哪一串方程。</p>
<p>相当于就是用方程的形式，历遍了所有的路径，最后根据需要去解出对应路径的方程，得到答案。</p>
<h1 id="Angr使用"><a href="#Angr使用" class="headerlink" title="Angr使用"></a>Angr使用</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project = angr.Project(<span class="string">&quot;./00_angr_find&quot;</span>, auto_load_libs=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>angr的二进制装载组件是<strong>CLE</strong>，它负责装载二进制对象（以及它依赖的任何库），angr将这些包含在Project类中。</li>
<li>uto_load_libs：是否载入依赖库，默认是true，一般设置为false，好处是不会去分析lib中的函数，减少时间，缺点是无法分析外部函数</li>
</ul>
<h3 id="设置状态-state"><a href="#设置状态-state" class="headerlink" title="设置状态(state)"></a>设置状态(state)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">initial_state = project.factory.entry_state()<span class="comment">#执行引擎从程序的入口点开始符号执行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>entry_state()：做一些初始化工作，然后在 程序的 入口停下</li>
</ul>
<p>state代表程序的一个实例镜像，模拟执行某个时刻的状态，就类似于<strong>快照</strong>。保存运行状态的上下文信息。</p>
<p>保留每一步的条件。</p>
<h3 id="设置-Simulation-Managers（模拟管理器）"><a href="#设置-Simulation-Managers（模拟管理器）" class="headerlink" title="设置 Simulation Managers（模拟管理器）"></a>设置 Simulation Managers（模拟管理器）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simulation = project.factory.simgr(initial_state)</span><br></pre></td></tr></table></figure>
<p>Project 对象表示程序一开始的样子，而在执行时，我们实际上是对<strong>SimState对象</strong>进行操作，她模拟执行某个时刻的状态</p>
<h3 id="探索路径"><a href="#探索路径" class="headerlink" title="探索路径"></a>探索路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print_good_address = 成功地址  </span><br><span class="line">simulation.explore(find=print_good_address)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>.explore()</code>方法：找到某条特定的路径，丢弃其他路径</p>
</li>
<li><p>find：参数的内容可以是想要执行到的某个地址、想要执行到的地址列表、或者一个获取state作为参数并判断这个state是否满足某些条件的<strong>函数</strong>。（地址，地址列表，函数）</p>
</li>
<li>当状态和<code>find</code>中的条件匹配的时候，它们就会被放到<code>found stash</code>中，执行随即停止。</li>
</ul>
<h3 id="获取执行结果"><a href="#获取执行结果" class="headerlink" title="获取执行结果"></a>获取执行结果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]  <span class="comment"># 获取通过 explore 找到符合条件的状态</span></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>simgr.found</code>来访问所有符合条件的分支，这里我们为了解题，就选择<strong>第一个符合条件的分支即可</strong>（found[0]）</li>
<li><code>sys.stdin.fileno()</code>：</li>
</ul>
<p>在UNIX中，按照惯例，三个文件描述符分别表示标准输入、标准输出和标准错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdin.fileno() <span class="comment">#标准输入</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.fileno()<span class="comment">#标准输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stderr.fileno()<span class="comment">#标准错误</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>所以可以写为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="题目：00-angr-find"><a href="#题目：00-angr-find" class="headerlink" title="题目：00_angr_find"></a>题目：00_angr_find</h2><p><img src="image-20220224114208823.png" alt="image-20220224114208823"></p>
<p>这里find的目标地址可以是</p>
<p><img src="Angr-0/image-20220224114251592.png" alt="image-20220224114251592"></p>
<p>这里的所有地址，但不能是跳转到这个代码块的地址，因为有可能不会跳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;00_angr_find&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=<span class="number">0x8048675</span>)<span class="comment">#这就是跳转的情况0x8048661-&gt;OUNYWZDT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:<span class="comment">#判定是否找到合适结果</span></span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]<span class="comment">#要第一个</span></span><br><span class="line">    <span class="built_in">print</span>(solution_state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#print(solution_state)，这样的话就会给出simstate走到的地址</span></span><br><span class="line">    <span class="comment">#&lt;SimState @ 0x8048675&gt;</span></span><br><span class="line">    <span class="comment">#print(solution_state.posix)</span></span><br><span class="line">    <span class="comment">#&lt;angr.state_plugins.posix.SimSystemPosix object at 0x7fe76cb5dc70&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>angr 重写了一些 libc 的函数，比如获取 stdin 数据，会返回符号量，用于符号执行</p>
</li>
<li><p>在某个状态下可以使用<code>state1.posix.dumps(0)</code> 获取进入该状态时 stdin 需要输入的数据 </p>
</li>
<li><p>posix 表示终点状态中存储的系统接口信息，然后通过dumps函数来导出系统输入</p>
</li>
</ul>
<h2 id="题目：01-angr-avoid"><a href="#题目：01-angr-avoid" class="headerlink" title="题目：01_angr_avoid"></a>题目：01_angr_avoid</h2><p>注意：不要直接在ida的字符串界面找地址，这时的地址<strong>不一定是text段的地址</strong>，angr跑不出来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./01_angr_avoid&quot;</span>)<span class="comment">#, auto_load_libs = False)</span></span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=<span class="number">0x80485E0</span>, avoid=<span class="number">0x80485F2</span>)</span><br><span class="line"><span class="comment">#avoid参数可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(solution_init.posix.dumps(<span class="number">0</span>))<span class="comment">#显示当时的输入</span></span><br><span class="line">    <span class="built_in">print</span>(solution_init.posix.dumps(<span class="number">1</span>))<span class="comment">#当时的输出（input the passwd：）</span></span><br></pre></td></tr></table></figure>
<p>explore函数的原型，这里只用到<code>find</code> <code>avoid</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">explore</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, find=<span class="literal">None</span>, avoid=<span class="literal">None</span>, find_stash=<span class="string">&#x27;found&#x27;</span>, avoid_stash=<span class="string">&#x27;avoid&#x27;</span>, cfg=<span class="literal">None</span>,um_find=<span class="number">1</span>, **kwargs</span>):</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当一个状态和<code>avoid</code>中的条件匹配时，它就会被放进<code>avoided stash</code>中，之后继续执行。</li>
</ul>
<h2 id="题目：02-angr-find-condition"><a href="#题目：02-angr-find-condition" class="headerlink" title="题目：02_angr_find_condition"></a>题目：02_angr_find_condition</h2><p>ida分析可以看到有多处的成功和提示标语</p>
<p>一般手段没有得到结果，这里采用新的方法，根据回显进行判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./02_angr_find_condition&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsSuccess</span>(<span class="params">state</span>):</span></span><br><span class="line">    std_out = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> std_out:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsFalse</span>(<span class="params">state</span>):</span></span><br><span class="line">    std_out = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> std_out:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find=IsSuccess, avoid=IsFalse)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    init_solution = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(init_solution.posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="动态state"><a href="#动态state" class="headerlink" title="动态state"></a>动态state</h3><p>在原来是判断地址的地方，改成了两个函数的回显</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsSuccess</span>(<span class="params">state</span>):</span></span><br><span class="line">    std_out = state.posix.dumps(<span class="number">1</span>)<span class="comment">#将打印到标准输出的字节对象赋值进行判断</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> std_out:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsFalse</span>(<span class="params">state</span>):</span></span><br><span class="line">    std_out = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> std_out:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>引入一个函数来对状态进行检测，是为了实现<strong>动态的选择想获取的state。</strong></p>
<h2 id="题目：03-angr-symbolic-registers"><a href="#题目：03-angr-symbolic-registers" class="headerlink" title="题目：03_angr_symbolic_registers"></a>题目：03_angr_symbolic_registers</h2><p>这题在于，ida中看到</p>
<p>输入三个十六进制数，然后有三个复杂的函数进行数学运算，最后进行比较得到答案</p>
<p>原来解法：完全可以行得通</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./03_angr_symbolic_registers&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(p.factory.entry_state()).explore(find=<span class="number">0x80489E6</span>, avoid=<span class="number">0x80489D4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">#b9ffd04e ccf63fe8 8fd4d959</span></span><br></pre></td></tr></table></figure>
<p>但是这里因为angr在处理<strong>复杂格式的字符串scanf()输入</strong>的时候不是很好，我们可以直接将符号之注入寄存器，也就是主要<strong>学会符号化寄存器</strong>，先分析函数</p>
<p><img src="image-20220224161855471.png" alt="image-20220224161855471"></p>
<p>看到输入进了这三个寄存器，所以这里直接对他下手</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./03_angr_symbolic_registers&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x8048980</span></span><br><span class="line">init_state = p.factory.blank_state(addr =  start_addr )</span><br><span class="line"><span class="comment">#通过blank_entry函数，让程序直接从指定的地址开始运行</span></span><br><span class="line"></span><br><span class="line">pawd_size = <span class="number">32</span></span><br><span class="line">pawd_0 = claripy.BVS(<span class="string">&#x27;pawd_0&#x27;</span>, pawd_size)</span><br><span class="line">pawd_1 = claripy.BVS(<span class="string">&#x27;pawd_1&#x27;</span>, pawd_size)</span><br><span class="line">pawd_2 = claripy.BVS(<span class="string">&#x27;pawd_2&#x27;</span>, pawd_size)</span><br><span class="line"></span><br><span class="line">init_state.regs.eax = pawd_0</span><br><span class="line">init_state.regs.ebx = pawd_1</span><br><span class="line">init_state.regs.ecx = pawd_2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;Good Job.&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find = issu, avoid = isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="comment">#print(simulation.found[0].posix.dumps(0))#没有回显</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="位向量-bitvector"><a href="#位向量-bitvector" class="headerlink" title="位向量(bitvector)"></a>位向量(bitvector)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pawd_size = <span class="number">32</span><span class="comment">#32位的寄存器，所以时是32位</span></span><br><span class="line">pawd_0 = claripy.BVS(<span class="string">&#x27;pawd_0&#x27;</span>, pawd_size)</span><br><span class="line">pawd_1 = claripy.BVS(<span class="string">&#x27;pawd_1&#x27;</span>, pawd_size)</span><br><span class="line">pawd_2 = claripy.BVS(<span class="string">&#x27;pawd_2&#x27;</span>, pawd_size)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用claripy通过<code>BVS()</code>方法生成三个位向量，此方法有两个参数：第一个是angr用来引用位向量的名称，第二个是位向量本身的大小（以位为单位，好像字节也可以）。</li>
</ul>
<p>1.符号位向量是angr用于将符号值注入程序的<strong>数据类型</strong>。</p>
<p>2.通过 <code>BVV(value,size)</code> 和 <code>BVS( name, size)</code> 接口创建位向量，也可以用 FPV 和 FPS 来创建浮点值和符号</p>
<h3 id="访问寄存器"><a href="#访问寄存器" class="headerlink" title="访问寄存器"></a>访问寄存器</h3><p>1.通过 <code>state.regs</code> 对象的属性访问以及修改寄存器的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = pawd_0</span><br><span class="line">init_state.regs.ebx = pawd_1</span><br><span class="line">init_state.regs.ecx = pawd_2</span><br></pre></td></tr></table></figure>
<p>既修改了<code>initial_state</code>之前创建的内容，并更新寄存器的内容</p>
<p>接下来就是定义explore的参数了</p>
<h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>通过使用<code>state.solver.eval(symbol)</code>对各个断言进行评测来求出一个合法的符号值（若有多个合法值，返回其中的一个）【就是对所选路径的方程进行求解】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">solution0 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd0), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">solution1 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd1), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">solution2 = <span class="built_in">format</span>(solution_state.solver.<span class="built_in">eval</span>(passwd2), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">solution = solution0 + <span class="string">&quot; &quot;</span> + solution1 + <span class="string">&quot; &quot;</span> + solution2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution))</span><br></pre></td></tr></table></figure>
<p>根据给出的方式，可以解出前两个数据，但是解不出第三个数；发现是网上教程的寄存器最后一个设置错误</p>
<p>改正后得到答案</p>
<h2 id="题目：04-angr-symbolic-stack"><a href="#题目：04-angr-symbolic-stack" class="headerlink" title="题目：04_angr_symbolic_stack"></a>题目：04_angr_symbolic_stack</h2><p>先跑简单脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./04_angr_symbolic_stack&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(p.factory.entry_state()).explore(find=<span class="number">0x80486e9</span>, avoid=<span class="number">0x80486d7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>成功得到输入</p>
<h3 id="符号化栈上的值"><a href="#符号化栈上的值" class="headerlink" title="符号化栈上的值"></a>符号化栈上的值</h3><p>看到汇编</p>
<p><img src="image-20220224172716947.png" alt="image-20220224172716947"></p>
<p>这里显然通过栈来把输入传进函数</p>
<p>思路还是</p>
<ul>
<li>跳过输入，直接操作栈</li>
<li>自动求解输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./04_angr_symbolic_stack&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr=<span class="number">0x8048697</span></span><br><span class="line"></span><br><span class="line">init_state = p.factory.blank_state(addr = start_addr)</span><br><span class="line"></span><br><span class="line">init_state.regs.ebp = init_state.regs.esp</span><br><span class="line"></span><br><span class="line">size = <span class="number">32</span></span><br><span class="line">pawd0 = BVS(<span class="string">&#x27;pawd1&#x27;</span>, size)</span><br><span class="line">pawd1 = BVS(<span class="string">&#x27;pawd2&#x27;</span>, size)</span><br><span class="line"></span><br><span class="line">para_size = <span class="number">8</span></span><br><span class="line">init_state.regs.esp -= para_size</span><br><span class="line">init_state.stack_push(pawd0)</span><br><span class="line">init_state.stack_push(pawd1)</span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    s1 = solution_state.solver.<span class="built_in">eval</span>(pawd0)</span><br><span class="line">    s2 = solution_state.solver.<span class="built_in">eval</span>(pawd1)</span><br><span class="line">    <span class="built_in">print</span>(s1,s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.ebp = init_state.regs.esp</span><br><span class="line"><span class="comment">#模拟的是 mov esp, ebp</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">32</span></span><br><span class="line">pawd0 = BVS(<span class="string">&#x27;pawd1&#x27;</span>, size)</span><br><span class="line">pawd1 = BVS(<span class="string">&#x27;pawd2&#x27;</span>, size)</span><br><span class="line"></span><br><span class="line">para_size = <span class="number">8</span></span><br><span class="line">init_state.regs.esp -= para_size</span><br><span class="line"><span class="comment">#sub eap, 8</span></span><br><span class="line"></span><br><span class="line">init_state.stack_push(pawd0)</span><br><span class="line">init_state.stack_push(pawd1)</span><br><span class="line"><span class="comment">#push para1</span></span><br><span class="line"><span class="comment">#push para2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的就是要保证堆栈平衡，模仿的要像才行</p>
<h3 id="关于eval"><a href="#关于eval" class="headerlink" title="关于eval"></a>关于eval</h3><ul>
<li><code>solver.eval(expression)</code> 将会解出一个可行解</li>
<li><code>solver.eval_one(expression)</code>将会给出一个表达式的可行解，若有多个可行解，则抛出异常。</li>
<li><code>solver.eval_upto(expression, n)</code>将会给出最多n个可行解，如果不足n个就给出所有的可行解。</li>
<li><code>solver.eval_exact(expression, n)</code>将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。</li>
<li><code>solver.min(expression)</code>将会给出最小可行解</li>
<li><code>solver.max(expression)</code>将会给出最大可行解</li>
</ul>
<h2 id="题目：05-angr-symbolic-memory"><a href="#题目：05-angr-symbolic-memory" class="headerlink" title="题目：05_angr_symbolic_memory"></a>题目：05_angr_symbolic_memory</h2><p>看到题目，找到find和avoid，简单方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;05_angr_symbolic_memory&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(p.factory.entry_state()).explore(find=<span class="number">0x8048672</span>, avoid=<span class="number">0x8048660</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#b&#x27;NAXTHGNR JVSFTPWE LMGAUHWC XMDCPALU&#x27;</span></span><br></pre></td></tr></table></figure>
<p>符号化内存实际上就是利用angr接口，把值直接写道内存里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;05_angr_symbolic_memory&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x8048601</span></span><br><span class="line">init_state = p.factory.blank_state(addr=start_addr)</span><br><span class="line"><span class="comment">#p.factory.simgr(init_state)</span></span><br><span class="line"></span><br><span class="line">size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">in0 = BVS(<span class="string">&#x27;in0&#x27;</span>, size)</span><br><span class="line">in1 = BVS(<span class="string">&#x27;in1&#x27;</span>, size)</span><br><span class="line">in2 = BVS(<span class="string">&#x27;in2&#x27;</span>, size)</span><br><span class="line">in3 = BVS(<span class="string">&#x27;in3&#x27;</span>, size)</span><br><span class="line"></span><br><span class="line">in0_addr = <span class="number">0xA1BA1C0</span></span><br><span class="line"></span><br><span class="line">init_state.memory.store(in0_addr, in0)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>, in1)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>+<span class="number">8</span>, in2)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span>, in3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">sta</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.\n&#x27;</span> <span class="keyword">in</span> sta.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">sta</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> sta.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"><span class="comment">#这就相当于是开始运行程序了，所以之前一定要配置好环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    s0 = solution_init.solver.<span class="built_in">eval</span>(in0, cast_to=<span class="built_in">bytes</span> )</span><br><span class="line">    s1 = solution_init.solver.<span class="built_in">eval</span>(in1, cast_to=<span class="built_in">bytes</span> )</span><br><span class="line">    s2 = solution_init.solver.<span class="built_in">eval</span>(in2, cast_to=<span class="built_in">bytes</span> )</span><br><span class="line">    s3 = solution_init.solver.<span class="built_in">eval</span>(in3, cast_to=<span class="built_in">bytes</span> )</span><br><span class="line">    <span class="built_in">print</span> (s0,s1,s2,s3)</span><br></pre></td></tr></table></figure>
<p>根据ida分析，这次的输入是存在了64位大小的内存中，所以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">in0_addr = <span class="number">0xA1BA1C0</span></span><br><span class="line"><span class="comment">#内存连续，直接+8</span></span><br><span class="line">init_state.memory.store(in0_addr, in0)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>, in1)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>+<span class="number">8</span>, in2)</span><br><span class="line">init_state.memory.store(in0_addr+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span>, in3)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>state.memory</code> 的 <code>load(addr, size) / store(addr, val)</code> 接口读写内存, size 以 <strong>bytes</strong> 为单位</li>
</ul>
<h2 id="题目：06-angr-symbolic-dynamic-memory"><a href="#题目：06-angr-symbolic-dynamic-memory" class="headerlink" title="题目：06_angr_symbolic_dynamic_memory"></a>题目：06_angr_symbolic_dynamic_memory</h2><p>简单方法得到flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./06_angr_symbolic_dynamic_memory&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line">simulation = p.factory.simgr(p.factory.entry_state()).explore(find=<span class="number">0x804875e</span>, avoid=<span class="number">0x804874c</span>)</span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"><span class="comment">#b&#x27;UBDKLMBV UNOERNYS&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="模拟动态内存"><a href="#模拟动态内存" class="headerlink" title="模拟动态内存"></a>模拟动态内存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./06_angr_symbolic_dynamic_memory&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x8048699</span></span><br><span class="line">init_state = p.factory.blank_state( addr=start_addr )</span><br><span class="line"></span><br><span class="line">size = <span class="number">64</span></span><br><span class="line">in1 = BVS(<span class="string">&#x27;in1&#x27;</span>, size)</span><br><span class="line">in2 = BVS(<span class="string">&#x27;in2&#x27;</span>, size)</span><br><span class="line"></span><br><span class="line">fake_heap1 = <span class="number">0xffffc93c</span><span class="comment">#0x805A039</span></span><br><span class="line">malloc_ptr1 = <span class="number">0xabcc8a4</span></span><br><span class="line"></span><br><span class="line">fake_heap2 = <span class="number">0xffffc94c</span><span class="comment">#0x805A049</span></span><br><span class="line">malloc_ptr2 = <span class="number">0xabcc8ac</span></span><br><span class="line"></span><br><span class="line">init_state.memory.store(malloc_ptr1, fake_heap1, endness=p.arch.memory_endness)</span><br><span class="line">init_state.memory.store(malloc_ptr2, fake_heap2, endness=p.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">init_state.memory.store(fake_heap1, in1)</span><br><span class="line">init_state.memory.store(fake_heap2, in2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):<span class="comment">#因为这里的数字写错了，debug了一晚上，ctmd</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    s1 = solution_init.solver.<span class="built_in">eval</span>(in1, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    s2 = solution_init.solver.<span class="built_in">eval</span>(in2, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(s1,s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析程序，输入存放在一块malloc出来的空间里，所以这块空间的地址是不一定的，但是<strong>angr并没有真正“运行”二进制文件</strong>（至少到目前为止），它只是在<strong>模拟</strong>运行状态，因此它实际上不需要将内存分配到堆中，实际上可以伪造任何地址。</p>
<p>思路：分析汇编，看一下malloc的地址的指针是什么，然后改写这个指针，让她指向指定的空间，因为没有实际运行，所以空间的地址随便，不是会用到的就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size = <span class="number">64</span></span><br><span class="line">in1 = BVS(<span class="string">&#x27;in1&#x27;</span>, size)</span><br><span class="line">in2 = BVS(<span class="string">&#x27;in2&#x27;</span>, size)</span><br><span class="line"></span><br><span class="line">fake_heap1 = <span class="number">0xffffc93c</span></span><br><span class="line">malloc_ptr1 = <span class="number">0xabcc8a4</span></span><br><span class="line"></span><br><span class="line">fake_heap2 = <span class="number">0xffffc94c</span></span><br><span class="line">malloc_ptr2 = <span class="number">0xabcc8ac</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里先改掉指针，注意大小端序，angr默认大端序，最后一个参数默认本机端序</span></span><br><span class="line">init_state.memory.store(malloc_ptr1, fake_heap1, endness=p.arch.memory_endness)</span><br><span class="line">init_state.memory.store(malloc_ptr2, fake_heap2, endness=p.arch.memory_endness)</span><br><span class="line"></span><br><span class="line"><span class="comment">#往指针指向的内存中写入自己的符号</span></span><br><span class="line">init_state.memory.store(fake_heap1, in1)</span><br><span class="line">init_state.memory.store(fake_heap2, in2)</span><br></pre></td></tr></table></figure>
<h3 id="大小端序"><a href="#大小端序" class="headerlink" title="大小端序"></a>大小端序</h3><p>参数 <code>endness</code> 用于设置端序，angr默认为大端序，总共可选的值如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">LE – 小端序(little endian, least significant <span class="keyword">byte </span>is stored <span class="built_in">at</span> lowest <span class="keyword">address)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">BE </span>– 大端序(<span class="keyword">big </span>endian, most significant <span class="keyword">byte </span>is stored <span class="built_in">at</span> lowest <span class="keyword">address)</span></span><br><span class="line"><span class="keyword"></span>ME – 中间序(Middle-endian. Yep.)</span><br></pre></td></tr></table></figure>
<h2 id="题目：07-angr-symbolic-file"><a href="#题目：07-angr-symbolic-file" class="headerlink" title="题目：07_angr_symbolic_file"></a>题目：07_angr_symbolic_file</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./07_angr_symbolic_file&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x80488EA</span></span><br><span class="line">init_state = p.factory.blank_state(addr = start_addr)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;OJKSQYDP.txt&quot;</span></span><br><span class="line">in_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">pawd = BVS(<span class="string">&#x27;pawd&#x27;</span>, in_size)</span><br><span class="line">pawd_file = storage.SimFile(filename, content = pawd, size = in_size, )</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(filename, pawd_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(solution_init.solver.<span class="built_in">eval</span>(pawd, cast_to = <span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<p>分析ida得知，本题是由从文件中读取密码，然后进行判断，这里主要是用angr来模拟文件输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">&quot;OJKSQYDP.txt&quot;</span></span><br><span class="line">in_size = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">pawd = BVS(<span class="string">&#x27;pawd&#x27;</span>, in_size)</span><br><span class="line">pawd_file = storage.SimFile(filename, content = pawd, size = in_size, )</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(filename, pawd_file)</span><br></pre></td></tr></table></figure>
<h3 id="状态插件（state-plugin"><a href="#状态插件（state-plugin" class="headerlink" title="状态插件（state plugin)"></a>状态插件（state plugin)</h3><p>1.所有存储在SimState中的东西实际上都存储在附加在state上的“插件”中。几乎所有<strong>state的属性</strong>都是一个插件——<code>memory</code>、<code>registers</code>、<code>mem</code>、<code>regs</code>、<code>solver</code>等等。</p>
<p>2.例如：memory插件模拟平坦的地址空间。</p>
<p>3.<code>state.memory</code>和<code>state.registers</code>实际上是同一个插件的不同实例，因为寄存器也是用一块地址空间模拟的。</p>
<p>说白了就是在地址模拟的基础上开发出了不同的插件，来简化angr语法</p>
<h3 id="仿真文件系统-The-Emulated-Filesystem"><a href="#仿真文件系统-The-Emulated-Filesystem" class="headerlink" title="仿真文件系统-The Emulated Filesystem"></a>仿真文件系统-The Emulated Filesystem</h3><p>1.angr中与文件系统，套接字，管道或终端的任何交互的根源都是SimFile对象。</p>
<h4 id="SimFile"><a href="#SimFile" class="headerlink" title="SimFile"></a>SimFile</h4><p>1.SimFile是一种存储抽象，定义符号或其他形式的字节序列。</p>
<p>2.可以从某个位置读取文件；在某个位置写入文件；询问文件中当前存储了多少字节；具体化文件，并为其生成测试用例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simgr_file = angr.storage.SimFile(filename, content=xxxxxx, size=file_size)</span><br></pre></td></tr></table></figure>
<p>之后就需要将其传递给init_state，利用<code>fs.insert</code>方法进行插入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">initial_state.fs.insert(filename, simgr_file)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr_1</title>
    <url>/2022/03/02/Angr-1/</url>
    <content><![CDATA[<p> Angr学习，解决路径爆炸问题和一些hook方法：</p>
<span id="more"></span>
<h2 id="题目：08-angr-constraints"><a href="#题目：08-angr-constraints" class="headerlink" title="题目：08_angr_constraints"></a>题目：08_angr_constraints</h2><h3 id="路径爆炸"><a href="#路径爆炸" class="headerlink" title="路径爆炸"></a>路径爆炸</h3><p>1.就是求解过程中，产生了太多了路径，导致求解过程异常缓慢，这通常由带有循环的判断引起的</p>
<p>2.比如说一个32次的for循环进行单字节比较，每一次比较都会产生两个路径，这就是2的32次方的路径，一般电脑无法达到这么大的算力。</p>
<p>3.解决：</p>
<ul>
<li>更换电脑</li>
<li><strong>hook技术</strong></li>
<li><strong>用约束条件取代这个判断函数</strong></li>
</ul>
<h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>angr中提供了可以用加入一个约束条件到一个state中的方法（<code>state.solver.add</code>）；类似于Z3-Solver的solver.add()。</p>
<p><strong>实际是通过 <code>.add</code> 对 state 对象添加约束，并使用 <code>.eval</code> 接口求解，得到符号变量的可行解。</strong></p>
<p>ida分析可得，main函数中存在循环，存在路径爆炸问题</p>
<p><img src="image-20220225155200364.png" alt="image-20220225155200364"></p>
<p>看到下面的if判断里的函数</p>
<p><img src="image-20220225155727402.png" alt="image-20220225155727402"></p>
<p>这里会爆炸，所以需要直接约束求解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./08_angr_constraints&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x8048625</span></span><br><span class="line">init_state = p.factory.blank_state(addr = start_addr)</span><br><span class="line"><span class="comment">#直接从输入之后开始跑</span></span><br><span class="line"></span><br><span class="line">check_addr = <span class="number">0x8048565</span><span class="comment">#判断函数的地址</span></span><br><span class="line">in0_addr = <span class="number">0x804A050</span><span class="comment">#输入的地址</span></span><br><span class="line"></span><br><span class="line">in0len = <span class="number">16</span></span><br><span class="line">in0 = BVS(<span class="string">&#x27;in0&#x27;</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">init_state.memory.store(in0_addr, in0)</span><br><span class="line"><span class="comment">#符号化内存，直接把符号写入内存，避免scanf抽风</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find = check_addr)</span><br><span class="line"><span class="comment">#这里注意，运行到调用check函数的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    para_addr = in0_addr</span><br><span class="line">    para_size = <span class="number">16</span></span><br><span class="line">    para_bitvector = solution_state.memory.load(para_addr, para_size)</span><br><span class="line">	<span class="comment">#使用 state.memory 的 .load(addr, size)接口读出buffer处的内存数据</span></span><br><span class="line">    </span><br><span class="line">    para_cmp_value = <span class="string">&#x27;AUPDNNPROEZRJWKB&#x27;</span></span><br><span class="line">    solution_state.solver.add(para_bitvector == para_cmp_value)</span><br><span class="line">    <span class="comment">#添加条件，读出的数据需要和给定的数据一致，相当是把程序内部判断，转移到外部</span></span><br><span class="line"></span><br><span class="line">    solution = solution_state.solver.<span class="built_in">eval</span>(in0, cast_to = <span class="built_in">bytes</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line">    </span><br><span class="line"><span class="string">b&#x27;LGCRCDGJHYUNGUJB&#x27;</span></span><br></pre></td></tr></table></figure>
<p>关键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   para_addr = in0_addr</span><br><span class="line">   para_size = <span class="number">16</span></span><br><span class="line">   para_bitvector = solution_state.memory.load(para_addr, para_size)</span><br><span class="line"><span class="comment">#使用 state.memory 的 .load(addr, size)接口读出buffer处的内存数据</span></span><br><span class="line">   </span><br><span class="line">   para_cmp_value = <span class="string">&#x27;AUPDNNPROEZRJWKB&#x27;</span></span><br><span class="line">   solution_state.solver.add(para_bitvector == para_cmp_value)</span><br><span class="line">   <span class="comment">#添加条件，读出的数据需要和给定的数据一致，相当是把程序内部判断，转移到外部</span></span><br></pre></td></tr></table></figure>
<p>这里就是把数据读出来，然后通过add添加的约束条件进行比较，最后得到结果，避免程序内部的路劲爆炸</p>
<h2 id="题目：09-angr-hooks"><a href="#题目：09-angr-hooks" class="headerlink" title="题目：09_angr_hooks"></a>题目：09_angr_hooks</h2><p>HOOK技术：通过拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为<strong>钩子</strong>（hook）。</p>
<p>这里就是用自己设计的函数去取代被hook的函数</p>
<p>ida分析，这里取代那个循环判断函数</p>
<h3 id="Hook地址"><a href="#Hook地址" class="headerlink" title="Hook地址"></a>Hook地址</h3><p>1.<code>hook engine</code>来处理hook的情况。默认情况下，angr 会使用 <code>SimProcedures</code> 中的符号摘要替换库函数，即设置 Hooking，这些 python 函数摘要高效地模拟库函数对状态的影响。可以通过 <code>angr.procedures</code>或 <code>angr.SimProcedures</code> 查看列表，具体我没看。</p>
<p>2.<code>SimProcedure</code> 其实就是 Hook 机制，可以通过 <code>proj.hook(addr,hook)</code> 设置</p>
<p> 3.<code>proj.hook(addr)</code> 作为函数装饰器，可以编写自己的 hook 函数。还可以通过 <code>proj.hook_symbol(name,hook)</code> hook 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./09_angr_hooks&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line">check_addr = <span class="number">0x80486B3</span></span><br><span class="line">jmp_len = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@p.hook(<span class="params">check_addr, length=jmp_len</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_checkfunc</span>(<span class="params">state</span>):</span></span><br><span class="line"></span><br><span class="line">    in0_addr = <span class="number">0x804A054</span></span><br><span class="line">    size = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    in0 = state.memory.load(in0_addr, size)</span><br><span class="line">    cmp_str = <span class="string">&#x27;XKSPZSJKJYQCQXZV&#x27;</span></span><br><span class="line"></span><br><span class="line">    register_size = <span class="number">32</span></span><br><span class="line">    state.regs.eax = If(in0 == cmp_str, BVV(<span class="number">1</span>, register_size), BVV(<span class="number">0</span>, register_size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Good Job.\n&#x27;</span> <span class="keyword">in</span> stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Try again.\n&#x27;</span> <span class="keyword">in</span>  stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_init.posix.dumps(<span class="number">0</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment">#ZJOIPFTRNZOXIMLEWUFAOUBLOGLQCCGK</span></span><br></pre></td></tr></table></figure>
<p>设置hook的地方是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_addr = <span class="number">0x80486B3</span></span><br><span class="line"><span class="comment">#这里就是 call 检查函数的地址</span></span><br><span class="line">jmp_len = <span class="number">5</span>，</span><br><span class="line"><span class="comment">#通过16进制可以看到，这哥call指令占据了5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@p.hook(<span class="params">check_addr, length=jmp_len</span>)</span></span><br><span class="line"><span class="comment">#hook的形式，别忘了前面的@</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_checkfunc</span>(<span class="params">state</span>):</span></span><br><span class="line"></span><br><span class="line">    in0_addr = <span class="number">0x804A054</span></span><br><span class="line">    size = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    in0 = state.memory.load(in0_addr, size)</span><br><span class="line">    cmp_str = <span class="string">&#x27;XKSPZSJKJYQCQXZV&#x27;</span></span><br><span class="line"></span><br><span class="line">    register_size = <span class="number">32</span></span><br><span class="line">    state.regs.eax = If(in0 == cmp_str, BVV(<span class="number">1</span>, register_size), BVV(<span class="number">0</span>, register_size))</span><br><span class="line"><span class="comment">#模拟一个函数就是把它视作一个黑盒，能成功模拟输入相对应的输出即可，所以我们需要处理check函数的返回值</span></span><br><span class="line"><span class="comment">#这里就是对eax的一个赋值</span></span><br></pre></td></tr></table></figure>
<h2 id="题目：10-angr-simprocedures"><a href="#题目：10-angr-simprocedures" class="headerlink" title="题目：10_angr_simprocedures"></a>题目：10_angr_simprocedures</h2><p>利用函数名进行hook，而不是复杂的利用函数的调用地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./10_angr_simprocedures&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookCheckFunc</span>(<span class="params">SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, to_check, length</span>):</span></span><br><span class="line">        in_addr = to_check</span><br><span class="line">        in_lenth = length</span><br><span class="line">        in_str = self.state.memory.load(in_addr, in_lenth)</span><br><span class="line"></span><br><span class="line">        check_str = <span class="string">&#x27;ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> claripy.If(in_str == check_str ,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">hook_func_name = <span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line">p.hook_symbol(hook_func_name, HookCheckFunc(init_state))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.\n&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Try again.\n&#x27;</span> <span class="keyword">in</span>  stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"> <span class="string">b&#x27;MSWKNJNAVTTOZMRY&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="HOOK函数名"><a href="#HOOK函数名" class="headerlink" title="HOOK函数名"></a>HOOK函数名</h3><p>这次的核心是根据函数的名字进行hook，当函数被多次调用的时候，通过名字进行hook的效果更好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookCheckFunc</span>(<span class="params">SimProcedure</span>):</span></span><br><span class="line"><span class="comment">#定义一个继承angr.SimProcedure的类，以利用Angr的SimProcedures，这是关键</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, to_check, length</span>):</span></span><br><span class="line">        <span class="comment">#self之后的任何参数都将被视为要替换的函数的参数，和原函数的参数意义保持一致</span></span><br><span class="line">        </span><br><span class="line">        in_addr = to_check</span><br><span class="line">        in_lenth = length</span><br><span class="line">        <span class="comment">#以上是两个参数，长度和字符串的首地址</span></span><br><span class="line">        </span><br><span class="line">        in_str = self.state.memory.load(in_addr, in_lenth)</span><br><span class="line">        <span class="comment">#在SimProcedure中查找系统状态，从该状态的内存中提取出数据</span></span><br><span class="line"></span><br><span class="line">        check_str = <span class="string">&#x27;ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> claripy.If(in_str == check_str ,claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line">		<span class="comment">#如果符合条件则返回输入的符号位向量</span></span><br><span class="line">        </span><br><span class="line">hook_func_name = <span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line">p.hook_symbol(hook_func_name, HookCheckFunc(init_state))</span><br><span class="line"><span class="comment">#设置hook的形式，名字和定义的类，参数是init_state</span></span><br></pre></td></tr></table></figure>
<p>Hook上check_equals函数， angr会<strong>自动查找</strong>与该函数符号关联的地址.</p>
<h2 id="题目：11-angr-sim-scanf"><a href="#题目：11-angr-sim-scanf" class="headerlink" title="题目：11_angr_sim_scanf"></a>题目：11_angr_sim_scanf</h2><p>1.思路同上，找到函数名，定义类，利用<code>hook_symbol()</code>进行hook。</p>
<p>2.为什么要hook这个：scanf对复杂字符串的处理对angr不友好，所以要学会hook她</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./11_angr_sim_scanf&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HookScanf</span>(<span class="params">SimProcedure</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, fmt, in1, in2</span>):</span></span><br><span class="line">        in_1 = BVS(<span class="string">&#x27;in_1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">        in_2 = BVS(<span class="string">&#x27;in_2&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        in1_addr = in1</span><br><span class="line">        in2_addr = in2</span><br><span class="line"></span><br><span class="line">        self.state.memory.store(in1_addr, in_1, endness = p.arch.memory_endness)</span><br><span class="line">        self.state.memory.store(in2_addr, in_2, endness = p.arch.memory_endness)</span><br><span class="line">        <span class="comment">#使用 state.memory 的 .store(addr, val) 接口将符号位向量写入两个字符串，注意不是load；模拟输入，把两个符号写进去</span></span><br><span class="line">        </span><br><span class="line">        self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>] = (in_1, in_2)</span><br><span class="line">        <span class="comment">#设置全局变量，用集合的形式</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">p.hook_symbol(name, HookScanf())<span class="comment">#init_state))</span></span><br><span class="line"><span class="comment">#这里其实加不加参数都行，具体为啥不清楚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good Job.\n&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;Try again.\n&#x27;</span> <span class="keyword">in</span>  stdout_output:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solu_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solu = solu_init.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(solu_init.solver.<span class="built_in">eval</span>(solu[<span class="number">0</span>]))</span><br><span class="line">    <span class="built_in">print</span>(solu_init.solver.<span class="built_in">eval</span>(solu[<span class="number">1</span>]))</span><br><span class="line"> <span class="comment">#这里涉及到两个输入以上的，就用solver，一个输入就用posix.dumps(0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题目：13-angr-static-binary"><a href="#题目：13-angr-static-binary" class="headerlink" title="题目：13_angr_static_binary"></a>题目：13_angr_static_binary</h2><h3 id="Hook静态库函数"><a href="#Hook静态库函数" class="headerlink" title="Hook静态库函数"></a>Hook静态库函数</h3><p>1.学习如何使用angr解出静态编译的题目，学习如何<strong>Hook静态库函数</strong></p>
<ul>
<li><p>动态编译：编译时生成动态链接，程序运行时需要什么找什么</p>
</li>
<li><p>静态编译：编译时把所有模块都编译进文件里，当启动这个可执行文件时，所有模块都被加载进来 </p>
</li>
</ul>
<p>2.一般来说，angr会用SimProcedure来代替标准库函数，但是静态编译的文件没法替换，angr提供了一些hook</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fopen&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fclose&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fwrite&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strncmp&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;exit&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>我们只需要手动找到程序中用到静态函数的地址，将其利用simprocedure提供的函数Hook掉即可</p>
<p>首先来看如果正常写会怎样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./13_angr_static_binary&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state, veritesting=<span class="literal">True</span>).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果就是跑了好久也没有得到答案，因为库函数没有被angr自动hook，导致跑着跑着就到了库函数里面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&#x27;./13_angr_static_binary&#x27;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line">p.hook(<span class="number">0x804ED40</span>, SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">p.hook(<span class="number">0x804ED80</span>, SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">p.hook(<span class="number">0x804f350</span>, SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">p.hook(<span class="number">0x8048D10</span>, SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state, veritesting=<span class="literal">True</span>).explore(find=issu, avoid=isfa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"><span class="string">b&#x27;PNMXNMUD&#x27;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的就是不要忘了函数<code>__libc_start_main</code></p>
<p>复习一下linux里的C程序如何启动的：</p>
<ul>
<li>execve开始执行</li>
<li>execve加载二进制程序，加载<code>.interp</code>指定的动态加载器</li>
<li>动态加载器把需要的so都加载起来，特别是把 libc.so.6 加载</li>
<li>调用到libc.so.6里的<code>__libc_start_main</code>函数，开始真正的执行程序</li>
<li>初始化之后开始main函数的执行</li>
</ul>
<h2 id="题目：14-angr-shared-library"><a href="#题目：14-angr-shared-library" class="headerlink" title="题目：14_angr_shared_library"></a>题目：14_angr_shared_library</h2><p>学习如何使用angr求解函数是外部导入在动态库(.so)里的题目</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>1.把程序按照模块拆分成相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都连接成一个单独的可执行文件。</p>
<p>2.ELF动态链接文件被称为动态共享对象（DSO，Dynamic Shared Object），简称共享对象，它们一般都是.so为扩展名的文件。</p>
<p>3.共享库中的所有地址都是base + offset，其中offset是它们在文件中的偏移地址，和ret2libc一样。</p>
<p>分析题目，看到引用了一个在so文件中的函数，ida中看不到原码，问题在于如何让angr处理这个外部函数</p>
<h3 id="Hook动态库函数"><a href="#Hook动态库函数" class="headerlink" title="Hook动态库函数"></a>Hook动态库函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">base = <span class="number">0x8048000</span></span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./lib14_angr_shared_library.so&quot;</span>, load_options = &#123; <span class="string">&#x27;main_opts&#x27;</span>:&#123;<span class="string">&#x27;custom_base_addr&#x27;</span>:base&#125; &#125;)</span><br><span class="line"></span><br><span class="line">buf_ptr = BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">validate_func_addr = base+<span class="number">0x6d7</span></span><br><span class="line">init_state = p.factory.call_state(validate_func_addr, buf_ptr, BVV(<span class="number">8</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">pawd = BVS(<span class="string">&#x27;pawd&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">init_state.memory.store(buf_ptr, pawd)</span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">su_addr = base+<span class="number">0x783</span></span><br><span class="line">simulation.explore(find=su_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solu_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solu_init.add_constraints(solu_init.regs.eax != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(solu_init.solver.<span class="built_in">eval</span>(pawd, cast_to=<span class="built_in">bytes</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pre-binary-选项"><a href="#pre-binary-选项" class="headerlink" title="pre-binary 选项"></a>pre-binary 选项</h3><p>使用 <code>main_opts</code> 和 <code>lib_opts</code> 参数进行设置。</p>
<ul>
<li><code>backend</code> – 指定 backend</li>
<li><code>base_addr</code> – 指定基址</li>
<li><code>entry_point</code> – 指定入口点</li>
<li><code>arch</code> – 指定架构</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base = <span class="number">0x8048000</span></span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./lib14_angr_shared_library.so&quot;</span>, load_options = &#123; <span class="string">&#x27;main_opts&#x27;</span>:&#123;<span class="string">&#x27;custom_base_addr&#x27;</span>:base&#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>程序本身没有开PIE保护，所以地址可以得到base，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">validate_func_addr = base+<span class="number">0x6d7</span><span class="comment">#通过ida可以看到导出函数的偏移</span></span><br><span class="line"></span><br><span class="line">init_state = p.factory.call_state(validate_func_addr, buf_ptr, BVV(<span class="number">8</span>, <span class="number">32</span>))<span class="comment">#最后是一个长度</span></span><br><span class="line"><span class="comment">#使用.call_state创建 state 对象，构造一个已经准备好执行validate函数的状态，所以我们需要设定好需要传入的参数</span></span><br></pre></td></tr></table></figure>
<p>根据程序中函数的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_BOOL4 __cdecl <span class="title">validate</span><span class="params">(<span class="keyword">char</span> *s1, <span class="keyword">int</span> a2)</span></span></span><br></pre></td></tr></table></figure>
<p>通过 <code>BVV(value,size)</code> 和 <code>BVS( name, size)</code> 接口创建位向量：</p>
<p>先创建一个缓冲区buffer作为参数<code>char *s1</code>，因为设定的缓冲区地址在0x3000000，又因为32位程序里int类型为4字节，即32比特，故得：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buf_ptr = BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure>
<p>用BVS创建一个符号位向量，作为符号化的传入字符串传入我们之前设定好的缓冲区地址中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pawd = BVS(<span class="string">&#x27;pawd&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">init_state.memory.store(buf_ptr, pawd)</span><br></pre></td></tr></table></figure>
<p>最后，让函数执行到返回地址，然后添加约束条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simulation = p.factory.simgr(init_state)</span><br><span class="line"></span><br><span class="line">su_addr = base+<span class="number">0x783</span></span><br><span class="line">simulation.explore(find=su_addr)<span class="comment">#执行到这个函数的返回地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    solu_init = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solu_init.add_constraints(solu_init.regs.eax != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">#添加约束条件</span></span><br><span class="line">    <span class="built_in">print</span>(solu_init.solver.<span class="built_in">eval</span>(pawd, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<h2 id="题目：12-angr-veritesting"><a href="#题目：12-angr-veritesting" class="headerlink" title="题目：12_angr_veritesting"></a>题目：12_angr_veritesting</h2><p>使用<code>Veritesting</code>的技术解决路径爆炸问题</p>
<h3 id="Veritesting"><a href="#Veritesting" class="headerlink" title="Veritesting"></a>Veritesting</h3><ul>
<li>动态符号执行（DSE）：生成路径公式，摘要路径汇合点上两条分支的情况</li>
<li>静态符号执行（SSE）：生成语句公式，为两条分支fork两条<strong>独立的执行路径</strong></li>
</ul>
<p>Veritesting结合了静态符合执行与动态符号执行，减少了路径爆炸的影响。</p>
<p>在angr里我们只要在构造模拟管理器时，启用Veritesting了就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.factory.simgr(init_state, veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>本题的判断在main函数中，没有独立的函数，没有办法直接hookcheck函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> angr <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> claripy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = Project(<span class="string">&quot;./12_angr_veritesting&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issu</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Good&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isfa</span>(<span class="params">state</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;Try&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">simulation = p.factory.simgr(init_state, veritesting=<span class="literal">True</span>).explore(find=issu, avoid=isfa)</span><br><span class="line"><span class="comment">#就直接拓展simgr的参数就行，简单快捷，会出现紫色的log信息，没事</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="built_in">print</span>(simulation.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"><span class="string">b&#x27;OQSUWYACEGIKMOQSUWYACEGIKMOQSUWY&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里如果使用约束求解的话，输入在栈中，并没有一个固定的地址，不好设置符号。</p>
]]></content>
      <categories>
        <category>逆向工程学习</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法</title>
    <url>/2022/01/11/Java%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="了解JAVA"><a href="#了解JAVA" class="headerlink" title="了解JAVA"></a>了解JAVA</h1><span id="more"></span>
<h2 id="JAVA的三种技术架构："><a href="#JAVA的三种技术架构：" class="headerlink" title="JAVA的三种技术架构："></a>JAVA的三种技术架构：</h2><p>JAVA SE: 标准版java，可以开发一般的程序，java语言的标准。</p>
<p>JAVA EE：企业版java，针对web应用程序开发。</p>
<p>JAVA ME：主要用于开发移动程序，被Android取代。</p>
<h2 id="java开发环境："><a href="#java开发环境：" class="headerlink" title="java开发环境："></a>java开发环境：</h2><p>Jre：Java Runtime Environment  Java运行环境</p>
<p>Jvm：Java Virtual Machine java虚拟机，和“核心类库” 组成了jre，jre只能运行java程序，开发java程序的话还需要JDK</p>
<p>JDK：Java Development Kit 开发工具包；<strong>Jdk=开发工具包+jre（jvm+核心类库）</strong></p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>//用<span class="title">class</span>关键字定义一个主类叫 <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="comment">//定义一个主方法，格式固定</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//系统.输出.打印+换行（没有ln就少一个换行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译过程："><a href="#编译过程：" class="headerlink" title="编译过程："></a>编译过程：</h2><p>java代码 ———&gt; javac编译 ———&gt; 机器语言，由jvm来执行生成的class文件</p>
<h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2><p>和c通用的，另加一个“文档注释”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	<span class="doctag">@author</span> 作者</span></span><br><span class="line"><span class="comment">	<span class="doctag">@version</span> 版本 @符号也是可以被解析的</span></span><br><span class="line"><span class="comment">	注释的内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h2><p>变量的定义格式：</p>
<blockquote>
<script type="math/tex; mode=display">
数据类型 变量名 = 初始化值 ;</script></blockquote>
<ul>
<li><p>整数默认int类型，定义long类型的数据时，要在数据<strong>后面</strong>加L。</p>
</li>
<li><p>浮点数默认double类型，定义float类型的数据时，要在数据<strong>后面</strong>加F。</p>
</li>
</ul>
<h3 id="数据类型的转化："><a href="#数据类型的转化：" class="headerlink" title="数据类型的转化："></a>数据类型的转化：</h3><p>1.占内存小的数据可以转化为占内存大的数据。</p>
<p>强制转化与C语言相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>)a;</span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="keyword">int</span> c = (<span class="keyword">int</span>)a+<span class="number">2.72</span>；(报错)</span><br><span class="line"><span class="keyword">int</span> c = (<span class="keyword">int</span>)(a+<span class="number">2.71</span>);（成功）</span><br></pre></td></tr></table></figure>
<h2 id="算数运算："><a href="#算数运算：" class="headerlink" title="算数运算："></a>算数运算：</h2><p><strong>运算符两侧的数据类型要保持一致</strong></p>
<ol>
<li>+：可以连接两个字符串，可以算数，可以算数和连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">System.out.println(a+b+<span class="string">&quot;hello&quot;</span>); <span class="comment">//30hello</span></span><br><span class="line"><span class="comment">//注意区分</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>+a+b); <span class="comment">//hello1020</span></span><br></pre></td></tr></table></figure>
<ol>
<li>可以用自增自减运算符</li>
</ol>
<p>关系运算符的结果是boolean类型；true 或者是 false（<strong>java的bool类型只有true和false</strong>）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&amp;&amp;</th>
<th>\</th>
<th>\</th>
<th></th>
<th>！</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>与C语言一样</p>
<h3 id="三元运算符："><a href="#三元运算符：" class="headerlink" title="三元运算符："></a>三元运算符：</h3><p><strong>表达式1 ? 表达式2 ： 表达式3;</strong></p>
<p>表达式1如果真，就执行表达式2，否则就执行3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">compare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;input two num: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> in1 = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> in2 = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> max = Cmp(in1,in2);</span><br><span class="line">        System.out.println(<span class="string">&quot;较大的是：&quot;</span>+max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&gt;b) ? a:b;					<span class="comment">//这里直接返回二者中较大的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="获得键盘输入："><a href="#获得键盘输入：" class="headerlink" title="获得键盘输入："></a>获得键盘输入：</h1><h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><p>导包———-&gt;创建对象————&gt;接受数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> input = sc.nextlnt();</span><br></pre></td></tr></table></figure>
<h2 id="运用实例："><a href="#运用实例：" class="headerlink" title="运用实例："></a>运用实例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;		<span class="comment">//先导入需要的包，结尾需要分号</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">compare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);		<span class="comment">//new一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;input two num: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> in1 = sc.nextInt();						<span class="comment">//这里进行输入</span></span><br><span class="line">        <span class="keyword">int</span> in2 = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> max = Cmp(in1,in2);</span><br><span class="line">        System.out.println(<span class="string">&quot;较大的是：&quot;</span>+max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a&gt;b) ? a:b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实的输入形式有多种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nextInt();<span class="comment">//这就是输入一个int类型的数</span></span><br><span class="line">nextLine();<span class="comment">//输入一个String类型</span></span><br><span class="line">nextByte();<span class="comment">//byte类型</span></span><br><span class="line">next();<span class="comment">//这个一般配合 next().charAt(0)来当作输入一个char类型使用</span></span><br><span class="line">nextFloat();<span class="comment">//输入一个浮点型</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h1 id="如何用IDEA"><a href="#如何用IDEA" class="headerlink" title="如何用IDEA"></a>如何用IDEA</h1><ul>
<li>点击文件</li>
<li>新建项目（不能像dev一样单文件运行）</li>
<li>选Groovy</li>
<li>下一步</li>
<li>下一步</li>
<li>起项目的名字，选目录</li>
<li>完成之后进入项目</li>
<li><strong>找到“src”文件，在里面新建java类，不要在外面那个.java文件里写，执行不了</strong></li>
<li>写好之后直接shift+f10，可以创建多个文件写，切换的时候要第一次用ctrl+shift+f10，不然会一直运行上一个文件</li>
</ul>
<p>这里在src目录中可以建立多个文件，多个文件中可以包含多个main函数，但是class类的名字在众多文件中最好不要同名，会出bug</p>
<h1 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h1><p>方法又称函数，可以独立运行，和main属于并列关系</p>
<p>定义一个函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">函数修饰符 函数返回值类型 函数名(参数类型 参数名，参数类型 参数名…… )</span><br><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">return</span> 返回值（必须要符合先前的定义）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印水仙花数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">W_F</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span>			<span class="comment">//main函数的参数是规定要这么写，不写会报错</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入一个三位数，打印出里面的所有水仙花数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> max = input.nextInt();</span><br><span class="line">        find(max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e,b,c,d;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(;a&gt;<span class="number">100</span>;a--)</span><br><span class="line">        &#123;</span><br><span class="line">            b = a%<span class="number">10</span>;</span><br><span class="line">            c = a%<span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">            d = a / <span class="number">100</span>;</span><br><span class="line">            p = (d==b)?a:<span class="number">0000</span>;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h1><p>同一个程序中，有多个同名函数，但是他们的参数列表不同，称为函数重载</p>
<h1 id="参数引用："><a href="#参数引用：" class="headerlink" title="参数引用："></a>参数引用：</h1><p>正常传参的话是正常的</p>
<p>在传递数组的时候要注意，引用函数修改数组之后，数组在原函数中也会发生变化（相当于传递了一个指针进去）</p>
<h2 id="运用switch-case："><a href="#运用switch-case：" class="headerlink" title="运用switch case："></a>运用switch case：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.plaf.synth.SynthEditorPaneUI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">56</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">22</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;xia天&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;dong天&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;qiu天&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和c语言基本一样</p>
<h2 id="数组的输入："><a href="#数组的输入：" class="headerlink" title="数组的输入："></a>数组的输入：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">score</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入成绩: &quot;</span>);</span><br><span class="line">        <span class="keyword">float</span>[] score = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];</span><br><span class="line">        edit(score);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;score.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot; got &quot;</span>+score[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Sum(score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">float</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.print(i+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">            a[i] = input.nextFloat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Sum</span><span class="params">(<span class="keyword">float</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总成绩: &quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均成绩: &quot;</span>+sum/i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.print.Printable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arryre</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] are)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//这里注意区分 一些数组的定义形式</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Print(a);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[a.length-<span class="number">1</span>-i];</span><br><span class="line">            a[a.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        Print(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java里面没有像python的index函数一样的数组元素定位的方法，要自己实现一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你要查找的数: &quot;</span>);</span><br><span class="line">        num = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> addr = getIndex(a , num);</span><br><span class="line">        System.out.println(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><p>同时存在 <strong>面向对象</strong>和 <strong>面向过程</strong>两种思维方式，面向：关注的意思</p>
<ul>
<li>面向过程：自己为了解决需求自己所构建的函数。</li>
<li>面向对象：为了解决需要寻找具备某些功能的对象，来构建程序。</li>
</ul>
<p>A:面向过程：强调的是过程，所有事情都需要自己完成</p>
<p>B:面向对象:   面向对象更加符合我们的思考习惯，自己不要那么辛苦，而我们仅仅只需要指挥或者找具备相应功能的对象帮助我们做事即可。</p>
<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><p>类：代码都必须有指定的存放位置，这个位置成为“类”（class）。</p>
<p>用Java中的类描述当前分析的这个事物：事物的名称，就是Java中的类名。</p>
<p>当描述完一个事物之后，要在Java程序中使用这个事物，首先需要使用new 关键字创建出这个事物在Java中的对象，然后通过这个对象就可以调用其中的所有特征。（类似于结构体）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>//定义了一个<span class="title">person</span>类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    String job;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;have food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tperson</span>//定义一个主类，如果不运行的话可以没有<span class="title">main</span>函数</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Person per1 = <span class="keyword">new</span> Person();<span class="comment">//new一个新的对象</span></span><br><span class="line"><span class="comment">//像C语言的结构体一样进行赋值</span></span><br><span class="line">        per1.age = <span class="number">18</span>;</span><br><span class="line">        per1.name = <span class="string">&quot;小王&quot;</span>;</span><br><span class="line">        per1.job = <span class="string">&quot;后勤管理&quot;</span>;</span><br><span class="line">        per1.sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">        <span class="comment">//这样就会调用类中的方法（函数）</span></span><br><span class="line">        per1.sleep();</span><br><span class="line">        per1.eating();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><h4 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h4><p>定义在函数中的变量。</p>
<h4 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h4><p>定义在类的成员位置上的变量，在整个类中都有效的变量(全局变量也是一种成员变量)</p>
<p>成员变量又分为 <strong>实例(对象)变量</strong> 和 <strong>类变量(static静态变量</strong>)。</p>
<p><strong>函数总是优先使用局部变量，从内往外找</strong></p>
<h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h2><h3 id="通过private关键字限制变量的访问权限："><a href="#通过private关键字限制变量的访问权限：" class="headerlink" title="通过private关键字限制变量的访问权限："></a>通过private关键字限制变量的访问权限：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Private</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String job;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//这里用private给他限制住</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editage</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num&gt;<span class="number">0</span> &amp;&amp; num &lt;<span class="number">200</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                age = num;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;fuck you&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//这里就可以对输入进行检查，从而保证age一定是正的</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Printage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;<span class="comment">//因为被限制了，所以打印也要在这个类里面打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teperson</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Private per = <span class="keyword">new</span> Private();</span><br><span class="line">            per.name = <span class="string">&quot;FUCK&quot;</span>;</span><br><span class="line">            per.job = <span class="string">&quot;Mother&quot;</span>;</span><br><span class="line">            per.editage(<span class="number">19</span>);<span class="comment">//间接调用</span></span><br><span class="line">            System.out.println(per.job);</span><br><span class="line">            System.out.println(per.name);</span><br><span class="line">            per.Printage();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="开发中的书写习惯："><a href="#开发中的书写习惯：" class="headerlink" title="开发中的书写习惯："></a>开发中的书写习惯：</h3><p><em>一个类中成员变量全部私有，对外提供getXxxx函数或者setXxxx函数 ， Xxxx表示的成员变量的名字，而成员变量的名字中的第一个字母要大写。</em></p>
<p><em>\1) 在开发中如果在外界想给类中的私有成员变量赋值，那么通过类中的setXxxx函数进行对该成员变量赋值。</em></p>
<p><em>\2) 在开发中如果在外界想使用类中的私有成员变量，那么通过类中的getXxxx函数获得该成员变量。</em></p>
<p><strong>编程习惯是要通过间接的方式对类的内容进行访问</strong></p>
<h2 id="this关键字："><a href="#this关键字：" class="headerlink" title="this关键字："></a>this关键字：</h2><p>方法被哪个对象调用，在方法中就会有一个隐式的变量this记录着调用对象的地址。</p>
<p><strong>当局部变量和成员变量重名时</strong>。使用<strong>this</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">This</span>//定义一个<span class="title">public</span>类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="comment">//都是私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">editName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在类中定义的函数，函数的参数和类的成员变量是重名的，这里使用this关键字来区分成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">editscore</span><span class="params">(<span class="keyword">int</span> score)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (score&gt;<span class="number">0</span> &amp;&amp; score&lt;<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.score = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Testthis</span> // 定义一个新的测试类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arges)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        This per = <span class="keyword">new</span> This();</span><br><span class="line">        <span class="comment">//这里的输入和自定义类其实是一样的，类名 变量 = 在类中new一个</span></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        System.out.print(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">        name = input.nextLine();</span><br><span class="line">        System.out.print(<span class="string">&quot;成绩:&quot;</span>);</span><br><span class="line">        num = input.nextInt();</span><br><span class="line">        per.editName(name);</span><br><span class="line">        per.editscore(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他关键字："><a href="#其他关键字：" class="headerlink" title="其他关键字："></a>其他关键字：</h2><p>public：公开的类或者是变量，所有的类都可以进行使用或者引入（都可以用）</p>
<p>protected：受保护的类，只有子孙类和本类可以引入使用（同包或者同类）。这也是默认的类，如果class前面什么也不加就默认是protected。</p>
<p>private：只有在本类中才可以使用（同类）</p>
<p>public void 修饰是非静态方法，<strong>该类方法属于对象</strong>，在对象初始化（new Object()）后才能被调用；</p>
<p>public static void 修饰是<strong>静态方法，属于类，使用类名.方法名直接调用</strong>。</p>
<h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><p>是什么：在创建对象时会自动调用的函数</p>
<p>使用new关键字创建对象，创建完之后，就会调用当前这个类的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Class()<span class="comment">//就是说以无参数构造方法实例化对象。</span></span><br></pre></td></tr></table></figure>
<h3 id="与一般函数的区别："><a href="#与一般函数的区别：" class="headerlink" title="与一般函数的区别："></a>与一般函数的区别：</h3><p><strong>一般函数的定义格式：</strong></p>
<p>修饰符 返回值类型 函数名（参数列表）</p>
<p>{</p>
<p>}</p>
<p><strong>构造函数（方法）格式：</strong>没有返回值类型，他也不需要</p>
<p>修饰符 构造函数名（ 参数列表 ）</p>
<p>{</p>
<p>}</p>
<p><strong><em>构造函数的名字要求必须和当前的类名一致</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EditAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EditName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stu (String name, <span class="keyword">int</span> age)<span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">build_func</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = input.nextLine();</span><br><span class="line">        <span class="keyword">int</span> num = input.nextInt();</span><br><span class="line">        Stu stu1 = <span class="keyword">new</span> Stu(name , num);<span class="comment">//在new对象的时候直接就进行初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试构造函数&quot;</span>);</span><br><span class="line">        stu1.EditAge();</span><br><span class="line">        stu1.EditName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是自己写出来构造函数，如果没有的话就是默认构造函数，java经过javac编译之后会自动添加一个没有参数的构造函数。</p>
<p>根据不同的需要可以在类中同时写有参数的和没有参数的构造函数，他们以 <strong>重载</strong>的形式存在于类中。在new的时候根据参数的不同选择构造函数。</p>
<p>构造函数和一般函数对比</p>
<ul>
<li><p>构造函数当对象创建完成了，函数也执行完成了。</p>
</li>
<li><p>构造函数只有在new对象的时候，会被调用，一旦对象创建完成，我们不能手动的人为去调用构造函数。</p>
</li>
<li>构造函数可以调用一般函数，反之不行</li>
</ul>
<h3 id="构造函数的相互调用："><a href="#构造函数的相互调用：" class="headerlink" title="构造函数的相互调用："></a>构造函数的相互调用：</h3><p>用this关键字，不能通过函数名调用构造函数</p>
<ol>
<li><p><strong>构造函数不能相互嵌套调用，不然会导致程序选入死循环</strong></p>
</li>
<li><p><strong>this调用构造函数，必须放在构造函数的第一句</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    student()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    student(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是1参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    student(String name , <span class="keyword">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;lala&quot;</span>);        <span class="comment">//这里通过this用了一参数的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        score = num;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是2参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; 考了: &quot;</span>+score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">buildFunc2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arge)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        student stu = <span class="keyword">new</span> student(<span class="string">&quot;陈润基&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        stu.showinfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这里不把this的调用放在第一行，那么这里就会报错说</p>
<blockquote>
<p>对this的调用必须是构造器中的第一个语句</p>
</blockquote>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><p>API：application programming interface。应用程序接口。</p>
<h2 id="Scanner类-与-String类："><a href="#Scanner类-与-String类：" class="headerlink" title="Scanner类 与 String类："></a>Scanner类 与 String类：</h2><h3 id="scanner："><a href="#scanner：" class="headerlink" title="scanner："></a>scanner：</h3><p>相当于时scanf函数用来接受外部输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = input.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string类："><a href="#string类：" class="headerlink" title="string类："></a>string类：</h3><p>Java中的所有常量：整数、小数、字符、字符串、null、真假值true false </p>
<p>由此可知，String类型不是java的基本数据类型，属于是引用类型，也成为 <strong>类类型</strong></p>
<p><strong>它不是存储在堆空间中，而是存储在方法区中的字符串常量池中</strong>。字符串常量池中保存的就是所有的字符串数据。只要我们书写了双引号，不管双引号中间是什么数据，这些数据都会立刻在字符串常量池中保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String a = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        String b = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用String类的构造函数创建的对象，那么这个对象就会在堆中出现。</strong>而在创建出的字符串对象中的字符数据保存在常量池中。</p>
<h3 id="使用String类的默认构造函数"><a href="#使用String类的默认构造函数" class="headerlink" title="使用String类的默认构造函数:"></a>使用String类的默认构造函数:</h3><h4 id="byte类型："><a href="#byte类型：" class="headerlink" title="byte类型："></a>byte类型：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">byte2string</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>,<span class="number">97</span>,<span class="number">99</span>,<span class="number">121</span>&#125;;</span><br><span class="line">        String s = <span class="keyword">new</span> String(b);</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(b,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//数组，从0开始，往后数3个</span></span><br><span class="line">        System.out.println(s);<span class="comment">//ABCDacy</span></span><br><span class="line">        System.out.println(s1);<span class="comment">//ABC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符数组类型："><a href="#字符数组类型：" class="headerlink" title="字符数组类型："></a>字符数组类型：</h4><p>将数组转换成string类型的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Char2string</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[]  c = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] i = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="keyword">new</span> String(c);</span><br><span class="line">        String s1 = <span class="keyword">new</span> String(i,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s1);<span class="comment">//这里还是进行一个ascii的转化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String类的运算操作："><a href="#String类的运算操作：" class="headerlink" title="String类的运算操作："></a>String类的运算操作：</h3><h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str)</span><span class="comment">//比较字符串的内容是否相同,忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span>		<span class="comment">//判断字符串对象是否以指定的str开头</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span>		<span class="comment">//判断字符串对象是否以指定的str结尾</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>这里不能用<code>==</code>来进行String类型的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>					<span class="comment">//获取字符串的长度，其实也就是字符个数</span></span></span><br><span class="line"><span class="function"> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>		<span class="comment">//获取指定索引处的字符</span></span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>		<span class="comment">//获取str在字符串对象中第一次出现的索引</span></span></span><br><span class="line"><span class="function"> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start)</span>	<span class="comment">//从start索引开始截取字符串，截取到字符串最后</span></span></span><br><span class="line"><span class="function"> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><span class="comment">//从start开始，到end结束截取字符串。包括start，不</span></span></span><br></pre></td></tr></table></figure>
<h4 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] toCharArray()<span class="comment">//把字符串转换为字符数组，相当于list了</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span><span class="comment">//把字符串中的所有大写字母转换为小写字母</span></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span><span class="comment">//把字符串中的小写字母转换为大写字母</span></span></span><br></pre></td></tr></table></figure>
<h4 id="切割方法："><a href="#切割方法：" class="headerlink" title="切割方法："></a>切割方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span><span class="comment">//去除字符串两头的空格</span></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String str)</span><span class="comment">//按照给定字符串进行分割</span></span></span><br></pre></td></tr></table></figure>
<h3 id="字符串缓冲区："><a href="#字符串缓冲区：" class="headerlink" title="字符串缓冲区："></a>字符串缓冲区：</h3><p>Java中提供2个字符串缓冲区StringBuffer和StringBuilder。</p>
<h2 id="集合的概念"><a href="#集合的概念" class="headerlink" title="集合的概念"></a>集合的概念</h2><h3 id="引出："><a href="#引出：" class="headerlink" title="引出："></a>引出：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stud</span><span class="params">(String name, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span><span class="comment">//构造函数必须和类同名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stud[] arr = <span class="keyword">new</span> Stud[<span class="number">3</span>];</span><br><span class="line">        Stud stu1 = <span class="keyword">new</span> Stud(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span> , <span class="number">66</span>);</span><br><span class="line">        Stud stu2 = <span class="keyword">new</span> Stud(<span class="string">&quot;小张&quot;</span>, <span class="number">19</span> , <span class="number">88</span>);</span><br><span class="line">        Stud stu3 = <span class="keyword">new</span> Stud(<span class="string">&quot;小王&quot;</span>, <span class="number">21</span> , <span class="number">99</span>);</span><br><span class="line">        arr[<span class="number">0</span>] = stu1;</span><br><span class="line">        arr[<span class="number">1</span>] = stu2;</span><br><span class="line">        arr[<span class="number">2</span>] = stu3;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i].name+<span class="string">&#x27; &#x27;</span>+arr[i].age+<span class="string">&#x27; &#x27;</span>+arr[i].score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，因为我在同一个src目录下创建的，然后后来应该是定义类的时候和前面的哪一个重名了，一直报错，把类名改一下就可以了</p>
<p>这里定义一个数组的方法</p>
<p>如果使用数组存储int类型的数据：int[] arr=new int[3];</p>
<p> 如果使用数组存储String类型的数据：String[] arr=new String[3];</p>
<p> <strong>如果使用数组存储Student类型的数据：Student[] arr=new Student[3];</strong></p>
<p>和结构体里面定义数组差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stud</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stud</span><span class="params">(String name, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span><span class="comment">//构造函数必须和类同名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> len = input.nextInt();</span><br><span class="line">        String name;</span><br><span class="line">        String bin;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String[] nm = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;;</span><br><span class="line">        Stud[] arr = <span class="keyword">new</span> Stud[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;score: &quot;</span>);</span><br><span class="line">            score = input.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span>);</span><br><span class="line">            bin = input.nextLine();<span class="comment">//这里先把回车过滤过去，不然name就成回车了</span></span><br><span class="line">            name = input.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;age: &quot;</span>);</span><br><span class="line">            age = input.nextInt();</span><br><span class="line">            arr[i] = <span class="keyword">new</span> Stud(name, score , age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i].name+<span class="string">&#x27; &#x27;</span>+arr[i].age+<span class="string">&#x27; &#x27;</span>+arr[i].score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序要注意的就是那个字符串name的输入函数，先用一个输入过滤掉回车</p>
<h3 id="集合：一种存放对象的容器"><a href="#集合：一种存放对象的容器" class="headerlink" title="集合：一种存放对象的容器"></a>集合：一种存放对象的容器</h3><p>集合的概念：一种存放对象的容器，需要使用对象的事后，把对象取出来，再去使用，方便快捷</p>
<p>集合和数组的区别：</p>
<ul>
<li><p>数组是固定长度，集合长度可变</p>
</li>
<li><p>数组可以存储基本类型数据和引用类型数据（String类型和上面定义的Stud类型），集合只能存储引用类型的数据</p>
</li>
<li><p>数组的数据都是类型相同的，集合允许元素的类型不同</p>
</li>
</ul>
<h3 id="ArrayList集合："><a href="#ArrayList集合：" class="headerlink" title="ArrayList集合："></a>ArrayList集合：</h3><p>她的底层就是大小可变的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">//引入ArratList包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//创建一个集合对象</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;test end&quot;</span>);</span><br><span class="line">        list.add(<span class="number">2</span>, <span class="string">&quot;android&quot;</span>);<span class="comment">//如果不指定位置就从头往后插入</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(list);   <span class="comment">//[hello,  world, android, test end]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="增添删改："><a href="#增添删改：" class="headerlink" title="增添删改："></a><strong>增添删改</strong>：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入集合的元素个数&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        String str;</span><br><span class="line">        String bin;</span><br><span class="line">        bin = input.nextLine();</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str = input.nextLine();</span><br><span class="line"><span class="comment">//            str = (String)(char)i;</span></span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;刚刚输入的是&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));<span class="comment">//可以通过get的形式类遍历整个集合</span></span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        list.remove(<span class="number">2</span>);<span class="comment">//删除第二位之后，后面的会向前进一位</span></span><br><span class="line">        list.set(<span class="number">2</span>, <span class="string">&quot;99&quot;</span>);<span class="comment">//注意这里修改的事后要类型合适</span></span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(list.size());<span class="comment">//size返回集合元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="增强for循环："><a href="#增强for循环：" class="headerlink" title="增强for循环："></a>增强for循环：</h4><p>这是看idea下面的提示才知道还有这么一回事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj : list) <span class="comment">//使用增强for循环遍历集合</span></span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(obj);<span class="comment">//取出并打印集合中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个东西就像是python里的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    <span class="built_in">print</span> i</span><br></pre></td></tr></table></figure>
<p>一样，不用再用get方法在集合里取值了，但是这里只能访问，不能修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    String title;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String title, String author, <span class="keyword">int</span> price)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfClassArray</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ArrayList&lt;Book&gt; book = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)<span class="comment">//不能直接while 1，因为她的bool类型只有true和false</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;输入 &#x27;#&#x27; 退出: &quot;</span>);</span><br><span class="line">            op = input.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PrintBook(book);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                addBook(book);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintBook</span><span class="params">(ArrayList&lt;Book&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下面是您输入保存的书目录：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;作者  书名  价格&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Book elm :list)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(elm.author+<span class="string">&quot;: &quot;</span>+elm.title+<span class="string">&quot; --&gt; &quot;</span>+elm.price+<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        &#125;           <span class="comment">//这里使用了加强版for循环</span></span><br><span class="line">    &#125;<span class="comment">//这里打印不能只println(elm)，每一个元素都相当于一个对象，这里的要打印出对象中的数据，否则会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(ArrayList&lt;Book&gt; list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;书名：&quot;</span>);</span><br><span class="line">        String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;作者：&quot;</span>);</span><br><span class="line">        String author = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;价格：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> price = input.nextInt();</span><br><span class="line"></span><br><span class="line">        Book temp = <span class="keyword">new</span> Book(name, author, price);</span><br><span class="line">        list.add(temp);<span class="comment">//这list里面都是一个个的对象</span></span><br><span class="line">        <span class="comment">//每个对象对应这自己的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序用了ArrayList将自定义的对象进行复制并且在退出之前进行遍历</p>
<h1 id="学生管理系统-java"><a href="#学生管理系统-java" class="headerlink" title="学生管理系统-java"></a>学生管理系统-java</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查看所有的学生信息，可以增加，修改，删除学生信息，学生信息包括学号，姓名，年龄，籍贯*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allstu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String addr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String stuid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">allstu</span><span class="params">(String name, String addr, String stuid, <span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addr = addr;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.stuid = stuid;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showname</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(name+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(addr+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(stuid+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.print(age+<span class="string">&quot;  。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">studentManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ArrayList&lt;allstu&gt; stu_list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Printalbe();</span><br><span class="line">            <span class="keyword">int</span> op = input.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (op)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    showInfo(stu_list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;要删除哪一个: &quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> index = input.nextInt();</span><br><span class="line">                    rmInfo(stu_list, index-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    addInfo(stu_list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;要修改哪一个: &quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> index1 = input.nextInt();</span><br><span class="line">                    setInfo(stu_list, index1-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;感谢使用&quot;</span>);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Printalbe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------欢迎来到学生管理系统--------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 查看所有&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 删除&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 增加&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 修改&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 退出&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;选择: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInfo</span><span class="params">(ArrayList&lt;allstu&gt; stu)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名: &quot;</span>);</span><br><span class="line">        String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;地址: &quot;</span>);</span><br><span class="line">        String addr = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;学号: &quot;</span>);</span><br><span class="line">        String id = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;年龄: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = input.nextInt();</span><br><span class="line"></span><br><span class="line">        allstu temp = <span class="keyword">new</span> allstu(name ,addr, id, age);</span><br><span class="line">        stu.add(temp);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(ArrayList&lt;allstu&gt; stu , <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        allstu temp = stu.get(index);</span><br><span class="line"></span><br><span class="line">        temp.showname();</span><br><span class="line">        temp.showid();</span><br><span class="line">        temp.showaddr();</span><br><span class="line">        temp.showage();</span><br><span class="line"></span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名: &quot;</span>);</span><br><span class="line">        String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;地址: &quot;</span>);</span><br><span class="line">        String addr = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;学号: &quot;</span>);</span><br><span class="line">        String id = input.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;年龄: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = input.nextInt();</span><br><span class="line"></span><br><span class="line">        allstu new_stu = <span class="keyword">new</span> allstu(name ,addr, id, age);</span><br><span class="line"></span><br><span class="line">        stu.set(index , new_stu);					<span class="comment">//这里直接就在原来的位置修改了，没有新增</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rmInfo</span><span class="params">(ArrayList&lt;allstu&gt; stu, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stu.remove(index);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">(ArrayList&lt;allstu&gt; stu)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stu.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(allstu pre : stu)</span><br><span class="line">            &#123;</span><br><span class="line">                pre.showname();</span><br><span class="line">                pre.showid();</span><br><span class="line">                pre.showage();</span><br><span class="line">                pre.showaddr();</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程初探-了解win编程</title>
    <url>/2022/02/22/Windows%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p> 在逆向一些软件的时候，会涉及到Windows编程以及API的一些知识，以此初探windows编程</p>
<span id="more"></span>
<h1 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h1><p>1.编写Windows程序，需要<windows.h>头文件，这个文件包括了四个文件</p>
<ul>
<li>windef.h：基本类型定义</li>
<li>winbase.h：内核函数</li>
<li>wingdi.h：用户接口函数</li>
<li>winuser.h： 图形设备接口函数</li>
</ul>
<p>所有的API都在这些头文件中声明</p>
<p>2.程序入口</p>
<p>控制台程序（console）程序的入口是<strong>main函数</strong>；GUI程序的入口是<strong>WinMain()</strong>（动态链接库(DLL)以 DllMain() 为入口函数）</p>
<p><strong>WinMain函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,  <span class="comment">// 当前窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,  <span class="comment">// 前一个窗口句柄，Win32下为NULL（Win16留下的废物，目前已弃用）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,  <span class="comment">// 命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCmdShow  	  <span class="comment">// 窗口显示方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>句柄：用来告诉程序去哪里寻找需要的数据（不是指针）</p>
<p>3.第一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用API 函数MessageBox</span></span><br><span class="line">    <span class="keyword">int</span> nSelect = MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Hello World\n烫&quot;</span>), TEXT(<span class="string">&quot;first GUI&quot;</span>), MB_OKCANCEL);</span><br><span class="line">    <span class="keyword">if</span> (nSelect == IDOK) </span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;你点击了“确定”按钮&quot;</span>), TEXT(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;你点击了“取消”按钮&quot;</span>), TEXT(<span class="string">&quot;提示&quot;</span>), MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageBox() 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MessageBox</span><span class="params">( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType )</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以知道，该api的返回值是int类型，代表了一个按钮消息</p>
<ul>
<li>hWnd：该消息框的父窗口句柄，如果此参数为NULL，则该消息框没有拥有父窗口。</li>
<li><strong>lpText：消息框的内容。LPCTSTR 是自定义数据类型，等价于 const char *。</strong></li>
<li><strong>lpCaption：消息框的标题。</strong></li>
<li><strong>uType：对话框的按钮样式和图标。</strong></li>
</ul>
<p>4.按钮的类型</p>
<p>微软给出了几种默认的按钮类型（MB_按钮的作用）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>按钮</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0：MB_OK</td>
<td><strong>默认值</strong>，有一个“确认”按钮在里面</td>
</tr>
<tr>
<td>1：MB_YESNO</td>
<td>有“是”和“否”两个按钮</td>
</tr>
<tr>
<td>2：MB_ABORTRETRYIGNORE</td>
<td>有“中止”，“重试”和“跳过”三个按钮</td>
</tr>
<tr>
<td>3：MB_YESNOCANCEL</td>
<td>有“是”，“否”和“取消”三个按钮</td>
</tr>
<tr>
<td>4：MB_RETRYCANCEL</td>
<td>有“重试”和“取消”两个按钮</td>
</tr>
<tr>
<td>5：MB_OKCANCEL</td>
<td>有“确定”和“取消”两个按钮</td>
</tr>
</tbody>
</table>
</div>
<p>uType 还图标（图标对用户有提醒作用）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图标</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>MB_ICONEXCLAMATION</td>
<td>一个惊叹号出现在消息框：<img src="1-14110Q0425B47.png" alt="img"></td>
</tr>
<tr>
<td>MB_ICONWARNING</td>
<td>一个惊叹号出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONINFORMATION</td>
<td>一个圆圈中小写字母i组成的图标出现在消息框：<img src="1-14110Q0431R22.png" alt="img"></td>
</tr>
<tr>
<td>MB_ICONASTERISK</td>
<td>一个圆圈中小写字母i组成的图标出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONQUESTION</td>
<td>一个问题标记图标出现在消息框：<img src="1-14110Q043302b.png" alt="img"></td>
</tr>
<tr>
<td>MB_ICONSTOP</td>
<td>一个停止消息图标出现在消息框：<img src="1-14110Q04345J6.png" alt="img"></td>
</tr>
<tr>
<td>MB_ICONERROR</td>
<td>一个停止消息图标出现在消息框（同上）</td>
</tr>
<tr>
<td>MB_ICONHAND</td>
<td>一个停止消息图标出现在消息框（同上）</td>
</tr>
</tbody>
</table>
</div>
<p>图标和按钮混合使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> nSelect = MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;Hello World\nlallalalallalalalla烫&quot;</span>), TEXT(<span class="string">&quot;first GUI&quot;</span>), MB_OKCANCEL|MB_ICONEXCLAMATION);</span><br><span class="line"><span class="comment">//用一个 | 符号</span></span><br></pre></td></tr></table></figure>
<p>5.注意，messagebox虽然返回数字，但是被定义为宏，所以可以使用数字或者宏名称</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDOK</td>
<td>用户按下了“确认”按钮</td>
</tr>
<tr>
<td>IDCANCEL</td>
<td>用户按下了“取消”按钮</td>
</tr>
<tr>
<td>IDABORT</td>
<td>用户按下了“中止”按钮</td>
</tr>
<tr>
<td>IDRETRY</td>
<td>用户按下了“重试”按钮</td>
</tr>
<tr>
<td>IDIGNORE</td>
<td>用户按下了“忽略”按钮</td>
</tr>
<tr>
<td>IDYES</td>
<td>用户按下了“是”按钮</td>
</tr>
<tr>
<td>IDNO</td>
<td>用户按下了“否”按钮</td>
</tr>
</tbody>
</table>
</div>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1.Windows使用<code>typedef</code>或<code>#define</code>定了很多新的数据类型，但是大多数都是基本数据类型的新名字，这样作可以提高兼容性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>                 INT;       <span class="comment">/* 整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        UINT;      <span class="comment">/* 无符号整形 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>        *PUINT;    <span class="comment">/* 无符号整形指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>                 BOOL;      <span class="comment">/* 布尔类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>       BYTE;      <span class="comment">/* 字节 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span>      WORD;      <span class="comment">/* WORD (无符号短整型) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>       DWORD;     <span class="comment">/* DOUBLE WORD (无符号长整形)*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>               FLOAT;     <span class="comment">/* 浮点型 */</span></span><br><span class="line"><span class="keyword">typedef</span> FLOAT               *PFLOAT;   <span class="comment">/* 指向float类型指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BOOL near           *PBOOL;    <span class="comment">/* 指向布尔类型指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BOOL far            *LPBOOL;</span><br><span class="line"><span class="keyword">typedef</span> BYTE near           *PBYTE;    <span class="comment">/* 指向字节类型指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> BYTE far            *LPBYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> near            *PINT;     <span class="comment">/* 整形指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> far             *LPINT;</span><br><span class="line"><span class="keyword">typedef</span> WORD near           *PWORD;    <span class="comment">/* 指向WORD类型的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> WORD far            *LPWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> far            *LPLONG;   <span class="comment">/* 指向长整形的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> DWORD near          *PDWORD;   <span class="comment">/* 指向DWORD类型的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> DWORD far           *LPDWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> far            *LPVOID;   <span class="comment">/* 指向void类型的指针 */</span></span><br><span class="line"><span class="keyword">typedef</span> CONST <span class="keyword">void</span> far      *LPCVOID;  <span class="comment">/* 指向void类型的常指针 */</span></span><br></pre></td></tr></table></figure>
<p>可以总结一下规律就是</p>
<ul>
<li>无符号类型：一般是以“U”开头，比如“INT”对应的“UINT”。</li>
<li>指针类型：其指向的数据类型前加“LP”或“P”，比如指向 DWORD 的指针类为“LPDWORD”和“PDWORD”。</li>
<li>句柄类型：以“H”开头。比如，HWND 是window（WND简写）也就是窗口的句柄，菜单(MENU)类型对应的句柄类型为 “HMENU” 等等。</li>
</ul>
<p>2.宽字节和unicode</p>
<p>unicode是宽字节编码的一种，需要用<strong>多个字节来表示的代码称为宽字符</strong></p>
<p>2.1 使用宽字符</p>
<p>使用<code>wchar.h</code>头文件中的<code>wchar_t</code>来定义宽字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> wch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;C语言中文网&quot;</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> wstr[] = <span class="string">L&quot;C语言中文网&quot;</span>; <span class="comment">//L是前缀，告诉编译器这是两字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch=%d, wch=%d, str=%d, wstr=%d\n&quot;</span>, </span><br><span class="line">           <span class="keyword">sizeof</span>(ch), <span class="keyword">sizeof</span>(wch), <span class="keyword">sizeof</span>(str), <span class="keyword">sizeof</span>(wstr));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：ch=1, wch=2, str=12, wstr=14</p>
<p>wstr 之所以比 str 多两个字节是因为：字符 ‘C’ 占用两个字节，字符串结束标志 ‘\0’ 也占用两个字节。</p>
<p>2.2 计算ASCII字符串长度使用 strlen 函数，计算宽字符串长度使用 wcslen 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;Hello API&quot;</span>;</span><br><span class="line">    <span class="keyword">wchar_t</span> wstr[] = <span class="string">L&quot;Hello API&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strlen(str)=%d, wcslen(wstr)=%d\n&quot;</span>, <span class="built_in">strlen</span>(str), wcslen(wstr));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strlen函数将一字节算作是一个字符，wcslen将两个字节算成一个字符</p>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p>窗口、控件、图像、音频视频等都称为<strong>资源(Resource)</strong>，在程序中都可以使用、创建、添加、修改等。</p>
<h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><p>不同窗口、控件、图像等都对应一个唯一的数字（初学者可以理解为 ID），称为句柄(Handle)。</p>
<p>通过句柄，程序可以找对对应的信息。例如：例如用 <code>CreateFile()</code> 函数创建文件后会返回一个文件句柄，然后通过这个句柄就可以读写、删除该文件.</p>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>1.事件：用户敲击键盘、点击鼠标、拖动窗口、选择菜单、输入文字等所有的操作都称为事件(Event)。</p>
<p>2.当事件发生时，windows会产生一条<strong>信息</strong>，告诉程序发生了什么。</p>
<p>3.每当事件发生时，Windows 会生成一条消息，并放到一个由<strong>系统维护的队列中</strong>。然后，<strong>程序会自己从这个队列中获取消息并分析</strong>，调用事件处理函数（处理事件的代码也就在这个函数中），对用户的操作进行响应。</p>
<p>4.队列：先进先出的数据结构</p>
<p><strong><em>注意：Windows 向队列中分派消息和应用程序从队列中获取消息并不是同步的，只要有事件发生，就会将消息丢进队列，什么时候处理完毕是应用程序的事。</em></strong></p>
<p>总结：消息是windows连接程序的桥梁，Windows通过 <strong>消息</strong> 告诉程序发生了什么，应用程序通过 <strong>消息</strong> 来办事。</p>
<h3 id="消息结构体"><a href="#消息结构体" class="headerlink" title="消息结构体"></a>消息结构体</h3><p>消息其实是一个结构体，名字为 MSG，定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HWND hwnd;	<span class="comment">//消息所属窗口</span></span><br><span class="line">    UINT message;	<span class="comment">//消息类型（数值）</span></span><br><span class="line">    WPARAM wParam;	<span class="comment">//同下</span></span><br><span class="line">    LPARAM lParam;	<span class="comment">//表示的信息随消息的不同而不同。</span></span><br><span class="line">    DWORD time;	<span class="comment">//消息投递到消息队列中的时间</span></span><br><span class="line">    POINT pt;	<span class="comment">//鼠标当前位置</span></span><br><span class="line">&#125; MSG;</span><br></pre></td></tr></table></figure>
<p>Windows 向队列中投递消息，其实就是将一个<strong>类型为 MSG 的结构体变量</strong>丢进队列。</p>
<p>1.message：因为数值不好记忆，所有Windows<strong>将消息对应的数值定义为WM_XXX宏</strong>（WM是Window Message的缩写）的形式。例如：鼠标左键按下消息是WM_LBUTTONDOWN；键盘按下消息WM_KEYDOWN；字符消息是WM_CHA。在程序中我们通常都是以WM_XXX宏的形式来使用消息的。</p>
<h1 id="MSG结构体和WndProc窗口过程详解"><a href="#MSG结构体和WndProc窗口过程详解" class="headerlink" title="MSG结构体和WndProc窗口过程详解"></a>MSG结构体和WndProc窗口过程详解</h1><h2 id="MSG结构体"><a href="#MSG结构体" class="headerlink" title="MSG结构体"></a>MSG结构体</h2><p>MSG 结构体用来表示一条消息，各个字段的含义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMSG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HWND hwnd;  <span class="comment">//窗口句柄</span></span><br><span class="line">    UINT message;  <span class="comment">//消息类型，例如 WM_CREATE、WM_PAINT、WM_DESTROY、WM_COMMAND 等。</span></span><br><span class="line">    WPARAM wParam;  <span class="comment">//附加消息1</span></span><br><span class="line">    LPARAM lParam;  <span class="comment">//附加消息2，他们的类型表示32位整数</span></span><br><span class="line">    DWORD time;  <span class="comment">//消息被传递时候的时间</span></span><br><span class="line">    POINT  pt;  <span class="comment">//消息被传递时光标在屏幕上的位置</span></span><br><span class="line">&#125; MSG;</span><br></pre></td></tr></table></figure>
<p>1.wParam 和 lParam ：wParam、lParam 表示的信息随消息类型的不同而不同。</p>
<p>2.一般约定，wParam 用来表示控件的ID，或者高 16 位和低 16 位组合起来分别表示鼠标的位置，如果发送消息时需要附带某种结构的指针或者是某种类型的句柄时，习惯上用 lParam。</p>
<h2 id="WndProc-窗口过程"><a href="#WndProc-窗口过程" class="headerlink" title="WndProc 窗口过程"></a>WndProc 窗口过程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,  <span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT message,  <span class="comment">//消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,  <span class="comment">//附加消息1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">//附加消息2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：WndProc 的各个参数和 MSG 结构体的前四个字段是一一对应的。需要铭记的是：每产生<strong>一条消息，都会调用一次 WndProc 函数。</strong></p>
<p>2.当用户点击按钮、编辑框、下拉列表框等控件的时候，会产生WM_COMMAND消息。对于不同来源的 WM_COMMAND 消息，wParam、lParam 参数也不同，见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>消息来源</th>
<th>wParam (高16位)</th>
<th>wParam (低16位)</th>
<th>lParam</th>
</tr>
</thead>
<tbody>
<tr>
<td>菜单</td>
<td>0</td>
<td>菜单ID</td>
<td>0</td>
</tr>
<tr>
<td>快捷键</td>
<td>1</td>
<td>快捷键ID</td>
<td>0</td>
</tr>
<tr>
<td>控件</td>
<td>控件通知码</td>
<td>控件ID</td>
<td>控件句柄</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>控件通知码用来识别控件的操作。例如 Button 控件一般有两种通知码，BN_CLICKED 和 BN_DOUBLECLICKED，前者表示 Button 被单击，后者表示 Button 被双击。</li>
</ul>
<p>3.对于 Button 控件，我们可以通过<code>LOWORD(wParam)</code>来获取它的 ID。</p>
<h1 id="窗口创建"><a href="#窗口创建" class="headerlink" title="窗口创建"></a>窗口创建</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>定义 <code>WinMain</code> 函数</li>
<li>定义 <strong>窗口处理函数</strong></li>
<li>注册窗口类</li>
<li>创建窗口</li>
<li>显示窗口</li>
<li>消息循环</li>
<li>消息处理</li>
</ul>
<h2 id="完整的窗口"><a href="#完整的窗口" class="headerlink" title="完整的窗口"></a>完整的窗口</h2><p>一般的窗口包括有：最大化、最小化、关闭按钮，也包含菜单、单选框、图像等各种控件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    PSTR szCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TCHAR szClassName[] = TEXT(<span class="string">&quot;HelloWin&quot;</span>);  <span class="comment">//窗口类名</span></span><br><span class="line">    HWND     hwnd;  <span class="comment">//窗口句柄</span></span><br><span class="line">    MSG      msg;  <span class="comment">//消息</span></span><br><span class="line">    WNDCLASS wndclass;  <span class="comment">//窗口类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**********第①步：注册窗口类**********/</span>  </span><br><span class="line">    <span class="comment">//创建的窗口各不相同，windows把通用属性抽取出来用结构体表示</span></span><br><span class="line">    <span class="comment">//为窗口类的各个字段赋值</span></span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;  <span class="comment">//窗口风格</span></span><br><span class="line">    wndclass.lpfnWndProc  = WndProc;  <span class="comment">//窗口过程</span></span><br><span class="line">    wndclass.cbClsExtra   = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.cbWndExtra   = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.hInstance    = hInstance;  <span class="comment">//当前窗口句柄</span></span><br><span class="line">    wndclass.hIcon        = LoadIcon (<span class="literal">NULL</span>, IDI_APPLICATION);  <span class="comment">//窗口图标</span></span><br><span class="line">    wndclass.hCursor      = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW);  <span class="comment">//鼠标样式</span></span><br><span class="line">    wndclass.hbrBackground= (HBRUSH) GetStockObject (WHITE_BRUSH);  <span class="comment">//窗口背景画刷</span></span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span> ;  <span class="comment">//窗口菜单</span></span><br><span class="line">    wndclass.lpszClassName= szClassName;  <span class="comment">//窗口类名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册窗口</span></span><br><span class="line">    RegisterClass(&amp;wndclass);</span><br><span class="line">    <span class="comment">//窗口类仅仅是一个结构体，如果只定义了结构体变量，那么在使用时并不能通过 lpszClassName 字段的值找到这个结构体。所以还要调用 RegisterClass() 来注册，让系统知道窗口类的名字，下次使用时才能找到。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*****第②步：创建窗口(并让窗口显示出来)*****/</span></span><br><span class="line">    hwnd = CreateWindow(</span><br><span class="line">        szClassName,  <span class="comment">//窗口类的名字</span></span><br><span class="line">        TEXT(<span class="string">&quot;Welcome&quot;</span>),  <span class="comment">//窗口标题（出现在标题栏）</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW,  <span class="comment">//窗口风格</span></span><br><span class="line">        CW_USEDEFAULT,  <span class="comment">//初始化时x轴的位置</span></span><br><span class="line">        CW_USEDEFAULT,  <span class="comment">//初始化时y轴的位置</span></span><br><span class="line">        <span class="number">500</span>,  <span class="comment">//窗口宽度</span></span><br><span class="line">        <span class="number">300</span>,  <span class="comment">//窗口高度</span></span><br><span class="line">        <span class="literal">NULL</span>,  <span class="comment">//父窗口句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,  <span class="comment">//窗口菜单句柄</span></span><br><span class="line">        hInstance,  <span class="comment">//当前窗口的句柄</span></span><br><span class="line">        <span class="literal">NULL</span>  <span class="comment">//不使用该值</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    ShowWindow (hwnd, iCmdShow);</span><br><span class="line">    <span class="comment">//更新（绘制）窗口</span></span><br><span class="line">    UpdateWindow (hwnd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**********第③步：消息循环**********/</span></span><br><span class="line">    <span class="keyword">while</span>( GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);  <span class="comment">//翻译消息</span></span><br><span class="line">        DispatchMessage (&amp;msg);  <span class="comment">//分派消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********第④步：窗口过程**********/</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    HDC         hdc;  <span class="comment">//设备环境句柄</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT        rect;</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="comment">//窗口绘制消息</span></span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">            GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">            DrawText(</span><br><span class="line">                hdc,</span><br><span class="line">                TEXT(<span class="string">&quot;第一个win api程序&quot;</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                &amp;rect,</span><br><span class="line">                DT_SINGLELINE | DT_CENTER | DT_VCENTER</span><br><span class="line">            );</span><br><span class="line">            EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//窗口销毁消息</span></span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注册窗口类</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WNDCLASS wndclass;  <span class="comment">//窗口类</span></span><br><span class="line">    <span class="comment">//创建的窗口各不相同，windows把通用属性抽取出来用结构体表示</span></span><br><span class="line">    <span class="comment">//为窗口类的各个字段赋值</span></span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;  </span><br><span class="line">	<span class="comment">//窗口风格，这里的取值表示窗口大小改变时重绘窗口，确保内容在中间</span></span><br><span class="line">    wndclass.lpfnWndProc  = WndProc;  </span><br><span class="line">	<span class="comment">//窗口过程</span></span><br><span class="line">    wndclass.cbClsExtra   = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.cbWndExtra   = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.hInstance    = hInstance;  </span><br><span class="line">	<span class="comment">//当前窗口句柄</span></span><br><span class="line">    wndclass.hIcon        = LoadIcon (<span class="literal">NULL</span>, IDI_APPLICATION);  </span><br><span class="line">	<span class="comment">//窗口图标，需要用loadicon来加载</span></span><br><span class="line">    wndclass.hCursor      = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">	<span class="comment">//鼠标样式</span></span><br><span class="line">    wndclass.hbrBackground= (HBRUSH) GetStockObject (WHITE_BRUSH);  </span><br><span class="line">	<span class="comment">//窗口背景画刷，窗口背景的颜色</span></span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span> ;  </span><br><span class="line">	<span class="comment">//窗口菜单，没有菜单就是null</span></span><br><span class="line">    wndclass.lpszClassName= szClassName;  </span><br><span class="line">	<span class="comment">//窗口类名，方便于其他窗口进行区分</span></span><br></pre></td></tr></table></figure>
<p><strong>创建窗口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hwnd = CreateWindow(</span><br><span class="line">    szClassName,  <span class="comment">// 窗口类的名字，通过这个名字可以找到刚才注册的窗口类</span></span><br><span class="line">    TEXT(<span class="string">&quot;Welcome&quot;</span>),  <span class="comment">//窗口标题（出现在标题栏）</span></span><br><span class="line">    WS_OVERLAPPEDWINDOW,  <span class="comment">//窗口风格</span></span><br><span class="line">    CW_USEDEFAULT,  <span class="comment">//初始化时窗口x轴坐标</span></span><br><span class="line">    CW_USEDEFAULT,  <span class="comment">//初始化时窗口y轴坐标</span></span><br><span class="line">    <span class="number">500</span>,  <span class="comment">//窗口宽度</span></span><br><span class="line">    <span class="number">300</span>,  <span class="comment">//窗口高度</span></span><br><span class="line">    <span class="literal">NULL</span>,  <span class="comment">//父窗口句柄。这里没有父窗口，所以为 NULL</span></span><br><span class="line">    <span class="literal">NULL</span>,  <span class="comment">//窗口菜单句柄。当前窗口没有菜单，所以为 NULL</span></span><br><span class="line">    hInstance,  <span class="comment">//当前窗口的句柄，通过 WinMain 函数传入。</span></span><br><span class="line">    <span class="literal">NULL</span>  <span class="comment">//不使用该值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>显示器坐标远点在左上角，横为x，竖为y，没有负数</p>
<p>上述函数只是在内存中创建了窗口，分配了空间，获得了句柄，做好了准备工作，但是并不能显示</p>
<p><strong>显示窗口</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ShowWindow(hWnd, iCmdShow)<span class="comment">//hWnd:指窗口句柄。nCmdShow：指定窗口如何显示。</span></span><br></pre></td></tr></table></figure>
<p><strong>消息循环</strong></p>
<p>在 UpdateWindow 函数被调用之后，新建的窗口在屏幕中就可以显示了。</p>
<p>此时，程序必须能够<strong>接受用户的键盘或鼠标事件</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>) )<span class="comment">//GetMessage 函数用来从消息队列中获取一条消息，并保存到 MSG 结构体变量中。</span></span><br><span class="line">&#123;</span><br><span class="line">    TranslateMessage(&amp;msg);  <span class="comment">//翻译消息</span></span><br><span class="line">    DispatchMessage (&amp;msg);  <span class="comment">//分派消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.GetMessage 的返回值永远为非零值，while 循环会一直进行下去。<strong>如果队列中没有消息，GetMessage 函数会等待，</strong>直到有消息进入。</p>
<p>2.获取到消息后，需要调用 TranslateMessage 函数对消息进行转换（翻译），然后再调用 DispatchMessage 函数将消息传给窗口过程去处理（调用窗口过程）。</p>
<p><strong>窗口过程</strong></p>
<p>1.就是处理窗口事件的函数，也就是上面代码中最后的 WndProc 函数。</p>
<p>2.GetMessage 每获取到一条消息，最终都会丢给窗口过程去处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HDC         hdc;  <span class="comment">//设备环境句柄</span></span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT        rect;</span><br><span class="line">    <span class="keyword">switch</span> (message)<span class="comment">//不同的消息往往需要进行不同的处理，所以一般通过 switch case 语句来匹配。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//窗口绘制消息</span></span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint (hwnd, &amp;ps) ;</span><br><span class="line">            GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">            DrawText(</span><br><span class="line">                hdc,</span><br><span class="line">                TEXT(<span class="string">&quot;第一个win api程序&quot;</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                &amp;rect,</span><br><span class="line">                DT_SINGLELINE | DT_CENTER | DT_VCENTER</span><br><span class="line">            );</span><br><span class="line">            EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//窗口销毁消息</span></span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam) ;</span><br><span class="line">    <span class="comment">//让Windows自己处理应用程序没有处理的消息，必须要有该语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="绘制和重绘"><a href="#绘制和重绘" class="headerlink" title="绘制和重绘"></a>绘制和重绘</h1><p>1.当用户在屏幕移动其他程序的窗口时，遮住当前程序的部分窗口。Windows 不会保存被遮住的那部分窗口，当其他程序的窗口被移开时，Windows 会要求你的程序重新绘制刚才被遮住的部分区域。如果你自己不重绘，Windows 是不会管的。</p>
<p><strong>并不是简单的遮挡关系</strong></p>
<p>2.Windows 是一个消息驱动的系统，它使用两种方式把各种事件通知给应用程序：</p>
<ul>
<li>把消息放到应用程序的消息队列中，让程序自己通过 GetMessage 函数获取；</li>
<li>向窗口直接发送消息。</li>
</ul>
<h2 id="WM-PAINT-消息"><a href="#WM-PAINT-消息" class="headerlink" title="WM_PAINT 消息"></a>WM_PAINT 消息</h2><p>1.<strong>WM_PAINT 消息表示绘制窗口的客户区</strong>。</p>
<p>以下任何一个事件发生时，窗口过程都会收到一条 WM_PAINT 消息：</p>
<ul>
<li>用户移动一个窗口，导致原来被遮住的部分窗口暴露出来。</li>
<li>用户调整窗口的大小（当窗口类中 style 字段的值设定为 CS_HREDRAW | CS_VREDRAW 时）。</li>
<li>客户区滚动条滚动时。</li>
<li>当然，你可以可以调用相应的函数强制生成一条 WM_PAINT 消息。</li>
</ul>
<p>注意：<strong>窗口类中 style 字段的值经常被设定为<code>CS_HREDRAW | CS_VREDRAW</code>，只有这样，调整窗口宽度或高度时才会发生重绘</strong>。</p>
<p>2.在少数情况下，Windows 总是会<strong>保存被覆盖的部分窗口，然后再恢复</strong>，例如：</p>
<ul>
<li>鼠标指针在客户区内移动。</li>
<li>在客户区内拖动图标。</li>
</ul>
<p><strong><em>在Windows中一切界面都是绘图，一旦界面发生改变，就需要重新绘制。</em></strong></p>
<h2 id="有效矩形和无效矩形"><a href="#有效矩形和无效矩形" class="headerlink" title="有效矩形和无效矩形"></a>有效矩形和无效矩形</h2><p>1.Windows 一般不重绘整个客户区，而是绘制客户区的一部分。需要重新绘制的部分被称为<strong>“无效区域”或“更新区域”</strong></p>
<p>在绘制的时候，会将无效区域装进一个“最小矩形之中”，称为 <strong>无效矩形</strong></p>
<h1 id="向窗口输出文字—TextOut和DrawText函数"><a href="#向窗口输出文字—TextOut和DrawText函数" class="headerlink" title="向窗口输出文字—TextOut和DrawText函数"></a>向窗口输出文字—TextOut和DrawText函数</h1><h2 id="设备环境DC"><a href="#设备环境DC" class="headerlink" title="设备环境DC"></a>设备环境DC</h2><p>1.Windows不允许我们直接访问硬件，在与这些硬件通信前要获得设备环境（Device Context，简称 DC），进而间接的访问硬件。</p>
<blockquote>
<p>设备环境有时也被称为设备上下文或设备描述表。</p>
</blockquote>
<p>2.设备环境：与当前硬件设备有关的各种信息，它是硬件设备的抽象。</p>
<p>3.与文字输出、图形绘制有关的函数，在使用时大都需要传入一个参数，就是设备环境句柄。让程序知道往哪里输出</p>
<p>4.获取句柄：常用的是 BeginPaint 函数。绘图完成后，还要释放句柄，使用 EndPaint 函数。</p>
<h2 id="BeginPaint-和-EndPaint-函数"><a href="#BeginPaint-和-EndPaint-函数" class="headerlink" title="BeginPaint 和 EndPaint 函数"></a>BeginPaint 和 EndPaint 函数</h2><p>发生绘制事件时，程序通过bp函数通知windows当前程序需要显示器，bp函数执行完就返回显示器的句柄， 绘图之后，用ep函数通知windows绘图结束，可以往下走了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HDC         hdc;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    RECT        rect;</span><br><span class="line">    <span class="keyword">switch</span> (message)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint (hwnd, &amp;ps) ;	<span class="comment">//在这里开始绘制</span></span><br><span class="line">            GetClientRect (hwnd, &amp;rect) ;</span><br><span class="line">            <span class="comment">//GetClientRect 函数用来获得窗口客户区的坐标，也就是获得客户区这个矩形。</span></span><br><span class="line">            DrawText(</span><br><span class="line">                hdc,</span><br><span class="line">                TEXT(<span class="string">&quot;第一个win api程序&quot;</span>),</span><br><span class="line">                <span class="number">-1</span>,</span><br><span class="line">                &amp;rect,</span><br><span class="line">                DT_SINGLELINE | DT_CENTER | DT_VCENTER</span><br><span class="line">            );</span><br><span class="line">            EndPaint (hwnd, &amp;ps) ;	<span class="comment">//在这里结束绘制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TextOut-函数"><a href="#TextOut-函数" class="headerlink" title="TextOut 函数"></a>TextOut 函数</h2><p>TextOut 函数可以在客户区输出一段文本，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">TextOut</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nXStart,  <span class="comment">//开始输出位置的x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nYStart,  <span class="comment">//开始输出位置的y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpString,  <span class="comment">//要输出的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cbString  <span class="comment">//字符串的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>每当发生WM_PAINT事件时，窗口就会发生重绘，这个时候需要向窗口输出文字：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HDC         hdc;  <span class="comment">//设备环境句柄</span></span><br><span class="line">    PAINTSTRUCT ps;  <span class="comment">//存储绘图环境的相关信息</span></span><br><span class="line">    TCHAR szText[<span class="number">20</span>] = TEXT(<span class="string">&quot;欢迎来到C语言中文网&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            <span class="comment">//开始绘图并返回环境句柄</span></span><br><span class="line">            hdc = BeginPaint (hwnd, &amp;ps);</span><br><span class="line">            <span class="comment">//输出文字</span></span><br><span class="line">            TextOut(hdc, <span class="number">50</span>, <span class="number">50</span>, szText, wcslen(szText));<span class="comment">//注意这里的宽字符</span></span><br><span class="line">            <span class="comment">//结束绘图并释放环境句柄</span></span><br><span class="line">            EndPaint (hwnd, &amp;ps) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DrawText函数"><a href="#DrawText函数" class="headerlink" title="DrawText函数"></a>DrawText函数</h2><p>TextOut 在一个起点开始输出文本，可以精确定位，不能自动换行；</p>
<p>DrawText 在指定区域内输出文本，可以控制格式对，齐居左、居中、居右，可以换行（DrawText 在内部其实也是调用TextOut ）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hDC,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpString,  <span class="comment">//将要输出的字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCount,  <span class="comment">//字符串的长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 如果 nCount 为 -1，则表明 lpString 指向的字符串是以&#x27;\0&#x27;结束的，DrawText 会自动计算字符数。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPRECT lpRect,  <span class="comment">//指向一个矩形区域的结构体 RECT 的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uFormat  <span class="comment">//输出格式，有四种取值，它们可以任意组合</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数 uFormat 有四种取值，它们可以任意组合：用 | 隔开</p>
<ul>
<li>DT_CALCRECT：这个参数比较重要，可以使 DrawText 函数计算出输出文本的尺寸。如果输出文本有多行，DrawText 函数使用 lpRect 定义的矩形的宽度，并扩展矩形的底部以容纳输出文本的最后一行。如果输出文本只有一行，则 DrawText 函数改变矩形的右边界，以容纳下正文行的最后一个字符。出现上述任何一种情况。</li>
<li>DT_CENTER：指定文本水平居中显示。</li>
<li>DT_VCENTER：指定文本垂直居中显示。该标记只在单行文本输出时有效，所以它必须与DT_SINGLELINE结合使用。</li>
<li>DT_SINGLELINE：单行显示文本，回车和换行符都不断行。</li>
</ul>
<h1 id="Windows-GDI绘图基础与轻量进阶"><a href="#Windows-GDI绘图基础与轻量进阶" class="headerlink" title="Windows GDI绘图基础与轻量进阶"></a>Windows GDI绘图基础与轻量进阶</h1><p>1，简介：GDI 是 Graphics Device Interface 的缩写，称为图形设备接口，主要用来绘图，由动态链接库 GDI32.DLL 提供支持。Windows 本身也使用GDI来显示用户界面，比如菜单、滚动条、图标和鼠标指针等。</p>
<h2 id="GDI-基础"><a href="#GDI-基础" class="headerlink" title="GDI 基础"></a>GDI 基础</h2><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>Rectangle 函数可以在窗口上绘制一个矩形，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Rectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nLeftRect,  <span class="comment">//矩形左上角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nTopRect,  <span class="comment">//矩形左上角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nRightRect,  <span class="comment">//矩形右下角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nBottomRect  <span class="comment">//矩形右下角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">    hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">    Rectangle(hdc, <span class="number">50</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<p>运行效果就是会在一个窗口内出现一个矩形。</p>
<h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>如果要绘制一个圆形，可以使用 RoundRect 函数，函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RoundRect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nLeftRect,  <span class="comment">//矩形左上角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nTopRect,  <span class="comment">//矩形左上角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nRightRect,  <span class="comment">//矩形右下角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nBottomRect,  <span class="comment">//矩形右下角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nWidth,  <span class="comment">//用来画圆角的椭圆的宽度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nHeight  <span class="comment">//用来画圆角的椭圆的高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当 nHeight &gt;= nBottomRect 且 nWidth = nRightRect 时，那么绘制出的就是一个圆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RoundRect(hdc, <span class="number">20</span>, <span class="number">20</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<h3 id="绘制椭圆"><a href="#绘制椭圆" class="headerlink" title="绘制椭圆"></a>绘制椭圆</h3><p>Ellipse() 函数可以用来绘制椭圆，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Ellipse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nLeftRect,  <span class="comment">//左上角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nTopRect,  <span class="comment">//左上角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nRightRect,  <span class="comment">//右下角x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nBottomRect  <span class="comment">//右下角y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><p>确定起点使用 MoveToEx 函数。MoveToEx 用来指定画笔的起始位置，也就是从哪里开始画，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MoveToEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> x,  <span class="comment">//起始位置x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> y,  <span class="comment">//起始位置y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPPOINT lpPoint  <span class="comment">//指向用于保存当前位置的POINT结构体的指针，直接返回NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面继续设置终点函数</span></span><br><span class="line">    <span class="function">BOOL <span class="title">LineTo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> xEnd,  <span class="comment">//终点的x坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> yEnd  <span class="comment">//终点的y坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：win32不再支持 MoveTo，只支持它的扩展函数 MoveToEx。</p>
</blockquote>
<p>（在这里知道后面的Ex是原先api的拓展）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">	hdc = BeginPaint(hwnd, &amp;ps);</span><br><span class="line">	GetClientRect(hwnd, &amp;rect);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DrawText(hdc, TEXT(&quot;第一个真正的gui程序&quot;), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);</span></span><br><span class="line">	<span class="comment">//Rectangle(hdc, 50,50,20,20);//用来绘制矩形</span></span><br><span class="line">	<span class="comment">//RoundRect(hdc, 20, 20, 150, 150, 150, 150);//绘制圆角或者是绘制圆形</span></span><br><span class="line">	<span class="comment">//Ellipse(hdc, 20, 20, 180, 90);//绘制椭圆，也可以绘制圆形</span></span><br><span class="line">	<span class="comment">//Ellipse(hdc, 20, 20, 40, 40);//绘制圆形</span></span><br><span class="line">	MoveToEx(hdc, <span class="number">150</span>, <span class="number">150</span>, <span class="literal">NULL</span>); <span class="comment">//设定起始点,不保存当前点坐标</span></span><br><span class="line">	LineTo(hdc, <span class="number">200</span>, <span class="number">60</span>); <span class="comment">//第一条线</span></span><br><span class="line">	LineTo(hdc, <span class="number">250</span>, <span class="number">150</span>); <span class="comment">//第二条线</span></span><br><span class="line">	LineTo(hdc, <span class="number">150</span>, <span class="number">150</span>); <span class="comment">//第三条线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	EndPaint(hwnd, &amp;ps);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//窗口销毁消息</span></span><br></pre></td></tr></table></figure>
<p>这样就可以绘制出一个三角形</p>
<h2 id="画笔和画刷"><a href="#画笔和画刷" class="headerlink" title="画笔和画刷"></a>画笔和画刷</h2><p>1.画笔就是划线的，画刷就是可以覆盖 一块区域</p>
<h3 id="创建和使用画笔"><a href="#创建和使用画笔" class="headerlink" title="创建和使用画笔"></a>创建和使用画笔</h3><p>1.上面的绘图使用的是Windows的默认画笔，也就是宽度为1个像素，颜色为黑色的画笔。</p>
<p>创建画笔的API函数为 CreatePen：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HPEN <span class="title">CreatePen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nPenStyle,  <span class="comment">//画笔的样式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nWidth,  <span class="comment">//画笔的宽度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    COLORREF crColor  <span class="comment">//画笔的颜色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//因为指定设备环境，所以新创建的画笔与当前设备环境并没有关联，无法使用。</span></span><br></pre></td></tr></table></figure>
<p>1.画笔样式 nPenStyle 有7种取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏定义</th>
<th>宏定义对应的值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PS_SOLID</td>
<td>0</td>
<td>实线</td>
</tr>
<tr>
<td>PS_DASH</td>
<td>1</td>
<td>虚线（段线），要求画笔宽度 &lt;= 1</td>
</tr>
<tr>
<td>PS_DOT</td>
<td>2</td>
<td>点线，要求画笔宽度 &lt;= 1</td>
</tr>
<tr>
<td>PS_DASHDOT</td>
<td>3</td>
<td>线、点，要求画笔宽度 &lt;= 1</td>
</tr>
<tr>
<td>PS_DASHDOTDOT</td>
<td>4</td>
<td>线、点、点，要求画笔宽度 &lt;= 1</td>
</tr>
<tr>
<td>PS_NULL</td>
<td>5</td>
<td>不可见</td>
</tr>
<tr>
<td>PS_INSIDEFRAME</td>
<td>6</td>
<td>实线，但画笔宽度是向里扩展的</td>
</tr>
</tbody>
</table>
</div>
<p>2.画笔宽度 ：nWidth 指逻辑宽度。iWidth为 0 则意味着画笔宽度为一个像素。如果画笔样式为点线或者虚线，同时又指定一个大于 1 的画笔宽度，<strong>那么Windows将使用实线画笔来代替。</strong></p>
<p>3.画笔的颜色 crColor 可以直接使用 RGB 颜色。</p>
<h3 id="GDI对象"><a href="#GDI对象" class="headerlink" title="GDI对象"></a>GDI对象</h3><p>画笔、画刷、字体等被称为GDI对象。可以供 GDI 函数使用。新创建的 GDI 对象必须通过 <code>SelectObject</code> 函数选入设备环境才能使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HGDIOBJ <span class="title">SelectObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HGDIOBJ ho  <span class="comment">//GDI对象句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="comment">//定义一个画笔句柄,请定义为静态变量</span></span><br><span class="line">    <span class="keyword">static</span> HPEN hPen;</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">            <span class="comment">//创建宽度为2个像素的红色点线画笔，保存句柄到 hPen 变量</span></span><br><span class="line">            hPen = CreatePen(PS_SOLID, <span class="number">2</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">//选入画笔到设备环境</span></span><br><span class="line">            SelectObject(hdc, hPen);</span><br><span class="line">            <span class="comment">//绘制三角形</span></span><br><span class="line">            MoveToEx(hdc, <span class="number">150</span>, <span class="number">150</span>, <span class="literal">NULL</span>);</span><br><span class="line">            LineTo(hdc,<span class="number">200</span>, <span class="number">60</span>); <span class="comment">//第一条线</span></span><br><span class="line">            LineTo(hdc, <span class="number">250</span>, <span class="number">150</span>); <span class="comment">//第二条线</span></span><br><span class="line">            LineTo(hdc, <span class="number">150</span>, <span class="number">150</span>); <span class="comment">//第三条线</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            <span class="comment">//请做好善后工作,处理 WM_DESTROY 消息时删除之前我们创建的一切GDI对象</span></span><br><span class="line">            DeleteObject(hPen);</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会画一个红色的三角形。</p>
<p>画笔最好在 WM_CREATE 事件中创建，因为当应用程序运行时会频繁地触发 WM_PAINT 事件，比如窗口被覆盖后再显示、窗口被拖动、窗口被拉伸等，每次都需要重新创建画笔，浪费资源</p>
<h3 id="创建和使用画刷"><a href="#创建和使用画刷" class="headerlink" title="创建和使用画刷"></a>创建和使用画刷</h3><p>Windows API 中有两个函数可以用来创建画刷。</p>
<p>1.CreateSolidBrush 函数可以用来创建一个指定颜色的实心画刷</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HBRUSH <span class="title">CreateSolidBrush</span><span class="params">( COLORREF crColor )</span></span>;  <span class="comment">// crColor为画刷颜色</span></span><br></pre></td></tr></table></figure>
<p>2.CreateHatchBrush 函数可以用来创建一个指定颜色的含有特定阴影样式的画刷，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HBRUSH <span class="title">CreateHatchBrush</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> fnStyle,  <span class="comment">//画刷样式，6种样式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    COLORREF crColor  <span class="comment">//画刷颜色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>HS_BDIGONAL：   45度向上，自左至右的阴影(///)</li>
<li>HS_CROSS：           表示水平直线和垂直直线交叉阴影(+++)</li>
<li>HS_DIAGCROSS： 45度交叉阴影(XXX)</li>
<li>HS_FDIAGONAL： 45度向下自左至右的阴影(\)</li>
<li>HS_HORIZONTAL：水平阴影(—-)</li>
<li>HS_VERTICAL：       垂直阴影</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="comment">//定义两个画刷,请定义为静态变量</span></span><br><span class="line">    <span class="keyword">static</span> HBRUSH hSolidBrush;</span><br><span class="line">    <span class="keyword">static</span> HBRUSH hHatchBrush;</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span> WM_CREATE:</span><br><span class="line">            <span class="comment">//创建蓝色实心画刷，保存句柄到 hSolidBrush 变量</span></span><br><span class="line">            hSolidBrush = CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">            <span class="comment">//创建绿色交叉阴影画刷，保存句柄到 hHatchBrush 变量</span></span><br><span class="line">            hHatchBrush = CreateHatchBrush(HS_DIAGCROSS,RGB(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">//选入蓝色实心画刷到设备环境</span></span><br><span class="line">            SelectObject(hdc, hSolidBrush);</span><br><span class="line">            Rectangle(hdc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>); <span class="comment">//绘制矩形</span></span><br><span class="line">            <span class="comment">//选入绿色交叉画刷到设备环境</span></span><br><span class="line">            SelectObject(hdc, hHatchBrush);</span><br><span class="line">            Ellipse(hdc,<span class="number">0</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>); <span class="comment">//绘制椭圆</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            <span class="comment">//请做好善后工作,处理 WM_DESTROY 消息时删除之前我们创建的一切GDI对象。</span></span><br><span class="line">            DeleteObject(hSolidBrush);</span><br><span class="line">            DeleteObject(hHatchBrush);</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上程序可以生成带颜色的长方形和矩形</p>
<h1 id="Windows-static控件"><a href="#Windows-static控件" class="headerlink" title="Windows static控件"></a>Windows static控件</h1><p>1.实际开发中一般使用静态文本框控件来输出文本。静态文本框是Windows 的一种<strong>标准控件</strong>，可以用来在窗口上显示一段文本，并且文本容易受到控制。除了静态文本框，<strong>Windows的标准控件还有很多种，例如按钮、下拉菜单、单选按钮、复选框等。</strong></p>
<p>2.<strong>控件是子窗口</strong>，创建时必须指定父窗口，这样控件才能有“归属”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpClassName,  <span class="comment">//窗口类名</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpWindowName,  <span class="comment">//窗体标题（或控件文本）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwStyle,  <span class="comment">//窗口/控件样式，WS开头</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> x,  <span class="comment">//窗口相对桌面（或子窗口相对父窗口）的 X 坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> y,  <span class="comment">//窗口相对桌面（或子窗口相对父窗口）的 Y 坐标</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nWidth,  <span class="comment">//窗体宽度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nHeight,  <span class="comment">//窗体高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWndParent,  <span class="comment">//父窗口句柄，独立窗口，那么为 NULL，如果是控件，那么就需要父窗口的句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HMENU hMenu,  <span class="comment">//菜单句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,  <span class="comment">//当前程序实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParam  <span class="comment">//一个指向某数值的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p> lpWindowName 应传入窗口的标题，若你希望创建控件，则应传入控件的文本。</p>
<p>写起来程序和上面的程序差不多，但是有一个地方就是<code>`CreateWindow 函数传入的倒数第二个参数为 hInst</code>,表示当前程序的实例句柄。</p>
<p>当前实例句柄是通过 WinMain 函数的参数传入的，所以必须要定义一个全局变量 hInst，然后在 WinMain 中给它赋值后才能使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE hInst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    PSTR szCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> iCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 其他代码</span></span><br><span class="line">    hInst = hInstance;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line">HINSTANCE hInst;		<span class="comment">//hInst 在 WndProc 函数中并不存在，</span></span><br><span class="line">						<span class="comment">//因为当前实例句柄是通过 WinMain 函数的参数传入的，所以必须要定义一个全局变量 hInst，然后在 WinMain 中给它赋值后才能使用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> TCHAR szClassName[] = <span class="string">L&quot;HelloWinStatic&quot;</span>;  <span class="comment">//窗口类名</span></span><br><span class="line"></span><br><span class="line">	HWND     hwnd;  <span class="comment">//窗口句柄</span></span><br><span class="line">	MSG      msg;  <span class="comment">//消息</span></span><br><span class="line">	WNDCLASS wndclass;  <span class="comment">//窗口类</span></span><br><span class="line">	hInst = hInstance;</span><br><span class="line"> <span class="comment">/**********第①步：注册窗口类**********/</span></span><br><span class="line">	<span class="comment">//为窗口类的各个字段赋值</span></span><br><span class="line">	wndclass.style = CS_HREDRAW | CS_VREDRAW;  <span class="comment">//窗口风格</span></span><br><span class="line">	wndclass.lpfnWndProc = WndProc;  <span class="comment">//窗口过程</span></span><br><span class="line">	wndclass.cbClsExtra = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">	wndclass.cbWndExtra = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">	wndclass.hInstance = hInstance;  <span class="comment">//当前窗口句柄</span></span><br><span class="line">	wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);  <span class="comment">//窗口图标</span></span><br><span class="line">	wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);  <span class="comment">//鼠标样式</span></span><br><span class="line">	wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  <span class="comment">//窗口背景画刷</span></span><br><span class="line">	wndclass.lpszMenuName = <span class="literal">NULL</span>;  <span class="comment">//窗口菜单</span></span><br><span class="line">	wndclass.lpszClassName = szClassName;  <span class="comment">//窗口类名</span></span><br><span class="line">	<span class="comment">//注册窗口</span></span><br><span class="line">	RegisterClass(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*****第②步：创建窗口(并让窗口显示出来)*****/</span></span><br><span class="line">	hwnd = CreateWindow(</span><br><span class="line">								szClassName,  <span class="comment">//窗口类的名字</span></span><br><span class="line">								TEXT(<span class="string">&quot;Welcome2Static&quot;</span>),  <span class="comment">//窗口标题（出现在标题栏）</span></span><br><span class="line">								WS_OVERLAPPEDWINDOW,  <span class="comment">//窗口风格</span></span><br><span class="line">								CW_USEDEFAULT,  <span class="comment">//初始化时x轴的位置</span></span><br><span class="line">								CW_USEDEFAULT,  <span class="comment">//初始化时y轴的位置</span></span><br><span class="line">								<span class="number">500</span>,  <span class="comment">//窗口宽度</span></span><br><span class="line">								<span class="number">500</span>,  <span class="comment">//窗口高度</span></span><br><span class="line">								<span class="literal">NULL</span>,  <span class="comment">//父窗口句柄</span></span><br><span class="line">								<span class="literal">NULL</span>,  <span class="comment">//窗口菜单句柄</span></span><br><span class="line">								hInstance,  <span class="comment">//当前窗口的句柄</span></span><br><span class="line">								<span class="literal">NULL</span>  <span class="comment">//不使用该值</span></span><br><span class="line">						);</span><br><span class="line">	<span class="comment">//显示窗口</span></span><br><span class="line">	ShowWindow(hwnd, iCmdShow);</span><br><span class="line">	<span class="comment">//更新（绘制）窗口</span></span><br><span class="line">	UpdateWindow(hwnd);</span><br><span class="line">	<span class="comment">/**********第③步：消息循环**********/</span></span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">		TranslateMessage(&amp;msg);  <span class="comment">//翻译消息</span></span><br><span class="line">		DispatchMessage(&amp;msg);  <span class="comment">//分派消息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">	PAINTSTRUCT ps;</span><br><span class="line">	HDC hdc;</span><br><span class="line">	HWND hStatic;</span><br><span class="line">	<span class="keyword">switch</span> (message) &#123;</span><br><span class="line">	<span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">		hStatic = CreateWindow(</span><br><span class="line">			<span class="string">L&quot;static&quot;</span>, <span class="comment">//静态文本框的类名</span></span><br><span class="line">			<span class="string">L&quot;C语言中文网&quot;</span>,  <span class="comment">//控件的文本</span></span><br><span class="line">			WS_CHILD <span class="comment">/*子窗口*/</span> | WS_VISIBLE <span class="comment">/*创建时显示*/</span> | WS_BORDER <span class="comment">/*带边框*/</span> | SS_CENTER <span class="comment">/*水平居中*/</span> | SS_CENTERIMAGE <span class="comment">/*垂直居中*/</span>,</span><br><span class="line">			<span class="number">20</span> <span class="comment">/*X坐标*/</span>, <span class="number">20</span> <span class="comment">/*Y坐标*/</span>, <span class="number">200</span> <span class="comment">/*宽度*/</span>, <span class="number">100</span> <span class="comment">/*高度*/</span>,</span><br><span class="line">			hWnd,  <span class="comment">//父窗口句柄</span></span><br><span class="line">			(HMENU)<span class="number">1</span>,  <span class="comment">//为控件指定一个唯一标识符</span></span><br><span class="line">			hInst,  <span class="comment">//当前程序实例句柄</span></span><br><span class="line">			<span class="literal">NULL</span></span><br><span class="line">		);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_PAINT:</span><br><span class="line">		hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">		EndPaint(hWnd, &amp;ps);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">		PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取、修改控件文本"><a href="#获取、修改控件文本" class="headerlink" title="获取、修改控件文本"></a>获取、修改控件文本</h2><p>1.GetWindowText 函数用于将指定窗口的标题文本（如果存在）拷贝到一个缓存区内；如果指定的窗口是一个控件，则拷贝控件的文本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Int <span class="title">GetWindowText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,  <span class="comment">//窗口/控件句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpString,  <span class="comment">//指向接收文本的缓冲区指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Int nMaxCount  <span class="comment">//要保存在缓冲区内的字符的最大个数，包含NULL字符。文本超过界被截断。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>2.类似的函数：<code>SetWindowText</code>，用来设置窗口标题或者控件文本。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetWindowText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpString</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如下代码显示鼠标点击次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line">HINSTANCE hInst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">    PSTR szCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> iCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TCHAR szClassName[] = TEXT(<span class="string">&quot;Win32Demo&quot;</span>); </span><br><span class="line">    HWND     hwnd;  </span><br><span class="line">    MSG      msg;  </span><br><span class="line">    WNDCLASS wndclass; </span><br><span class="line"></span><br><span class="line">    hInst = hInstance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;  </span><br><span class="line">    wndclass.lpfnWndProc = WndProc; </span><br><span class="line">    wndclass.cbClsExtra = <span class="number">0</span>;  </span><br><span class="line">    wndclass.cbWndExtra = <span class="number">0</span>;  </span><br><span class="line">    wndclass.hInstance = hInstance;  </span><br><span class="line">    wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION); </span><br><span class="line">    wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);  </span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);; </span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span>;  </span><br><span class="line">    wndclass.lpszClassName = szClassName;  </span><br><span class="line"></span><br><span class="line">    RegisterClass(&amp;wndclass);</span><br><span class="line"></span><br><span class="line">    hwnd = CreateWindow(</span><br><span class="line">        szClassName,  </span><br><span class="line">        TEXT(<span class="string">&quot;Welcome&quot;</span>),  </span><br><span class="line">        WS_OVERLAPPEDWINDOW,  </span><br><span class="line">        CW_USEDEFAULT,  </span><br><span class="line">        CW_USEDEFAULT,  </span><br><span class="line">        <span class="number">500</span>,  </span><br><span class="line">        <span class="number">300</span>,  </span><br><span class="line">        <span class="literal">NULL</span>, </span><br><span class="line">        <span class="literal">NULL</span>,  </span><br><span class="line">        hInstance,  </span><br><span class="line">        <span class="literal">NULL</span>  </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ShowWindow(hwnd, iCmdShow);</span><br><span class="line">   </span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg); </span><br><span class="line">        DispatchMessage(&amp;msg);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> iClick = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">static</span> TCHAR szTextBuf[<span class="number">20</span>];  </span><br><span class="line">    <span class="keyword">static</span> HWND hStatic;  <span class="comment">//静态变量是因为防止在creat结束的时候会销毁无法使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">        hStatic = CreateWindow(</span><br><span class="line">            <span class="string">L&quot;static&quot;</span>, </span><br><span class="line">            <span class="string">L&quot;LALALALALALALA&quot;</span>,  </span><br><span class="line">            WS_CHILD  | WS_VISIBLE  | WS_BORDER  | SS_CENTER  | SS_CENTERIMAGE ,</span><br><span class="line">            <span class="number">20</span> , <span class="number">20</span> , <span class="number">200</span> , <span class="number">100</span> ,</span><br><span class="line">            hWnd,  </span><br><span class="line">            (HMENU)<span class="number">1</span>,  </span><br><span class="line">            hInst,  </span><br><span class="line">            <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">        EndPaint(hWnd, &amp;ps);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">        iClick++;</span><br><span class="line">        wsprintf(szTextBuf, TEXT(<span class="string">&quot;%d&quot;</span>), iClick);<span class="comment">//往缓冲区写东西的函数</span></span><br><span class="line">        SetWindowText(hStatic, szTextBuf);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.对于窗口函数中的变量，如果是在 WM_CREATE 消息中赋值，但在其他消息中使用，那么一般声明为静态变量，这样下次执行窗口函数时依然有效。尤其是这种窗口会不断变化的函数</p>
<h1 id="Windows-CreateFont：创建自己的字体"><a href="#Windows-CreateFont：创建自己的字体" class="headerlink" title="Windows CreateFont：创建自己的字体"></a>Windows CreateFont：创建自己的字体</h1><p>创建字体使用 CreateFont 函数，它的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HFONT <span class="title">CreateFont</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cHeight,  <span class="comment">//字体的逻辑高度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cWidth,  <span class="comment">//字体的逻辑宽度，一般取负数，高是宽的两倍</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cEscapement,  <span class="comment">//指定移位向量相对X轴的偏转角度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cOrientation,  <span class="comment">//指定字符基线相对X轴的偏转角度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> cWeight,  <span class="comment">//设置字体粗细程度，可以使用 FW_ 开头的宏定义；一般取 FW_NORMAL (400)，此参数需要值的值域为 [0,1000]。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD bItalic,  <span class="comment">//是否启用斜体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD bUnderline,  <span class="comment">//是否启用下划线</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD bStrikeOut,  <span class="comment">//是否启用删除线。以上这仨，直接TRUE或者FALSE取值就可以</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD iCharSet,  <span class="comment">//指定字符集，直接使用 DEFAULT_CHARSET 让系统自动处理。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD iOutPrecision,  <span class="comment">//输出精度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD iClipPrecision,  <span class="comment">//剪裁精度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD iQuality,  <span class="comment">//输出质量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD iPitchAndFamily,  <span class="comment">//字体族</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR pszFaceName  <span class="comment">//字体名</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意：字体也是一种 GDI 对象，使用完后也要在 WM_DESTROY 消息中删除。</strong></p>
<p>1.创建完字体后并不能立即使用，还需要手动触发 <strong>WM_SETFONT</strong> 消息（设置字体的消息），让Windows 将当前字体设置为我们创建的字体。</p>
<p>2.发送消息使用 SendMessage 函数，它可以让我们在必要时主动向窗口发送各种消息，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(	<span class="comment">//SendMessage 发送的消息就是由窗口过程来处理的。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,  <span class="comment">//发送消息的目标窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT msg,  <span class="comment">//将要发送的消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,  <span class="comment">//附加消息1， 传入 CreateFont 返回的句柄即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">//附加消息2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="Windows-button控件（按钮控件）"><a href="#Windows-button控件（按钮控件）" class="headerlink" title="Windows button控件（按钮控件）"></a>Windows button控件（按钮控件）</h1><p>1.按钮既是标准控件，也是子窗口，窗口类名是<code>button</code>。</p>
<p>2.Button 控件样式以<code>BS</code>开头</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BS_LEFT</td>
<td>文本居左。</td>
</tr>
<tr>
<td>BS_RIGHT</td>
<td>文本居右。</td>
</tr>
<tr>
<td>BS_CENTER</td>
<td>文本水平居中（默认为 BS_CENTER）。</td>
</tr>
<tr>
<td>BS_BOTTOM</td>
<td>文本位于按钮底部。</td>
</tr>
<tr>
<td>BS_TOP</td>
<td>文本位于按钮顶部。</td>
</tr>
<tr>
<td>BS_VCENTER</td>
<td>文本垂直居中（默认为 BS_VCENTER）。</td>
</tr>
<tr>
<td>BS_FLAT</td>
<td>扁平样式。默认情况下按钮具有3D阴影效果。</td>
</tr>
<tr>
<td>BS_MULTILINE</td>
<td>允许显示多行文本。也就是说当文本过长时会自动换行。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="keyword">static</span> HFONT hFont;</span><br><span class="line">    <span class="keyword">static</span> HWND hBtn;</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">            <span class="comment">//创建逻辑字体</span></span><br><span class="line">            hFont = CreateFont(</span><br><span class="line">                <span class="number">-15</span><span class="comment">/*高度*/</span>, <span class="number">-7.5</span><span class="comment">/*宽度*/</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span> <span class="comment">/*一般这个值设为400*/</span>,</span><br><span class="line">                FALSE<span class="comment">/*不带斜体*/</span>, FALSE<span class="comment">/*不带下划线*/</span>, FALSE<span class="comment">/*不带删除线*/</span>,</span><br><span class="line">                DEFAULT_CHARSET,  <span class="comment">//使用默认字符集</span></span><br><span class="line">                OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,  <span class="comment">//这行参数不用管</span></span><br><span class="line">                DEFAULT_QUALITY,  <span class="comment">//默认输出质量</span></span><br><span class="line">                FF_DONTCARE,  <span class="comment">//不指定字体族*/</span></span><br><span class="line">                TEXT(<span class="string">&quot;微软雅黑&quot;</span>)  <span class="comment">//字体名</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//创建按钮控件</span></span><br><span class="line">            hBtn = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), <span class="comment">//按钮控件的类名</span></span><br><span class="line">                TEXT(<span class="string">&quot;这是按钮&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | WS_BORDER | BS_FLAT<span class="comment">/*扁平样式*/</span>,</span><br><span class="line">                <span class="number">30</span> <span class="comment">/*X坐标*/</span>, <span class="number">20</span> <span class="comment">/*Y坐标*/</span>, <span class="number">150</span> <span class="comment">/*宽度*/</span>, <span class="number">50</span><span class="comment">/*高度*/</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">2</span> <span class="comment">/*控件唯一标识符*/</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            SendMessage(hBtn, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);<span class="comment">//设置按钮字体</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            <span class="comment">//请做好善后工作</span></span><br><span class="line">            DeleteObject(hFont);</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码就设置了一个内容是“这是按钮”的控件</p>
<p>关于如何捕获到按钮的消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT message,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="keyword">static</span> HFONT hFont;</span><br><span class="line">    <span class="keyword">static</span> HWND hBtn;</span><br><span class="line">    <span class="keyword">static</span> HWND hStatic;</span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">            <span class="comment">//创建逻辑字体</span></span><br><span class="line">            hFont = CreateFont(</span><br><span class="line">                <span class="number">-15</span><span class="comment">/*高度*/</span>, <span class="number">-7.5</span><span class="comment">/*宽度*/</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span> <span class="comment">/*一般这个值设为400*/</span>,</span><br><span class="line">                FALSE<span class="comment">/*不带斜体*/</span>, FALSE<span class="comment">/*不带下划线*/</span>, FALSE<span class="comment">/*不带删除线*/</span>,</span><br><span class="line">                DEFAULT_CHARSET,  <span class="comment">//使用默认字符集</span></span><br><span class="line">                OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,  <span class="comment">//这行参数不用管</span></span><br><span class="line">                DEFAULT_QUALITY,  <span class="comment">//默认输出质量</span></span><br><span class="line">                FF_DONTCARE,  <span class="comment">//不指定字体族*/</span></span><br><span class="line">                TEXT(<span class="string">&quot;微软雅黑&quot;</span>)  <span class="comment">//字体名</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//创建静态文本控件</span></span><br><span class="line">            hStatic = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;static&quot;</span>),  <span class="comment">//静态文本框的类名</span></span><br><span class="line">                TEXT(<span class="string">&quot;你好，欢迎来到C语言中文网&quot;</span>),  <span class="comment">//控件的文本</span></span><br><span class="line">                WS_CHILD <span class="comment">/*子窗口*/</span> | WS_VISIBLE <span class="comment">/*创建时显示*/</span> | WS_BORDER <span class="comment">/*带边框*/</span>,</span><br><span class="line">                <span class="number">30</span> <span class="comment">/*X坐标*/</span>, <span class="number">20</span><span class="comment">/*Y坐标*/</span>, <span class="number">150</span><span class="comment">/*宽度*/</span>, <span class="number">80</span><span class="comment">/*高度*/</span>, hWnd<span class="comment">/*父窗口句柄*/</span>,</span><br><span class="line">                (HMENU)<span class="number">1</span>,  <span class="comment">//为控件指定一个唯一标识符</span></span><br><span class="line">                hInst,  <span class="comment">//当前实例句柄</span></span><br><span class="line">                <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//创建按钮控件</span></span><br><span class="line">            hBtn = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>),  <span class="comment">//按钮控件的类名</span></span><br><span class="line">                TEXT(<span class="string">&quot;点击这里试试&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | WS_BORDER | BS_FLAT<span class="comment">/*扁平样式*/</span>,</span><br><span class="line">                <span class="number">30</span> <span class="comment">/*X坐标*/</span>, <span class="number">110</span> <span class="comment">/*Y坐标*/</span>, <span class="number">150</span> <span class="comment">/*宽度*/</span>, <span class="number">50</span><span class="comment">/*高度*/</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">2</span> <span class="comment">/*控件唯一标识符*/</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            SendMessage(hStatic,WM_SETFONT,(WPARAM)hFont,<span class="literal">NULL</span>);<span class="comment">//设置文本框字体</span></span><br><span class="line">            SendMessage(hBtn, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);<span class="comment">//设置按钮字体</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">            wmId    = LOWORD(wParam);</span><br><span class="line">            wmEvent = HIWORD(wParam);</span><br><span class="line">            <span class="keyword">switch</span> (wmId)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//按下按钮</span></span><br><span class="line">                    <span class="comment">//更改文本框的内容</span></span><br><span class="line">                    SetWindowText( hStatic, TEXT(<span class="string">&quot;你点击了下面的按钮&quot;</span>) );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//不处理的消息一定要交给 DefWindowProc 处理。</span></span><br><span class="line">                    <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            <span class="comment">//请做好善后工作</span></span><br><span class="line">            DeleteObject(hFont);</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Windows-edit控件（编辑框控件）"><a href="#Windows-edit控件（编辑框控件）" class="headerlink" title="Windows edit控件（编辑框控件）"></a>Windows edit控件（编辑框控件）</h1><p>1.相当于是控制台程序的scanf函数</p>
<p>2.编辑框控件的窗口类名是<code>edit</code>。除了子窗口常用的风格 WS_CHILD、WS_VISIBLE、WS_BORDER 外，edit 控件也有自己的风格，都是以<code>ES</code>开头。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>风格</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ES_AUTOHSCROLL</td>
<td>当输入文字超出横向显示范围时自动滚动（一般必选）。</td>
</tr>
<tr>
<td>ES_AUTOVSCROLL</td>
<td>当输入文字超出纵向显示范围时自动滚动。</td>
</tr>
<tr>
<td>ES_CENTER</td>
<td>文本居中对齐。</td>
</tr>
<tr>
<td>ES_LEFT</td>
<td>文本左对齐（默认）。</td>
</tr>
<tr>
<td>ES_RIGHT</td>
<td>文本右对齐。</td>
</tr>
<tr>
<td>ES_MULTILINE</td>
<td>是否允许多行输入。</td>
</tr>
<tr>
<td>ES_PASSWORD</td>
<td>是否为密码输入框，如果指明该风格则输入的文字显示为“<em>*</em>”。</td>
</tr>
<tr>
<td>ES_READONLY</td>
<td>是否为只读。禁止用户输入或修改编辑控件中的文本。</td>
</tr>
<tr>
<td>ES_UPPERCASE</td>
<td>显示大写字符。</td>
</tr>
<tr>
<td>ES_LOWERCASE</td>
<td>显示小写字符。</td>
</tr>
<tr>
<td>ES_LOWERCASE</td>
<td>将用户输入到编辑控件的字符全部转换为小写。</td>
</tr>
<tr>
<td>ES_UPPERCASE</td>
<td>将用户输入到编辑控件的字符全部转换为大写。</td>
</tr>
<tr>
<td>ES_MULTILINE</td>
<td>指明了一个多行编辑控件（缺省的是单行的）。  1) 如果指定了ES_AUTOVSCROLL风格，编辑控件将显示尽可能多的文本，并且当用户按下ENTER键时会自动地垂直滚动文本。  2) 如果没有指定ES_AUTOVSCROLL风格，则编辑控件将显示尽可能多的行，如果在按下ENTER键却没有更多的行要显示的话，就发出蜂鸣声。  3) 如果指定了ES_AUTOHSCROLL风格，当光标到达控件的右边时，多行编辑控件会自动地水平滚动文本。如果要开始一个新行，用户必须按下ENTER键。  4) 如果没有指定ES_AUTOHSCROLL风格，控件会在有必要时自动将单词折合到下一行的开始。如果按下ENTER键，则另起一行。折回单词的位置是由窗口的大小决定的。如果窗口的大小发生改变，折回单词的位置也会反生改变，将会重新显示文本。</td>
</tr>
</tbody>
</table>
</div>
<p>实例程序，登录框</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span>    <span class="comment">//代码段2 完整的窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line">HINSTANCE hInst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> TCHAR szClassName[] = TEXT(<span class="string">&quot;HelloWin&quot;</span>);  <span class="comment">//窗口类名</span></span><br><span class="line"></span><br><span class="line">    HWND     hwnd;  <span class="comment">//窗口句柄</span></span><br><span class="line">    MSG      msg;  <span class="comment">//消息</span></span><br><span class="line">    WNDCLASS wndclass;  <span class="comment">//窗口类</span></span><br><span class="line"></span><br><span class="line">    hInst = hInstance;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**********第①步：注册窗口类**********/</span></span><br><span class="line">    <span class="comment">//为窗口类的各个字段赋值</span></span><br><span class="line">    wndclass.style = CS_HREDRAW | CS_VREDRAW;  <span class="comment">//窗口风格</span></span><br><span class="line">    wndclass.lpfnWndProc = WndProc;  <span class="comment">//窗口过程</span></span><br><span class="line">    wndclass.cbClsExtra = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.cbWndExtra = <span class="number">0</span>;  <span class="comment">//暂时不需要理解</span></span><br><span class="line">    wndclass.hInstance = hInstance;  <span class="comment">//当前窗口句柄</span></span><br><span class="line">    wndclass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);  <span class="comment">//窗口图标</span></span><br><span class="line">    wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);  <span class="comment">//鼠标样式</span></span><br><span class="line">    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  <span class="comment">//窗口背景画刷</span></span><br><span class="line">    wndclass.lpszMenuName = <span class="literal">NULL</span>;  <span class="comment">//窗口菜单</span></span><br><span class="line">    wndclass.lpszClassName = szClassName;  <span class="comment">//窗口类名</span></span><br><span class="line">    <span class="comment">//注册窗口</span></span><br><span class="line">    RegisterClass(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****第②步：创建窗口(并让窗口显示出来)*****/</span></span><br><span class="line">    hwnd = CreateWindow(</span><br><span class="line">        szClassName,  <span class="comment">//窗口类的名字</span></span><br><span class="line">        TEXT(<span class="string">&quot;Welcome&quot;</span>),  <span class="comment">//窗口标题（出现在标题栏）</span></span><br><span class="line">        WS_OVERLAPPEDWINDOW,  <span class="comment">//窗口风格</span></span><br><span class="line">        CW_USEDEFAULT,  <span class="comment">//初始化时x轴的位置</span></span><br><span class="line">        CW_USEDEFAULT,  <span class="comment">//初始化时y轴的位置</span></span><br><span class="line">        <span class="number">500</span>,  <span class="comment">//窗口宽度</span></span><br><span class="line">        <span class="number">300</span>,  <span class="comment">//窗口高度</span></span><br><span class="line">        <span class="literal">NULL</span>,  <span class="comment">//父窗口句柄</span></span><br><span class="line">        <span class="literal">NULL</span>,  <span class="comment">//窗口菜单句柄</span></span><br><span class="line">        hInstance,  <span class="comment">//当前窗口的句柄</span></span><br><span class="line">        <span class="literal">NULL</span>  <span class="comment">//不使用该值</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    ShowWindow(hwnd, iCmdShow);</span><br><span class="line">    <span class="comment">//更新（绘制）窗口</span></span><br><span class="line">    UpdateWindow(hwnd);</span><br><span class="line">    <span class="comment">/**********第③步：消息循环**********/</span></span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);  <span class="comment">//翻译消息</span></span><br><span class="line">        DispatchMessage(&amp;msg);  <span class="comment">//分派消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="keyword">static</span> HFONT hFont;  <span class="comment">//逻辑字体</span></span><br><span class="line">    <span class="keyword">static</span> HWND hLabUsername;  <span class="comment">//静态文本框--用户名</span></span><br><span class="line">    <span class="keyword">static</span> HWND hLabPassword;  <span class="comment">//静态文本框--密码</span></span><br><span class="line">    <span class="keyword">static</span> HWND hEditUsername;  <span class="comment">//单行文本输入框</span></span><br><span class="line">    <span class="keyword">static</span> HWND hEditPassword;  <span class="comment">//密码输入框</span></span><br><span class="line">    <span class="keyword">static</span> HWND hBtnLogin;  <span class="comment">//登录按钮</span></span><br><span class="line">    <span class="comment">//定义缓冲区</span></span><br><span class="line">    TCHAR szUsername[<span class="number">100</span>];</span><br><span class="line">    TCHAR szPassword[<span class="number">100</span>];</span><br><span class="line">    TCHAR szUserInfo[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">switch</span> (message) &#123;</span><br><span class="line">    <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">        <span class="comment">//创建逻辑字体</span></span><br><span class="line">        hFont = CreateFont(<span class="number">-14</span><span class="comment">/*高*/</span>, <span class="number">-7</span><span class="comment">/*宽*/</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span> <span class="comment">/*一般这个值设为400*/</span>,</span><br><span class="line">            FALSE<span class="comment">/*斜体?*/</span>, FALSE<span class="comment">/*下划线?*/</span>, FALSE<span class="comment">/*删除线?*/</span>, DEFAULT_CHARSET,</span><br><span class="line">            OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY,</span><br><span class="line">            FF_DONTCARE, TEXT(<span class="string">&quot;微软雅黑&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//创建静态文本框控件--用户名</span></span><br><span class="line">        hLabUsername = CreateWindow(TEXT(<span class="string">&quot;static&quot;</span>), TEXT(<span class="string">&quot;用户名：&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE <span class="comment">/*垂直居中*/</span> | SS_RIGHT <span class="comment">/*水平居右*/</span>,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*x坐标*/</span>, <span class="number">20</span> <span class="comment">/*y坐标*/</span>, <span class="number">70</span> <span class="comment">/*宽度*/</span>, <span class="number">26</span> <span class="comment">/*高度*/</span>,</span><br><span class="line">            hWnd <span class="comment">/*父窗口句柄*/</span>, (HMENU)<span class="number">1</span> <span class="comment">/*控件ID*/</span>, hInst <span class="comment">/*当前程序实例句柄*/</span>, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//创建静态文本框控件--密码</span></span><br><span class="line">        hLabPassword = CreateWindow(TEXT(<span class="string">&quot;static&quot;</span>), TEXT(<span class="string">&quot;密码：&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE <span class="comment">/*垂直居中*/</span> | SS_RIGHT <span class="comment">/*水平居右*/</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">26</span>,</span><br><span class="line">            hWnd, (HMENU)<span class="number">2</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//创建单行文本框控件</span></span><br><span class="line">        hEditUsername = CreateWindow(TEXT(<span class="string">&quot;edit&quot;</span>), TEXT(<span class="string">&quot;&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE | WS_BORDER <span class="comment">/*边框*/</span> | ES_AUTOHSCROLL <span class="comment">/*水平滚动*/</span>,</span><br><span class="line">            <span class="number">80</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">26</span>,</span><br><span class="line">            hWnd, (HMENU)<span class="number">3</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//创建密码输入框</span></span><br><span class="line">        hEditPassword = CreateWindow(TEXT(<span class="string">&quot;edit&quot;</span>), TEXT(<span class="string">&quot;&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE | WS_BORDER | ES_PASSWORD <span class="comment">/*密码*/</span> | ES_AUTOHSCROLL <span class="comment">/*水平滚动*/</span>,</span><br><span class="line">            <span class="number">80</span>, <span class="number">56</span>, <span class="number">200</span>, <span class="number">26</span>,</span><br><span class="line">            hWnd, (HMENU)<span class="number">4</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//创建按钮控件</span></span><br><span class="line">        hBtnLogin = CreateWindow(TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;登录&quot;</span>),</span><br><span class="line">            WS_CHILD | WS_VISIBLE | WS_BORDER | BS_FLAT<span class="comment">/*扁平样式*/</span>,</span><br><span class="line">            <span class="number">80</span>, <span class="number">92</span>, <span class="number">200</span>, <span class="number">30</span>,</span><br><span class="line">            hWnd, (HMENU)<span class="number">5</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//依次设置控件的字体</span></span><br><span class="line">        SendMessage(hLabUsername, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">        SendMessage(hLabPassword, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">        SendMessage(hEditUsername, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">        SendMessage(hEditPassword, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">        SendMessage(hBtnLogin, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">        wmId = LOWORD(wParam);</span><br><span class="line">        wmEvent = HIWORD(wParam);</span><br><span class="line">        <span class="keyword">switch</span> (wmId) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//按钮的HMENU参数</span></span><br><span class="line">            <span class="comment">//获取输入框的数据</span></span><br><span class="line">            GetWindowText(hEditUsername, szUsername, <span class="number">100</span>);</span><br><span class="line">            GetWindowText(hEditPassword, szPassword, <span class="number">100</span>);</span><br><span class="line">            wsprintf(szUserInfo, TEXT(<span class="string">&quot;C语言中文网提示：\r\n您的用户账号：%s\r\n您的用户密码：%s&quot;</span>), szUsername, szPassword);</span><br><span class="line">            MessageBox(hWnd, szUserInfo, TEXT(<span class="string">&quot;信息提示&quot;</span>), MB_ICONINFORMATION);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">        EndPaint(hWnd, &amp;ps);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        DeleteObject(hFont);</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="修改static控件背景颜色和文字颜色"><a href="#修改static控件背景颜色和文字颜色" class="headerlink" title="修改static控件背景颜色和文字颜色"></a>修改static控件背景颜色和文字颜色</h1><p>1.当 static 控件或具有 ES_READONLY 风格的 edit 控件被绘制时，会向父窗口发送 WM_CTLCOLORSTATIC 消息。如果我们在窗口过程中处理该消息，就必须返回一个画刷句柄，Windows 会使用该画刷来绘制控件背景（子窗口背景）。</p>
<p>所以，改变空间颜色的方法就是<strong>处理 WM_CTLCOLORSTATIC 消息。</strong></p>
<h2 id="修改文字背景颜色"><a href="#修改文字背景颜色" class="headerlink" title="修改文字背景颜色"></a>修改文字背景颜色</h2><p>1.修改文字背景颜色使用 SetBkColor 函数，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetBkColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC      hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    COLORREF crColor  <span class="comment">//背景颜色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>2.修改文字前景色（文字颜色）使用 SetTextColor 函数，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">SetTextColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC      hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    COLORREF crColor  <span class="comment">//背景颜色</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里我们修改的是 static 控件中的文本颜色，所以需要获取 static 控件的设备环境句柄。</p>
<p>非常巧妙的是，发送 WM_CTLCOLORSTATIC 消息时，<strong>wParam 参数表示的就是 static 控件的设备环境句柄（lParam 表示控件句柄）。</strong></p>
<h2 id="透明背景"><a href="#透明背景" class="headerlink" title="透明背景"></a>透明背景</h2><p>实现透明背景需要设置文本背景颜色透明，同时返回没有颜色的画刷。</p>
<p>1.SetBkMode 函数可以用来设置文本的背景模式，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetBkMode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HDC hdc,  <span class="comment">//设备环境句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> iBkMode  <span class="comment">//背景模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>iBkMode 有下面两种取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPAQUE</td>
<td>使用当前背景颜色来填充背景。</td>
</tr>
<tr>
<td>TRANSPARENT</td>
<td>背景透明。</td>
</tr>
</tbody>
</table>
</div>
<p>2.GetStockObject (NULL_BRUSH); 语句可以返回没有颜色的画刷。示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CTLCOLORSTATIC:</span><br><span class="line">    hdcStatic = (HDC)wParam;</span><br><span class="line">    SetTextColor( hdcStatic, RGB(<span class="number">0x41</span>, <span class="number">0x96</span>, <span class="number">0x4F</span>) );  <span class="comment">//翠绿色</span></span><br><span class="line">    SetBkMode(hdcStatic, TRANSPARENT);  <span class="comment">//透明背景</span></span><br><span class="line">    <span class="keyword">return</span> (INT_PTR)GetStockObject(NULL_BRUSH);  <span class="comment">//无颜色画刷</span></span><br></pre></td></tr></table></figure>
<h1 id="Windows单选按钮、复选框、分组框控件"><a href="#Windows单选按钮、复选框、分组框控件" class="headerlink" title="Windows单选按钮、复选框、分组框控件"></a>Windows单选按钮、复选框、分组框控件</h1><p>单选按钮和复选框都是一种特殊的按钮，窗口类名称都是<code>button</code></p>
<p>单选按钮的样式为<code>BS_AUTORADIOBUTTON</code>，复选框的样式为<code>BS_AUTOCHECKBOX</code>。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个单选按钮</span></span><br><span class="line">CreateWindow(</span><br><span class="line">    TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;单选按钮&quot;</span>),</span><br><span class="line">    WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON<span class="comment">/*单选按钮*/</span>,</span><br><span class="line">    <span class="number">235</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">26</span>,</span><br><span class="line">    hWnd, (HMENU)<span class="number">7</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//创建一个复选框</span></span><br><span class="line">CreateWindow(</span><br><span class="line">    TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;复选框&quot;</span>),</span><br><span class="line">    WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTOCHECKBOX<span class="comment">/*复选框*/</span>,</span><br><span class="line">    <span class="number">95</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">    hWnd, (HMENU)<span class="number">9</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>想为<strong>单选按钮分组</strong>，可以增加<code>WS_GROUP</code>样式。设置了 WS_GROUP 样式的单选框为一组中的首元素，随后的所有单选按钮都和它在同一组，直到下一个设置了 WS_GROUP 样式的单选按钮。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口过程</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="keyword">static</span> HFONT hFont;  <span class="comment">//逻辑字体</span></span><br><span class="line">    <span class="comment">//一组单选按钮</span></span><br><span class="line">    <span class="keyword">static</span> HWND labSex;  <span class="comment">//静态文本框--性别</span></span><br><span class="line">    <span class="keyword">static</span> HWND radioMale;  <span class="comment">//单选按钮--男</span></span><br><span class="line">    <span class="keyword">static</span> HWND radioFemale;  <span class="comment">//单选按钮--女</span></span><br><span class="line">    <span class="comment">//一组单选按钮</span></span><br><span class="line">    <span class="keyword">static</span> HWND labMarriage;  <span class="comment">//静态文本框--婚姻状况</span></span><br><span class="line">    <span class="keyword">static</span> HWND radioMarried;  <span class="comment">//单选按钮--已婚</span></span><br><span class="line">    <span class="keyword">static</span> HWND radioSingle;  <span class="comment">//单选按钮--未婚</span></span><br><span class="line">    <span class="keyword">static</span> HWND radioSecrecy;  <span class="comment">//单选按钮--保密</span></span><br><span class="line">    <span class="comment">//一组复选框</span></span><br><span class="line">    <span class="keyword">static</span> HWND labPet;  <span class="comment">//静态文本框--你的宠物</span></span><br><span class="line">    <span class="keyword">static</span> HWND checkboxDog;  <span class="comment">//复选框--狗</span></span><br><span class="line">    <span class="keyword">static</span> HWND checkboxCat;  <span class="comment">//复选框--猫</span></span><br><span class="line">    <span class="keyword">static</span> HWND checkboxFish;  <span class="comment">//复选框--鱼</span></span><br><span class="line">    <span class="keyword">static</span> HWND checkboxOther;  <span class="comment">//复选框--其他</span></span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">            hFont = CreateFont(</span><br><span class="line">                <span class="number">-14</span>, <span class="number">-7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>,</span><br><span class="line">                FALSE, FALSE, FALSE,DEFAULT_CHARSET,</span><br><span class="line">                OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY,</span><br><span class="line">                FF_DONTCARE, TEXT(<span class="string">&quot;微软雅黑&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//选择性别</span></span><br><span class="line">            labSex = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;static&quot;</span>), TEXT(<span class="string">&quot;你的性别：&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE | SS_RIGHT<span class="comment">/*文字居右*/</span>,</span><br><span class="line">                <span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">1</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            radioMale = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;男&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT<span class="comment">/*文字居左*/</span> | BS_AUTORADIOBUTTON <span class="comment">/*单选按钮*/</span> | WS_GROUP,</span><br><span class="line">                <span class="number">95</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">2</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            radioFemale = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;女&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON,</span><br><span class="line">                <span class="number">150</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">2</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//选择婚姻状况</span></span><br><span class="line">            labMarriage = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;static&quot;</span>), TEXT(<span class="string">&quot;婚姻状况：&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE | SS_RIGHT,</span><br><span class="line">                <span class="number">10</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">4</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            radioMarried = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;已婚&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON | WS_GROUP,</span><br><span class="line">                <span class="number">95</span>, <span class="number">40</span>, <span class="number">65</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">5</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            radioSingle = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;未婚&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON,</span><br><span class="line">                <span class="number">165</span>, <span class="number">40</span>, <span class="number">65</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">6</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            radioSecrecy = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;保密&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON,</span><br><span class="line">                <span class="number">235</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">7</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//你的宠物</span></span><br><span class="line">            labPet = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;static&quot;</span>), TEXT(<span class="string">&quot;你的宠物：&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE | SS_RIGHT,</span><br><span class="line">                <span class="number">10</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">8</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">           </span><br><span class="line">            checkboxDog = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;狗&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTOCHECKBOX<span class="comment">/*复选框*/</span>,</span><br><span class="line">                <span class="number">95</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">9</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            checkboxCat = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;猫&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTOCHECKBOX,</span><br><span class="line">                <span class="number">150</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">10</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            checkboxFish = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;鱼&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTOCHECKBOX,</span><br><span class="line">                <span class="number">205</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">11</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            checkboxOther = CreateWindow(</span><br><span class="line">                TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;其他&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTOCHECKBOX,</span><br><span class="line">                <span class="number">260</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">26</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">11</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            SendMessage(labSex, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(radioMale, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(radioFemale, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(labMarriage, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(radioMarried, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(radioSingle, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(radioSecrecy, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(labPet, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(checkboxDog, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(checkboxCat, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(checkboxFish, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            SendMessage(checkboxOther, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">            hdc = BeginPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span>  在此添加任意绘图代码...</span></span><br><span class="line">            EndPaint(hWnd, &amp;ps);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">            PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分组框控件"><a href="#分组框控件" class="headerlink" title="分组框控件"></a>分组框控件</h2><p>分组框控件也是一种特殊的按钮，它的样式为<code>BS_GROUPBOX</code>，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建分组框控件</span></span><br><span class="line">hGroupSex = CreateWindow(</span><br><span class="line">    TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;你的性别&quot;</span>),</span><br><span class="line">    WS_CHILD | WS_VISIBLE | BS_GROUPBOX,</span><br><span class="line">    <span class="number">20</span>, <span class="number">20</span>, <span class="number">300</span>, <span class="number">70</span>,</span><br><span class="line">    hWnd, (HMENU)<span class="number">1</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//接下来添加单选按钮</span></span><br><span class="line">hRadioMale = CreateWindow(</span><br><span class="line">    TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;男&quot;</span>),</span><br><span class="line">    WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON <span class="comment">/*单选按钮*/</span>,</span><br><span class="line">    <span class="number">15</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">    hGroupSex <span class="comment">/*父窗口为 GroupBox 控件*/</span>, (HMENU)<span class="number">2</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">hRadioFemale = CreateWindow(</span><br><span class="line">    TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;女&quot;</span>),</span><br><span class="line">    WS_CHILD | WS_VISIBLE | BS_LEFT | BS_AUTORADIOBUTTON,</span><br><span class="line">    <span class="number">80</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">26</span>,</span><br><span class="line">    hGroupSex, (HMENU)<span class="number">3</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意父子窗口关系：需要注意的是：单选按钮的父窗口为分组框控件 hGroupSex，而不是顶级窗口 hWnd。</p>
<h1 id="判断单选按钮和复选框是否被选中"><a href="#判断单选按钮和复选框是否被选中" class="headerlink" title="判断单选按钮和复选框是否被选中"></a>判断单选按钮和复选框是否被选中</h1><p>对于一组单选按钮，只有一个选项能被选中，最好的办法是将这组按钮作为参数传入一个函数，通过函数返回值判断哪个按钮被选中了。</p>
<p>但遗憾的是<strong>，在Windows中不能一次性获得一组按钮的选中状态，只能一个一个地遍历。复选框也是如此。</strong></p>
<p>解决：可以通过<code>SendMessage</code>函数发送<code>BM_GETCHECK</code>消息来获取按钮的选中状态，返回 BST_CHECKED 表示按钮被选中，返回 BST_UNCHECKED 是未被选中。</p>
<p>SendMessage 原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT WINAPI <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND   hWnd,  <span class="comment">//窗口（控件）句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT   Msg,  <span class="comment">//消息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,  <span class="comment">//附加消息1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam  <span class="comment">//附加消息2</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意：发送 BM_GETCHECK 消息时，wParam 和 lParam 两个参数必须都为 0。</strong></p>
<p>如果被选中，那么会获取按钮文本并保存到缓冲区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( SendMessage(hCheckBox, BM_GETCHECK, <span class="number">0</span>, <span class="number">0</span>) == BST_CHECKED )</span><br><span class="line">&#123;</span><br><span class="line">    GetWindowText(hCheckBox, szBuffer,  <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wmId, wmEvent;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc;</span><br><span class="line">    <span class="comment">//设置缓冲区</span></span><br><span class="line">    <span class="keyword">static</span> TCHAR szBufSex[<span class="number">10</span>];  <span class="comment">//保存性别</span></span><br><span class="line">    <span class="keyword">static</span> TCHAR szBufMarriage[<span class="number">10</span>];  <span class="comment">//保存婚姻状况</span></span><br><span class="line">    <span class="keyword">static</span> TCHAR szBufPet[<span class="number">20</span>];  <span class="comment">//保存宠物</span></span><br><span class="line">    <span class="keyword">static</span> TCHAR szBufSubmit[<span class="number">100</span>];  <span class="comment">//保存提交时显示的文本</span></span><br><span class="line">    <span class="keyword">static</span> TCHAR szBufTmp[<span class="number">10</span>];  <span class="comment">//临时缓冲区</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了节省空间，这里省略了各种控件句柄的定义</span></span><br><span class="line"><span class="comment">     * 这里的代码与上节相同，请参考上节代码</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">static</span> HWND btnSubmit;  <span class="comment">//按钮控件</span></span><br><span class="line">    <span class="keyword">switch</span> (message)&#123;</span><br><span class="line">        <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为了节省空间，这里省略了创建各种控件的语句</span></span><br><span class="line"><span class="comment">             * 这里的代码与上节相同，请参考上节代码</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="comment">//创建按钮控件</span></span><br><span class="line">            btnSubmit = CreateWindow(TEXT(<span class="string">&quot;button&quot;</span>), TEXT(<span class="string">&quot;提 交&quot;</span>),</span><br><span class="line">                WS_CHILD | WS_VISIBLE | WS_BORDER | BS_FLAT,</span><br><span class="line">                <span class="number">95</span>, <span class="number">110</span>, <span class="number">200</span>, <span class="number">36</span>,</span><br><span class="line">                hWnd, (HMENU)<span class="number">13</span>, hInst, <span class="literal">NULL</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为了节省空间，这里省略了设置字体的语句</span></span><br><span class="line"><span class="comment">             * 这里的代码与上节相同，请参考上节代码</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            SendMessage(btnSubmit, WM_SETFONT, (WPARAM)hFont, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//这里是重点</span></span><br><span class="line">        <span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">            wmId    = LOWORD(wParam);</span><br><span class="line">            wmEvent = HIWORD(wParam);</span><br><span class="line">            <span class="keyword">if</span>( wmEvent==  BN_CLICKED)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (wmId)&#123;</span><br><span class="line">                    <span class="comment">//获取性别</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        GetWindowText((HWND)lParam, szBufSex, <span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//获取婚姻状况</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                        GetWindowText((HWND)lParam, szBufMarriage, <span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//获取宠物</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                        <span class="built_in">memset</span>(szBufPet, <span class="number">0</span>, <span class="keyword">sizeof</span>(szBufPet));</span><br><span class="line">                        <span class="comment">//是否选中狗</span></span><br><span class="line">                        <span class="keyword">if</span>( SendMessage(checkboxDog, BM_GETCHECK, <span class="number">0</span>, <span class="number">0</span>) == BST_CHECKED )&#123;</span><br><span class="line">                            GetWindowText(checkboxDog, szBufTmp,  <span class="number">10</span>);</span><br><span class="line">                            wsprintf(szBufPet, TEXT(<span class="string">&quot;%s  %s&quot;</span>), szBufPet, szBufTmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//是否选中猫</span></span><br><span class="line">                        <span class="keyword">if</span>( SendMessage(checkboxCat, BM_GETCHECK, <span class="number">0</span>, <span class="number">0</span>) == BST_CHECKED )&#123;</span><br><span class="line">                            GetWindowText(checkboxCat, szBufTmp, <span class="number">10</span>);</span><br><span class="line">                            wsprintf(szBufPet, TEXT(<span class="string">&quot;%s  %s&quot;</span>), szBufPet, szBufTmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//是否选中鱼</span></span><br><span class="line">                        <span class="keyword">if</span>( SendMessage(checkboxFish, BM_GETCHECK, <span class="number">0</span>, <span class="number">0</span>) == BST_CHECKED )&#123;</span><br><span class="line">                            GetWindowText(checkboxFish, szBufTmp, <span class="number">10</span>);</span><br><span class="line">                            wsprintf(szBufPet, TEXT(<span class="string">&quot;%s  %s&quot;</span>), szBufPet, szBufTmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//是否选中其他</span></span><br><span class="line">                        <span class="keyword">if</span>( SendMessage(checkboxOther, BM_GETCHECK, <span class="number">0</span>, <span class="number">0</span>) == BST_CHECKED )&#123;</span><br><span class="line">                            GetWindowText(checkboxOther, szBufTmp, <span class="number">10</span>);</span><br><span class="line">                            wsprintf(szBufPet, TEXT(<span class="string">&quot;%s  %s&quot;</span>), szBufPet, szBufTmp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//点击提交按钮</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                        wsprintf(szBufSubmit, TEXT(<span class="string">&quot;你的性别：%s\n婚姻状况：%s\r\n你的宠物：%s&quot;</span>), szBufSex, szBufMarriage, szBufPet);</span><br><span class="line">                        MessageBox(hWnd, szBufSubmit, TEXT(<span class="string">&quot;信息提示&quot;</span>), MB_ICONINFORMATION);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了节省空间，这里省略了部分语句</span></span><br><span class="line"><span class="comment">         * 这里的代码与上节相同，请参考上节代码</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.用户点击控件时会产生 WM_COMMAND 消息，这时 wParam 参数的低16位表示控件ID，高16位表示控件通知码，lParam 表示控件句柄。</p>
<p>2.对于单选按钮，根据控件ID判断当前按钮是否被选中，是的话就获取按钮文本，保存到缓冲区。</p>
<p>3.对于复选框，根据控件ID判断当前复选框是否被选中，是的话就需要<strong>遍历所有复选框</strong>，检测它们的选中状态，并将所有被选中的复选框的文本保存到缓冲区。</p>
<p><strong><em>PS:单选按钮可以不发送 BM_GETCHECK 消息，因为一组中只能有一个被选中，就是当前被点击的这个。而复选框就不同了，一组中可以有多个被选中，所以必须发送 BM_GETCHECK 消息检测其他复选框的选中状态。</em></strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
      </tags>
  </entry>
</search>
